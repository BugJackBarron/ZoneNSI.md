{"config":{"indexing":"full","lang":["fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nouvelle version Ceci est mon nouveau site. Il est prioritairement \u00e0 destination de mes \u00e9l\u00e8ves, mais vous pouvez m'envoyer vos commentaires par le lien situ\u00e9 en bas de page. L'ancien site peut-\u00eatre trouv\u00e9 ici .","title":"Home"},{"location":"#nouvelle-version","text":"Ceci est mon nouveau site. Il est prioritairement \u00e0 destination de mes \u00e9l\u00e8ves, mais vous pouvez m'envoyer vos commentaires par le lien situ\u00e9 en bas de page. L'ancien site peut-\u00eatre trouv\u00e9 ici .","title":"Nouvelle version"},{"location":"WorkInProgress/","text":"","title":"Manim"},{"location":"Maths/Seconde/home/","text":"Le programme Documents officiels Le programme de maths de seconde se trouve ici . Pr\u00e9vision de progression annuelle 2021-2022 Cette progression n'est valable que pour les \u00e9l\u00e8ves de seconde I du Lyc\u00e9e Pavie de Guingamp, et est sujette \u00e0 modifications au cours de l'ann\u00e9e... N\u00b0 Chapitre Dur\u00e9e Estim\u00e9e Dates pr\u00e9vues Dates effectives Remarques 1 Ensembles et intervalles 2 Notions de vecteurs 3 G\u00e9n\u00e9ralit\u00e9s sur les fonctions 4 Configuration du plan et orthogonalit\u00e9 5 Calcul litt\u00e9ral 6 Fonctions de r\u00e9f\u00e9rences 1 (affines et carr\u00e9s) 7 G\u00e9om\u00e9trie rep\u00e9r\u00e9e 8 Arithm\u00e9tique 9 Pourcentages 10 Fonctions de r\u00e9f\u00e9rences 2 11 Probabilit\u00e9s 12 Equations cart\u00e9siennes et syst\u00e8mes 13 Statistiques 14 Echantillonage A toutes ces notions, il faut rajouter les bases d'algorithmique et de programmation en Python : Types de variables ; Affectations de variables ; Structures conditionnelles : Boucles born\u00e9es et non-born\u00e9es. Epreuves communes Deux \u00e9preuves communes sont pr\u00e9vues pour l'ann\u00e9e 2021-2022 : la premi\u00e8re juste avant les vacances de la toussaint, sur les chapitres 1 \u00e0 3 La deuxi\u00e8me avant les vacances de f\u00e9vrier, sur les chapitres 1 \u00e0 7.","title":"Pr\u00e9sentation"},{"location":"Maths/Seconde/home/#le-programme","text":"","title":"Le programme"},{"location":"Maths/Seconde/home/#documents-officiels","text":"Le programme de maths de seconde se trouve ici .","title":"Documents officiels"},{"location":"Maths/Seconde/home/#prevision-de-progression-annuelle-2021-2022","text":"Cette progression n'est valable que pour les \u00e9l\u00e8ves de seconde I du Lyc\u00e9e Pavie de Guingamp, et est sujette \u00e0 modifications au cours de l'ann\u00e9e... N\u00b0 Chapitre Dur\u00e9e Estim\u00e9e Dates pr\u00e9vues Dates effectives Remarques 1 Ensembles et intervalles 2 Notions de vecteurs 3 G\u00e9n\u00e9ralit\u00e9s sur les fonctions 4 Configuration du plan et orthogonalit\u00e9 5 Calcul litt\u00e9ral 6 Fonctions de r\u00e9f\u00e9rences 1 (affines et carr\u00e9s) 7 G\u00e9om\u00e9trie rep\u00e9r\u00e9e 8 Arithm\u00e9tique 9 Pourcentages 10 Fonctions de r\u00e9f\u00e9rences 2 11 Probabilit\u00e9s 12 Equations cart\u00e9siennes et syst\u00e8mes 13 Statistiques 14 Echantillonage A toutes ces notions, il faut rajouter les bases d'algorithmique et de programmation en Python : Types de variables ; Affectations de variables ; Structures conditionnelles : Boucles born\u00e9es et non-born\u00e9es.","title":"Pr\u00e9vision de progression annuelle 2021-2022"},{"location":"Maths/Seconde/home/#epreuves-communes","text":"Deux \u00e9preuves communes sont pr\u00e9vues pour l'ann\u00e9e 2021-2022 : la premi\u00e8re juste avant les vacances de la toussaint, sur les chapitres 1 \u00e0 3 La deuxi\u00e8me avant les vacances de f\u00e9vrier, sur les chapitres 1 \u00e0 7.","title":"Epreuves communes"},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/","text":"C01-01 : Ensembles de Nombres La version pdf de ce cours est t\u00e9l\u00e9chargeable ici . (version 2021-2022) Activit\u00e9 : Classer des nombres Dans la liste ci-dessus, deux \u00e9critures sont interdites. Lesquelles et pourquoi ? Classer les nombres restants en cinq groupes , en justifiant vos choix. Diff\u00e9rence entres propri\u00e9t\u00e9s et \u00e9critures Un nombre peut \u00eatre \u00e9crit de diff\u00e9rentes mani\u00e8res, plus ou moins compliqu\u00e9es. Par exemple : \\[ 2 = \\cfrac{6}{3} = 20 \\times 10^{-1} = \\sqrt{4}= - \\left(-2\\right) = 2,0000 \\] Pour autant, ce qui nous int\u00e9resse en math\u00e9matiques c'est d'\u00e9tudier les propri\u00e9t\u00e9s de ce nombre, qui elles sont ind\u00e9pendantes de l'\u00e9criture de ce nombre. Nombres entiers naturels et relatifs D\u00e9finitions L'ensemble des entiers naturels , not\u00e9 \\(\\mathbb{N}\\) , est l'ensemble des nombres permettant de d\u00e9nombrer une collection d'objets, de personnes, etc, c'est-\u00e0-dire la suite naturelle \\(0~;~1~;~2~;~3~;~...\\) L'ensemble des entiers relatifs , not\u00e9 \\(\\mathbb{Z}\\) , est l'ensemble des entiers naturels et leurs oppos\u00e9s , c'est-\u00e0-dire la suite \\(...~;~-3~;~-2~;~-1~;~0~;~1~;~2~;~3~;~...\\) Info L'ensemble \\(\\mathbb{N}\\) poss\u00e8de un plus petit \u00e9l\u00e9ment, c'est \\(0\\) . Les nombres entiers naturels sont tous positifs ou nuls . Tous les entiers naturels sont aussi des entiers relatifs . Vocabulaire et notations Appartenance : On dit que \\(5\\) appartient \u00e0 \\(\\mathbb{N}\\) , et on note \\(5 \\in \\mathbb{N}\\) . De m\u00eame \\(-2\\) n'appartient pas \u00e0 \\(\\mathbb{N}\\) , et on note \\(-12 \\notin \\mathbb{N}\\) . Inclusion : Tous les \u00e9l\u00e9ments de \\(\\mathbb{N}\\) sont aussi des \u00e9l\u00e9ments de \\(\\mathbb{Z}\\) . On dit alors que \\(\\mathbb{N}\\) est un sous-ensemble de \\(\\mathbb{Z}\\) et on note alors \\(\\mathbb{N} \\subset \\mathbb{Z}\\) (qui se lit \\(\\mathbb{N}\\) est inclus dans \\(\\mathbb{Z}\\) ). Application : choix du bon symbole Exercice Compl\u00e9ter avec \\(\\in\\) ou \\(\\notin\\) : \\(7 \\dots \\mathbb{N}\\) \\(-3 \\dots \\mathbb{N}\\) \\(-5 \\dots \\mathbb{Z}\\) \\(7 \\dots \\mathbb{Z}\\) \\(\\dfrac{1}{3} \\dots \\mathbb{N}\\) \\(\\sqrt{9} \\dots \\mathbb{N}\\) \\(-\\sqrt{25} \\dots \\mathbb{N}\\) \\(-\\sqrt{2} \\dots \\mathbb{Z}\\) \\(5 \\times 10^{3} \\dots \\mathbb{N}\\) \\(5 \\times 10 ^{-3} \\dots \\mathbb{Z}\\) \\(-4,2 \\dots \\mathbb{Z}\\) \\(3 \\times (1 - \\dfrac{1}{3}) \\dots \\mathbb{N}\\) Solution Compl\u00e9ter avec \\(\\in\\) ou \\(\\notin\\) : \\(7 \\in \\mathbb{N}\\) \\(-3 \\notin \\mathbb{N}\\) \\(-5 \\in \\mathbb{Z}\\) \\(7 \\in \\mathbb{Z}\\) \\(\\dfrac{1}{3} \\notin \\mathbb{N}\\) \\(\\sqrt{9} \\in \\mathbb{N}\\) car \\(\\sqrt{9} = 3\\) \\(-\\sqrt{25} \\notin \\mathbb{N}\\) car \\(-\\sqrt{25} = -5\\) \\(-\\sqrt{2} \\notin \\mathbb{Z}\\) car \\(-\\sqrt{2} \\simeq -1,414...\\) \\(5 \\times 10^{3} \\in \\mathbb{N}\\) car \\(5 \\times 10^3 = 5 \\times 1000 = 5000\\) \\(5 \\times 10 ^{-3} \\notin \\mathbb{Z}\\) car \\(5 \\times 10 ^{-3} = 5 \\times 0,001 = 0,005\\) \\(-4,2 \\notin \\mathbb{Z}\\) \\(3 \\times (1 - \\dfrac{1}{3}) \\in \\mathbb{N}\\) car \\(3 \\times (1 - \\dfrac{1}{3}) = 3 - 1 = 2\\) (en d\u00e9veloppant) ou \\(3 \\times (1 - \\dfrac{1}{3}) = 3 \\times \\dfrac{2}{3} = 2\\) (en calculant entre parenth\u00e8ses). Nombres d\u00e9cimaux d\u00e9finition : Nombres d\u00e9cimaux Un nombre d\u00e9cimal est un nombre pouvant s'\u00e9crire sous la forme d'une fraction d\u00e9cimale , c'est \u00e0 dire sous la forme $$ \\dfrac{a}{10^n} $$ avec \\(a\\in \\mathbb{Z}\\) et \\(n\\in \\mathbb{N}\\) . L'ensemble des d\u00e9cimaux est not\u00e9 \\(\\mathbb{D}\\) . Application : Nombres d\u00e9cimaux et puissances de 10 Exercice Pour chacun des nombres suivants, d\u00e9terminer si possible une \u00e9criture de la forme \\(\\dfrac{k}{10^n}\\) . \\(4,37\\) \\(0,002\\) \\(-12\\) \\(\\dfrac{1}{3}\\) \\(\\dfrac{2}{5}\\) \\(\\sqrt{0,16}\\) \\(10^3\\) \\(10^{-5}\\) \\(-10^5\\) \\(\\dfrac{3.10^5}{10^7}\\) \\(\\dfrac{10^7}{3.10^5}\\) Solution Pour chacun des nombres suivants, d\u00e9terminer si possible une \u00e9criture de la forme \\(\\dfrac{k}{10^n}\\) . \\(4,37 = \\dfrac{437}{100} = \\dfrac{437}{10^{2}}\\) \\(0,002 = \\dfrac{2}{1~000} = \\dfrac{2}{10^{3}}\\) \\(-12 = \\dfrac{-12}{1} = \\dfrac{-12}{10^{0}}\\) ( car \\(a^0 =1\\) pour tout nombre \\(a \\neq 0\\) ). \\(\\dfrac{1}{3} \\notin \\mathbb{D}\\) car \\(\\dfrac{1}{3} \\simeq 0,333...\\) (La d\u00e9monstration r\u00e9elle sera donn\u00e9e plus tard dans l'ann\u00e9e) \\(\\dfrac{2}{5} = \\dfrac{4}{10} = \\dfrac{4}{10^1}\\) \\(\\sqrt{0,16} = 0,4 = \\dfrac{4}{10} = \\dfrac{4}{10^1}\\) \\(10^3 = \\dfrac{1~000}{1} = \\dfrac{1~000}{10^{0}}\\) \\(10^{-5} = \\dfrac{1}{10^5}\\) (par d\u00e9finition des exposants n\u00e9gatifs \\(a^{-n} = \\dfrac{1}{a^n}\\) pour tout \\(n \\in \\mathbb{Z}\\) si \\(a \\neq 0\\) ) \\(-10^5 = - 100~000 = \\dfrac{- 100~000}{1} = \\dfrac{- 100~000}{10^{0}}\\) $ \\(\\dfrac{3.10^5}{10^7} = \\dfrac{3}{10^2}\\) par division des puissances ( \\(\\dfrac{a^m}{a^n} = a^{m-n}\\) pour tout \\(m,n \\in \\Z\\) ) \\(\\dfrac{10^7}{3.10^5} = \\dfrac{10^2}{3} \\simeq 33,333.... \\notin \\mathbb{D}\\) Remarques Les entiers relatifs sont des d\u00e9cimaux, car si \\(k \\in \\mathbb{Z}\\) , on peut aussi \u00e9crire \\(k=\\dfrac{k}{1}=\\dfrac{k}{10^0}\\) . On a donc la propri\u00e9t\u00e9 \\(\\mathbb{Z} \\subset \\mathbb{D}\\) . Un nombre d\u00e9cimal poss\u00e8de une \u00e9criture d\u00e9cimale finie . Nombres rationnels D\u00e9finition : Nombres rationnels Un nombre rationnel est un nombre pouvant s'\u00e9crire sous la forme \\(\\dfrac{a}{b}\\) avec \\(a\\in \\mathbb{Z}\\) et \\(b\\in \\mathbb{N}^{*}\\) (c'est-\u00e0-dire \\(\\mathbb{N}\\) priv\u00e9 de \\(0\\) ). L'ensemble des nombres rationnels est not\u00e9 \\(\\mathbb{Q}\\) . Remarque Un nombre d\u00e9cimal est par d\u00e9finition un nombre rationnel. Par d\u00e9finition de \\(\\mathbb{D}\\) et \\(\\mathbb{Q}\\) , on a la propri\u00e9t\u00e9 \\(\\mathbb{D} \\subset \\mathbb{Q}\\) . Propri\u00e9t\u00e9 : Caract\u00e9risation des rationnels non d\u00e9cimaux Tous les nombres rationnels ne poss\u00e8dent pas d'\u00e9criture d\u00e9cimale finie. En particulier, \\(\\dfrac{1}{3}\\) n'est pas d\u00e9cimal. Preuve La d\u00e9monstration de cette propri\u00e9t\u00e9 sera faite plus tard dans l'ann\u00e9e, dans le chapitre arithm\u00e9tique. Remarques Les nombres rationnels non d\u00e9cimaux poss\u00e8dent une \u00e9criture d\u00e9cimale infinie p\u00e9riodique , c'est-\u00e0-dire avec une s\u00e9rie de chiffres qui se r\u00e9p\u00e8tent \u00e0 l'infini. Par exemple \\(\\dfrac{1}{7} = 0,14285714285714...\\) (on constate la r\u00e9p\u00e9tition de la s\u00e9quence 142857}). R\u00e9ciproquement, si un nombre poss\u00e8de une \u00e9criture d\u00e9cimale infinie p\u00e9riodique, alors c'est un rationnel. M\u00e9thode : D\u00e9terminer une fraction \u00e9gale \u00e0 une \u00e9criture d\u00e9cimale infinie p\u00e9riodique On consid\u00e8re le nombre \\(a\\) dont l'\u00e9criture d\u00e9cimale est infinie p\u00e9riodique \\(a = 2,71347134...\\) . D\u00e9montrons que ce nombre est rationnel. Solution On constate que la partie r\u00e9p\u00e9titive des chiffres de \\(a\\) est \\(7134\\) , donc de taille 4. Donc \\(10^4 \\times a = 10~000\\times a = 27134,71347134...\\) . D'o\u00f9 \\(10~000\\times a - a = 27134,71347134... - 2,71347134... = 27134 -2 = 27~132\\) . Or \\(10~000\\times a - a = 9~999\\times a\\) . D'apr\u00e8s les deux lignes pr\u00e9c\u00e9dentes, on a alors \\(9~999\\times a = 27132\\) soit \\(a = \\dfrac{27~132}{9~999} = \\dfrac{9~044}{3~333}\\) . Donc \\(a\\) est bien un nombre rationnel puisqu'il s'\u00e9crit sous la forme d'une fraction. Application : Calculs avec les rationnels Exercice Dans chacun des cas suivants, calculer \u00e0 la main chacune des expressions suivantes : \\(A = \\dfrac {5}{7} - \\dfrac{3}{11}\\) \\(B = -\\dfrac {4}{3} + \\dfrac{7}{8}\\) \\(C = \\dfrac {3}{8} - \\dfrac{5}{12}\\) \\(D = \\dfrac {-6}{7} \\times \\dfrac{8}{9}\\) \\(E = \\dfrac {3}{2} \\times \\left(-\\dfrac{7}{3}\\right)\\) \\(F = \\dfrac {48}{35} \\times \\dfrac{25}{64}\\) \\(G = \\dfrac {4}{7} \\div \\dfrac{8}{21}\\) \\(H = \\dfrac{~~\\dfrac{3}{4}~~}{\\dfrac{18}{20}}\\) \\(I = \\dfrac{~~7~~}{\\dfrac{5}{3}}\\) \\(J = \\dfrac{~~\\dfrac{7}{5}~~}{3}\\) Solution \\(A = \\dfrac {5}{7} - \\dfrac{3}{11} = \\dfrac {5\\times 11}{7\\times 11} - \\dfrac{3\\times 7}{11\\times 7} = \\dfrac {55}{77} - \\dfrac{21}{77} = \\dfrac{34}{77}\\) \\(B = -\\dfrac {4}{3} + \\dfrac{7}{8} = -\\dfrac {4 \\times 8}{3 \\times 8} + \\dfrac{7 \\times 3}{8 \\times 3} = -\\dfrac {32}{24} + \\dfrac{21}{24} -\\dfrac {11}{24}\\) \\(C = \\dfrac {3}{8} - \\dfrac{5}{12} = \\dfrac {3\\times 3}{8\\times 3} - \\dfrac{5 \\times 2}{12 \\times 2} = \\dfrac {9}{24} - \\dfrac{10}{24} = - \\dfrac{1}{24}\\) \\(D = \\dfrac {-6}{7} \\times \\dfrac{8}{9} = \\dfrac{-6 \\times 8}{7 \\times 9} = \\dfrac{-2 \\times 3 \\times 8}{7 \\times 3 \\times 3} = -\\dfrac{16}{21}\\) N'oubliez pas de simplifier ! \\(E = \\dfrac {3}{2} \\times \\left(-\\dfrac{7}{3}\\right) = -\\dfrac {3 \\times 7}{2 \\times3} = - \\dfrac{7}{2}\\) \\(F = \\dfrac {48}{35} \\times \\dfrac{25}{64} = \\dfrac{48 \\times 25}{35 \\times 64} = \\dfrac{2 \\times 3 \\times 8 \\times 5 \\times 5}{5\\times 7 \\times 2 \\times 4 \\times 8} = \\dfrac{15}{28}\\) \\(G = \\dfrac {4}{7} \\div \\dfrac{8}{21} = \\dfrac {4}{7} \\times \\dfrac{21}{8} = \\dfrac{4 \\times 21}{7 \\times 8} = \\dfrac{ 4 \\times 3 \\times 7}{7 \\times 2 \\times 4} = \\dfrac{3}{2}\\) \\(H = \\dfrac{~~\\dfrac{3}{4}~~}{\\dfrac{18}{20}} = \\dfrac{3}{4}\\div\\dfrac{18}{20} = \\dfrac{3}{4}\\div\\dfrac{20}{18} = \\dfrac{3 \\times 4 \\times 5}{ 4 \\times 3 \\times 6} = \\dfrac{5}{6}\\) . \\(I = \\dfrac{~~7~~}{\\dfrac{5}{3}} = 7 \\div \\dfrac{5}{3} = 7 \\times \\dfrac{3}{5} = \\dfrac{21}{5}\\) \\(J = \\dfrac{~~\\dfrac{7}{5}~~}{3} = \\dfrac{7}{5} \\div 3 = \\dfrac{7}{5} \\times \\dfrac{1}{3} = \\dfrac{7}{15}\\) Nombres r\u00e9els D\u00e9finition : Nombres r\u00e9els Un {==nombre r\u00e9el est un nombre exprimant une longueur, ou l'oppos\u00e9 d'un nombre exprimant une longueur. L'ensemble des nombres rationnels est not\u00e9 \\(\\mathbb{R}\\) . Remarques Un nombre r\u00e9el est un nombre dont le carr\u00e9 est positif ou nul . Par d\u00e9finition, tous les nombres rationnels sont des r\u00e9els. On a alors \\(\\mathbb{Q} \\subset \\mathbb{R}\\) . Certains nombres r\u00e9els ne sont pas rationnels. Par exemple \\(\\pi\\) n'est pas rationnel, tout comme \\(\\sqrt{2}\\) ( on le montrera en exercice ). Ces nombres sont dits irrationnels . Propri\u00e9t\u00e9 : Ensembles de nombres Des remarques pr\u00e9c\u00e9dentes, on \u00e0 la propri\u00e9t\u00e9 : \\[ \\mathbb{N} \\subset \\mathbb{Z} \\subset \\mathbb{D} \\subset \\mathbb{Q} \\subset \\mathbb{R} \\] Propri\u00e9t\u00e9 : Droite des r\u00e9els Tout nombre r\u00e9el est repr\u00e9sent\u00e9 par l'abscisse d'un point sur la droite num\u00e9rique ( appel\u00e9e aussi droite des r\u00e9els ). Application : Repr\u00e9senter sur la droite des r\u00e9els D\u00e9terminer l'abscisse de chacun des points de la droite ci-dessous : Repr\u00e9senter la droite des r\u00e9els ( unit\u00e9 : 5 ) et y placer le plus pr\u00e9cis\u00e9ment possible les nombres suivants : \\[ 3 ~;~ -0,75 ~;~ \\dfrac{5}{4} ~;~\\dfrac{-2}{5} ~;~ \\dfrac{7}{3} ~;~ \\sqrt{2} \\]","title":"Ensembles de nombres "},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/#c01-01-ensembles-de-nombres","text":"La version pdf de ce cours est t\u00e9l\u00e9chargeable ici . (version 2021-2022)","title":"C01-01 : Ensembles de Nombres"},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/#activite-classer-des-nombres","text":"Dans la liste ci-dessus, deux \u00e9critures sont interdites. Lesquelles et pourquoi ? Classer les nombres restants en cinq groupes , en justifiant vos choix. Diff\u00e9rence entres propri\u00e9t\u00e9s et \u00e9critures Un nombre peut \u00eatre \u00e9crit de diff\u00e9rentes mani\u00e8res, plus ou moins compliqu\u00e9es. Par exemple : \\[ 2 = \\cfrac{6}{3} = 20 \\times 10^{-1} = \\sqrt{4}= - \\left(-2\\right) = 2,0000 \\] Pour autant, ce qui nous int\u00e9resse en math\u00e9matiques c'est d'\u00e9tudier les propri\u00e9t\u00e9s de ce nombre, qui elles sont ind\u00e9pendantes de l'\u00e9criture de ce nombre.","title":"Activit\u00e9 : Classer des nombres"},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/#nombres-entiers-naturels-et-relatifs","text":"D\u00e9finitions L'ensemble des entiers naturels , not\u00e9 \\(\\mathbb{N}\\) , est l'ensemble des nombres permettant de d\u00e9nombrer une collection d'objets, de personnes, etc, c'est-\u00e0-dire la suite naturelle \\(0~;~1~;~2~;~3~;~...\\) L'ensemble des entiers relatifs , not\u00e9 \\(\\mathbb{Z}\\) , est l'ensemble des entiers naturels et leurs oppos\u00e9s , c'est-\u00e0-dire la suite \\(...~;~-3~;~-2~;~-1~;~0~;~1~;~2~;~3~;~...\\) Info L'ensemble \\(\\mathbb{N}\\) poss\u00e8de un plus petit \u00e9l\u00e9ment, c'est \\(0\\) . Les nombres entiers naturels sont tous positifs ou nuls . Tous les entiers naturels sont aussi des entiers relatifs . Vocabulaire et notations Appartenance : On dit que \\(5\\) appartient \u00e0 \\(\\mathbb{N}\\) , et on note \\(5 \\in \\mathbb{N}\\) . De m\u00eame \\(-2\\) n'appartient pas \u00e0 \\(\\mathbb{N}\\) , et on note \\(-12 \\notin \\mathbb{N}\\) . Inclusion : Tous les \u00e9l\u00e9ments de \\(\\mathbb{N}\\) sont aussi des \u00e9l\u00e9ments de \\(\\mathbb{Z}\\) . On dit alors que \\(\\mathbb{N}\\) est un sous-ensemble de \\(\\mathbb{Z}\\) et on note alors \\(\\mathbb{N} \\subset \\mathbb{Z}\\) (qui se lit \\(\\mathbb{N}\\) est inclus dans \\(\\mathbb{Z}\\) ). Application : choix du bon symbole Exercice Compl\u00e9ter avec \\(\\in\\) ou \\(\\notin\\) : \\(7 \\dots \\mathbb{N}\\) \\(-3 \\dots \\mathbb{N}\\) \\(-5 \\dots \\mathbb{Z}\\) \\(7 \\dots \\mathbb{Z}\\) \\(\\dfrac{1}{3} \\dots \\mathbb{N}\\) \\(\\sqrt{9} \\dots \\mathbb{N}\\) \\(-\\sqrt{25} \\dots \\mathbb{N}\\) \\(-\\sqrt{2} \\dots \\mathbb{Z}\\) \\(5 \\times 10^{3} \\dots \\mathbb{N}\\) \\(5 \\times 10 ^{-3} \\dots \\mathbb{Z}\\) \\(-4,2 \\dots \\mathbb{Z}\\) \\(3 \\times (1 - \\dfrac{1}{3}) \\dots \\mathbb{N}\\) Solution Compl\u00e9ter avec \\(\\in\\) ou \\(\\notin\\) : \\(7 \\in \\mathbb{N}\\) \\(-3 \\notin \\mathbb{N}\\) \\(-5 \\in \\mathbb{Z}\\) \\(7 \\in \\mathbb{Z}\\) \\(\\dfrac{1}{3} \\notin \\mathbb{N}\\) \\(\\sqrt{9} \\in \\mathbb{N}\\) car \\(\\sqrt{9} = 3\\) \\(-\\sqrt{25} \\notin \\mathbb{N}\\) car \\(-\\sqrt{25} = -5\\) \\(-\\sqrt{2} \\notin \\mathbb{Z}\\) car \\(-\\sqrt{2} \\simeq -1,414...\\) \\(5 \\times 10^{3} \\in \\mathbb{N}\\) car \\(5 \\times 10^3 = 5 \\times 1000 = 5000\\) \\(5 \\times 10 ^{-3} \\notin \\mathbb{Z}\\) car \\(5 \\times 10 ^{-3} = 5 \\times 0,001 = 0,005\\) \\(-4,2 \\notin \\mathbb{Z}\\) \\(3 \\times (1 - \\dfrac{1}{3}) \\in \\mathbb{N}\\) car \\(3 \\times (1 - \\dfrac{1}{3}) = 3 - 1 = 2\\) (en d\u00e9veloppant) ou \\(3 \\times (1 - \\dfrac{1}{3}) = 3 \\times \\dfrac{2}{3} = 2\\) (en calculant entre parenth\u00e8ses).","title":"Nombres entiers naturels et relatifs"},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/#nombres-decimaux","text":"d\u00e9finition : Nombres d\u00e9cimaux Un nombre d\u00e9cimal est un nombre pouvant s'\u00e9crire sous la forme d'une fraction d\u00e9cimale , c'est \u00e0 dire sous la forme $$ \\dfrac{a}{10^n} $$ avec \\(a\\in \\mathbb{Z}\\) et \\(n\\in \\mathbb{N}\\) . L'ensemble des d\u00e9cimaux est not\u00e9 \\(\\mathbb{D}\\) . Application : Nombres d\u00e9cimaux et puissances de 10 Exercice Pour chacun des nombres suivants, d\u00e9terminer si possible une \u00e9criture de la forme \\(\\dfrac{k}{10^n}\\) . \\(4,37\\) \\(0,002\\) \\(-12\\) \\(\\dfrac{1}{3}\\) \\(\\dfrac{2}{5}\\) \\(\\sqrt{0,16}\\) \\(10^3\\) \\(10^{-5}\\) \\(-10^5\\) \\(\\dfrac{3.10^5}{10^7}\\) \\(\\dfrac{10^7}{3.10^5}\\) Solution Pour chacun des nombres suivants, d\u00e9terminer si possible une \u00e9criture de la forme \\(\\dfrac{k}{10^n}\\) . \\(4,37 = \\dfrac{437}{100} = \\dfrac{437}{10^{2}}\\) \\(0,002 = \\dfrac{2}{1~000} = \\dfrac{2}{10^{3}}\\) \\(-12 = \\dfrac{-12}{1} = \\dfrac{-12}{10^{0}}\\) ( car \\(a^0 =1\\) pour tout nombre \\(a \\neq 0\\) ). \\(\\dfrac{1}{3} \\notin \\mathbb{D}\\) car \\(\\dfrac{1}{3} \\simeq 0,333...\\) (La d\u00e9monstration r\u00e9elle sera donn\u00e9e plus tard dans l'ann\u00e9e) \\(\\dfrac{2}{5} = \\dfrac{4}{10} = \\dfrac{4}{10^1}\\) \\(\\sqrt{0,16} = 0,4 = \\dfrac{4}{10} = \\dfrac{4}{10^1}\\) \\(10^3 = \\dfrac{1~000}{1} = \\dfrac{1~000}{10^{0}}\\) \\(10^{-5} = \\dfrac{1}{10^5}\\) (par d\u00e9finition des exposants n\u00e9gatifs \\(a^{-n} = \\dfrac{1}{a^n}\\) pour tout \\(n \\in \\mathbb{Z}\\) si \\(a \\neq 0\\) ) \\(-10^5 = - 100~000 = \\dfrac{- 100~000}{1} = \\dfrac{- 100~000}{10^{0}}\\) $ \\(\\dfrac{3.10^5}{10^7} = \\dfrac{3}{10^2}\\) par division des puissances ( \\(\\dfrac{a^m}{a^n} = a^{m-n}\\) pour tout \\(m,n \\in \\Z\\) ) \\(\\dfrac{10^7}{3.10^5} = \\dfrac{10^2}{3} \\simeq 33,333.... \\notin \\mathbb{D}\\) Remarques Les entiers relatifs sont des d\u00e9cimaux, car si \\(k \\in \\mathbb{Z}\\) , on peut aussi \u00e9crire \\(k=\\dfrac{k}{1}=\\dfrac{k}{10^0}\\) . On a donc la propri\u00e9t\u00e9 \\(\\mathbb{Z} \\subset \\mathbb{D}\\) . Un nombre d\u00e9cimal poss\u00e8de une \u00e9criture d\u00e9cimale finie .","title":"Nombres d\u00e9cimaux"},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/#nombres-rationnels","text":"D\u00e9finition : Nombres rationnels Un nombre rationnel est un nombre pouvant s'\u00e9crire sous la forme \\(\\dfrac{a}{b}\\) avec \\(a\\in \\mathbb{Z}\\) et \\(b\\in \\mathbb{N}^{*}\\) (c'est-\u00e0-dire \\(\\mathbb{N}\\) priv\u00e9 de \\(0\\) ). L'ensemble des nombres rationnels est not\u00e9 \\(\\mathbb{Q}\\) . Remarque Un nombre d\u00e9cimal est par d\u00e9finition un nombre rationnel. Par d\u00e9finition de \\(\\mathbb{D}\\) et \\(\\mathbb{Q}\\) , on a la propri\u00e9t\u00e9 \\(\\mathbb{D} \\subset \\mathbb{Q}\\) . Propri\u00e9t\u00e9 : Caract\u00e9risation des rationnels non d\u00e9cimaux Tous les nombres rationnels ne poss\u00e8dent pas d'\u00e9criture d\u00e9cimale finie. En particulier, \\(\\dfrac{1}{3}\\) n'est pas d\u00e9cimal. Preuve La d\u00e9monstration de cette propri\u00e9t\u00e9 sera faite plus tard dans l'ann\u00e9e, dans le chapitre arithm\u00e9tique. Remarques Les nombres rationnels non d\u00e9cimaux poss\u00e8dent une \u00e9criture d\u00e9cimale infinie p\u00e9riodique , c'est-\u00e0-dire avec une s\u00e9rie de chiffres qui se r\u00e9p\u00e8tent \u00e0 l'infini. Par exemple \\(\\dfrac{1}{7} = 0,14285714285714...\\) (on constate la r\u00e9p\u00e9tition de la s\u00e9quence 142857}). R\u00e9ciproquement, si un nombre poss\u00e8de une \u00e9criture d\u00e9cimale infinie p\u00e9riodique, alors c'est un rationnel. M\u00e9thode : D\u00e9terminer une fraction \u00e9gale \u00e0 une \u00e9criture d\u00e9cimale infinie p\u00e9riodique On consid\u00e8re le nombre \\(a\\) dont l'\u00e9criture d\u00e9cimale est infinie p\u00e9riodique \\(a = 2,71347134...\\) . D\u00e9montrons que ce nombre est rationnel. Solution On constate que la partie r\u00e9p\u00e9titive des chiffres de \\(a\\) est \\(7134\\) , donc de taille 4. Donc \\(10^4 \\times a = 10~000\\times a = 27134,71347134...\\) . D'o\u00f9 \\(10~000\\times a - a = 27134,71347134... - 2,71347134... = 27134 -2 = 27~132\\) . Or \\(10~000\\times a - a = 9~999\\times a\\) . D'apr\u00e8s les deux lignes pr\u00e9c\u00e9dentes, on a alors \\(9~999\\times a = 27132\\) soit \\(a = \\dfrac{27~132}{9~999} = \\dfrac{9~044}{3~333}\\) . Donc \\(a\\) est bien un nombre rationnel puisqu'il s'\u00e9crit sous la forme d'une fraction. Application : Calculs avec les rationnels Exercice Dans chacun des cas suivants, calculer \u00e0 la main chacune des expressions suivantes : \\(A = \\dfrac {5}{7} - \\dfrac{3}{11}\\) \\(B = -\\dfrac {4}{3} + \\dfrac{7}{8}\\) \\(C = \\dfrac {3}{8} - \\dfrac{5}{12}\\) \\(D = \\dfrac {-6}{7} \\times \\dfrac{8}{9}\\) \\(E = \\dfrac {3}{2} \\times \\left(-\\dfrac{7}{3}\\right)\\) \\(F = \\dfrac {48}{35} \\times \\dfrac{25}{64}\\) \\(G = \\dfrac {4}{7} \\div \\dfrac{8}{21}\\) \\(H = \\dfrac{~~\\dfrac{3}{4}~~}{\\dfrac{18}{20}}\\) \\(I = \\dfrac{~~7~~}{\\dfrac{5}{3}}\\) \\(J = \\dfrac{~~\\dfrac{7}{5}~~}{3}\\) Solution \\(A = \\dfrac {5}{7} - \\dfrac{3}{11} = \\dfrac {5\\times 11}{7\\times 11} - \\dfrac{3\\times 7}{11\\times 7} = \\dfrac {55}{77} - \\dfrac{21}{77} = \\dfrac{34}{77}\\) \\(B = -\\dfrac {4}{3} + \\dfrac{7}{8} = -\\dfrac {4 \\times 8}{3 \\times 8} + \\dfrac{7 \\times 3}{8 \\times 3} = -\\dfrac {32}{24} + \\dfrac{21}{24} -\\dfrac {11}{24}\\) \\(C = \\dfrac {3}{8} - \\dfrac{5}{12} = \\dfrac {3\\times 3}{8\\times 3} - \\dfrac{5 \\times 2}{12 \\times 2} = \\dfrac {9}{24} - \\dfrac{10}{24} = - \\dfrac{1}{24}\\) \\(D = \\dfrac {-6}{7} \\times \\dfrac{8}{9} = \\dfrac{-6 \\times 8}{7 \\times 9} = \\dfrac{-2 \\times 3 \\times 8}{7 \\times 3 \\times 3} = -\\dfrac{16}{21}\\) N'oubliez pas de simplifier ! \\(E = \\dfrac {3}{2} \\times \\left(-\\dfrac{7}{3}\\right) = -\\dfrac {3 \\times 7}{2 \\times3} = - \\dfrac{7}{2}\\) \\(F = \\dfrac {48}{35} \\times \\dfrac{25}{64} = \\dfrac{48 \\times 25}{35 \\times 64} = \\dfrac{2 \\times 3 \\times 8 \\times 5 \\times 5}{5\\times 7 \\times 2 \\times 4 \\times 8} = \\dfrac{15}{28}\\) \\(G = \\dfrac {4}{7} \\div \\dfrac{8}{21} = \\dfrac {4}{7} \\times \\dfrac{21}{8} = \\dfrac{4 \\times 21}{7 \\times 8} = \\dfrac{ 4 \\times 3 \\times 7}{7 \\times 2 \\times 4} = \\dfrac{3}{2}\\) \\(H = \\dfrac{~~\\dfrac{3}{4}~~}{\\dfrac{18}{20}} = \\dfrac{3}{4}\\div\\dfrac{18}{20} = \\dfrac{3}{4}\\div\\dfrac{20}{18} = \\dfrac{3 \\times 4 \\times 5}{ 4 \\times 3 \\times 6} = \\dfrac{5}{6}\\) . \\(I = \\dfrac{~~7~~}{\\dfrac{5}{3}} = 7 \\div \\dfrac{5}{3} = 7 \\times \\dfrac{3}{5} = \\dfrac{21}{5}\\) \\(J = \\dfrac{~~\\dfrac{7}{5}~~}{3} = \\dfrac{7}{5} \\div 3 = \\dfrac{7}{5} \\times \\dfrac{1}{3} = \\dfrac{7}{15}\\)","title":"Nombres rationnels"},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/#nombres-reels","text":"D\u00e9finition : Nombres r\u00e9els Un {==nombre r\u00e9el est un nombre exprimant une longueur, ou l'oppos\u00e9 d'un nombre exprimant une longueur. L'ensemble des nombres rationnels est not\u00e9 \\(\\mathbb{R}\\) . Remarques Un nombre r\u00e9el est un nombre dont le carr\u00e9 est positif ou nul . Par d\u00e9finition, tous les nombres rationnels sont des r\u00e9els. On a alors \\(\\mathbb{Q} \\subset \\mathbb{R}\\) . Certains nombres r\u00e9els ne sont pas rationnels. Par exemple \\(\\pi\\) n'est pas rationnel, tout comme \\(\\sqrt{2}\\) ( on le montrera en exercice ). Ces nombres sont dits irrationnels . Propri\u00e9t\u00e9 : Ensembles de nombres Des remarques pr\u00e9c\u00e9dentes, on \u00e0 la propri\u00e9t\u00e9 : \\[ \\mathbb{N} \\subset \\mathbb{Z} \\subset \\mathbb{D} \\subset \\mathbb{Q} \\subset \\mathbb{R} \\] Propri\u00e9t\u00e9 : Droite des r\u00e9els Tout nombre r\u00e9el est repr\u00e9sent\u00e9 par l'abscisse d'un point sur la droite num\u00e9rique ( appel\u00e9e aussi droite des r\u00e9els ). Application : Repr\u00e9senter sur la droite des r\u00e9els D\u00e9terminer l'abscisse de chacun des points de la droite ci-dessous : Repr\u00e9senter la droite des r\u00e9els ( unit\u00e9 : 5 ) et y placer le plus pr\u00e9cis\u00e9ment possible les nombres suivants : \\[ 3 ~;~ -0,75 ~;~ \\dfrac{5}{4} ~;~\\dfrac{-2}{5} ~;~ \\dfrac{7}{3} ~;~ \\sqrt{2} \\]","title":"Nombres r\u00e9els"},{"location":"Miscellanees/mkdocs_cmd/","text":"Syntaxe des documents MkDocs Pour la documentation compl\u00e8te : mkdocs.org . Documentation sur materials : materials reference La documentation sur le plugin macro : macro plugin Bases de la syntaxe Markdown Le langage Mardown est en langage de balise simple, utilis\u00e9 entre autres dans les notebooks Jupyter, et pour lequel les r\u00e8gles d'utilisation sont simples : La mise en gras se fait par en encadrant par 2 \u00e9toiles : **Gras** -> Gras . La mise en italique se fait par en encadrant par 1 \u00e9toile : *Italique* -> Italique . Les titres de diff\u00e9rents niveaux sont obtenus en utilisant un certain nombre de di\u00e8se # Les images sont ins\u00e9r\u00e9es par la commande ![Alt text](/path/to/img.jpg \"Optional title\") Un texte sans fortmatage est obtenu en encadrant par des guillemets invvers\u00e9s ` : '**Truc**' n'est pas mis en forme Pour utiliser un caract\u00e8re * simple, il faut l'\u00e9chapper avec un backslash \\, comme pour tous les autres caract\u00e8re sp\u00e9ciaux. Les citations Pour ins\u00e9rer une citation, on utilise le chevron > devant chaque ligne de code : > Voici une citation > sur plusieurs lignes. donnera Voici une citation sur plusieurs lignes. A noter que si on ne saute pas de ligne, MkDocs formate selon la loingueur de la ligne courante : Pour ins\u00e9rer une citation, on utilise le chevron > devant chaque ligne de code : > Voici une citation > sur une seule ligne. donnera Voici une citation sur une seule ligne. Les hyperliens Le fonctionnement des hyperlmens est particulier \u00e0 MkDocs, donc ce qui suit n'est pas toujours valable dans n'importe quel environnement lisant du MarkDown . Le principe de base : [texte de remplacement](adresse du document) Il est possible de r\u00e9f\u00e9rer \u00e0 des documents internes en utilisant leur chemin relatif. Please see the [project license](../about/license.md) for further details. Il est possible de faire une r\u00e9f\u00e9rence \u00e0 une partie sp\u00e9cifique d'un document par l'interm\u00e9diaire d'ID g\u00e9n\u00e9r\u00e9es automatiquement par MkDocs pour chaque header (\u26a0\ufe0f les noms sont en minuscules et les caract\u00e8res sp\u00e9ciaux - y compris les espaces, sont remplac\u00e9 par des tirets. lers tirets doubles sont alors r\u00e9duits \u00e0 un simple tiret). Ainsi le lien [ceci](mkdocs_cmd.md#syntaxe-des-documents-mkdocs) renvoie ici renvoie vers le header de cette partie. Modules de MkDocs-Material Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Test code 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] supprime et insere et Surligne Keys Ctrl Alt Del Latex \\[ \\dfrac{3}{4x} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) . Admonitions (?) Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note On teste l'auto deploiement","title":"MkDocs"},{"location":"Miscellanees/mkdocs_cmd/#syntaxe-des-documents-mkdocs","text":"Pour la documentation compl\u00e8te : mkdocs.org . Documentation sur materials : materials reference La documentation sur le plugin macro : macro plugin","title":"Syntaxe des documents MkDocs"},{"location":"Miscellanees/mkdocs_cmd/#bases-de-la-syntaxe-markdown","text":"Le langage Mardown est en langage de balise simple, utilis\u00e9 entre autres dans les notebooks Jupyter, et pour lequel les r\u00e8gles d'utilisation sont simples : La mise en gras se fait par en encadrant par 2 \u00e9toiles : **Gras** -> Gras . La mise en italique se fait par en encadrant par 1 \u00e9toile : *Italique* -> Italique . Les titres de diff\u00e9rents niveaux sont obtenus en utilisant un certain nombre de di\u00e8se # Les images sont ins\u00e9r\u00e9es par la commande ![Alt text](/path/to/img.jpg \"Optional title\") Un texte sans fortmatage est obtenu en encadrant par des guillemets invvers\u00e9s ` : '**Truc**' n'est pas mis en forme Pour utiliser un caract\u00e8re * simple, il faut l'\u00e9chapper avec un backslash \\, comme pour tous les autres caract\u00e8re sp\u00e9ciaux.","title":"Bases de la syntaxe Markdown"},{"location":"Miscellanees/mkdocs_cmd/#les-citations","text":"Pour ins\u00e9rer une citation, on utilise le chevron > devant chaque ligne de code : > Voici une citation > sur plusieurs lignes. donnera Voici une citation sur plusieurs lignes. A noter que si on ne saute pas de ligne, MkDocs formate selon la loingueur de la ligne courante : Pour ins\u00e9rer une citation, on utilise le chevron > devant chaque ligne de code : > Voici une citation > sur une seule ligne. donnera Voici une citation sur une seule ligne.","title":"Les citations"},{"location":"Miscellanees/mkdocs_cmd/#les-hyperliens","text":"Le fonctionnement des hyperlmens est particulier \u00e0 MkDocs, donc ce qui suit n'est pas toujours valable dans n'importe quel environnement lisant du MarkDown . Le principe de base : [texte de remplacement](adresse du document) Il est possible de r\u00e9f\u00e9rer \u00e0 des documents internes en utilisant leur chemin relatif. Please see the [project license](../about/license.md) for further details. Il est possible de faire une r\u00e9f\u00e9rence \u00e0 une partie sp\u00e9cifique d'un document par l'interm\u00e9diaire d'ID g\u00e9n\u00e9r\u00e9es automatiquement par MkDocs pour chaque header (\u26a0\ufe0f les noms sont en minuscules et les caract\u00e8res sp\u00e9ciaux - y compris les espaces, sont remplac\u00e9 par des tirets. lers tirets doubles sont alors r\u00e9duits \u00e0 un simple tiret). Ainsi le lien [ceci](mkdocs_cmd.md#syntaxe-des-documents-mkdocs) renvoie ici renvoie vers le header de cette partie.","title":"Les hyperliens"},{"location":"Miscellanees/mkdocs_cmd/#modules-de-mkdocs-material","text":"","title":"Modules de MkDocs-Material"},{"location":"Miscellanees/mkdocs_cmd/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"Miscellanees/mkdocs_cmd/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Miscellanees/mkdocs_cmd/#test-code","text":"1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] supprime et insere et Surligne","title":"Test code"},{"location":"Miscellanees/mkdocs_cmd/#keys","text":"Ctrl Alt Del","title":"Keys"},{"location":"Miscellanees/mkdocs_cmd/#latex","text":"\\[ \\dfrac{3}{4x} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"Latex"},{"location":"Miscellanees/mkdocs_cmd/#admonitions","text":"Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note On teste l'auto deploiement","title":"Admonitions (?)"},{"location":"NSI/Terminale/home/","text":"Le programme Documents officiels Le programme de Terminale NSI se trouve ici . Cependant certains ajustements ont \u00e9t\u00e9 effectu\u00e9s dans le BO du 29 juillet 2021 . Pr\u00e9vision de progression annuelle 2021-2022 Cette progression n'est valable que pour les \u00e9l\u00e8ves du Lyc\u00e9e Pavie de Guingamp, et est sujette \u00e0 modifications au cours de l'ann\u00e9e... Th\u00e8me Chapitre Dur\u00e9e Estim\u00e9e Dates pr\u00e9vues Dates effectives Remarques Structures de donn\u00e9es Modularit\u00e9 et POO 2 semaine 02/09 -> 16/09 Langages et programmation R\u00e9cursivit\u00e9 2 semaines 16/09 -> 30/09 Les \u00e9preuves Epreuve \u00e9crite Pour l'instant, aucune date officielle n'est tomb\u00e9e concernant l'\u00e9preuve \u00e9crite de NSI pour la session de Bac 2022. Nous pouvons cependant- supposer qu'elle aura lieu en Mars . Epreuve pratique Pour l'instant, aucune date officielle n'est tomb\u00e9e concernant l'\u00e9preuve pratique de NSI pour la session de Bac 2022. Nous pouvons cependant- supposer qu'elle aura lieu en Mars .","title":"Pr\u00e9sentation"},{"location":"NSI/Terminale/home/#le-programme","text":"","title":"Le programme"},{"location":"NSI/Terminale/home/#documents-officiels","text":"Le programme de Terminale NSI se trouve ici . Cependant certains ajustements ont \u00e9t\u00e9 effectu\u00e9s dans le BO du 29 juillet 2021 .","title":"Documents officiels"},{"location":"NSI/Terminale/home/#prevision-de-progression-annuelle-2021-2022","text":"Cette progression n'est valable que pour les \u00e9l\u00e8ves du Lyc\u00e9e Pavie de Guingamp, et est sujette \u00e0 modifications au cours de l'ann\u00e9e... Th\u00e8me Chapitre Dur\u00e9e Estim\u00e9e Dates pr\u00e9vues Dates effectives Remarques Structures de donn\u00e9es Modularit\u00e9 et POO 2 semaine 02/09 -> 16/09 Langages et programmation R\u00e9cursivit\u00e9 2 semaines 16/09 -> 30/09","title":"Pr\u00e9vision de progression annuelle 2021-2022"},{"location":"NSI/Terminale/home/#les-epreuves","text":"","title":"Les \u00e9preuves"},{"location":"NSI/Terminale/home/#epreuve-ecrite","text":"Pour l'instant, aucune date officielle n'est tomb\u00e9e concernant l'\u00e9preuve \u00e9crite de NSI pour la session de Bac 2022. Nous pouvons cependant- supposer qu'elle aura lieu en Mars .","title":"Epreuve \u00e9crite"},{"location":"NSI/Terminale/home/#epreuve-pratique","text":"Pour l'instant, aucune date officielle n'est tomb\u00e9e concernant l'\u00e9preuve pratique de NSI pour la session de Bac 2022. Nous pouvons cependant- supposer qu'elle aura lieu en Mars .","title":"Epreuve pratique"},{"location":"NSI/Terminale/C01/Exceptions/","text":"Gestion des exceptions Un exemple d'erreur \u00e0 ne pas commettre Utilisation malheureuse d'un module Reprenons le module secondDegre.py , mais en temps qu'utilisateur. Nous connaissons l'interface qui nous a \u00e9t\u00e9 fournie par l'auteur. Pour tester le module nous lan\u00e7ons le script suivant, nomm\u00e9 testModule.py , et situ\u00e9 dans le m\u00eame dossier que secondDegre.py : import secondDegre as sD p = input ( \"Donnez les coefficients du polynome s\u00e9par\u00e9s par des virgules :\" ) p = tuple ( map ( float , p . split ( \",\" ))) p = sD . polynome ( p ) print ( sD . tangente ( p , 3 )) Un probl\u00e8me ? Copiez-collez le code ci-dessus dans un fichier testModule.py , puis ex\u00e9cutez-le en saisissant : 3,4,5 ; \"trois\",4,5 3,4,5,6 0,3,4 Dans chacun des cas, qu'obtient-on en sortie ? Pourquoi ? Solution 3,4,5 La sortie est : `y = 22.0(x-3) + 44.0` qui est correcte. \"trois\",4,5 La sortie renvoie une erreur de type ValueError , mais c'est celle lev\u00e9e dans le premier if , car un \u00e9l\u00e9ment du tuple n'est pas du bon type. 3,4,5,6 La sortie renvoie une erreur de type ValueError , mais c'est celle lev\u00e9e dans le premier if , car le tuple donn\u00e9 n'est pas de la bonne taille. 0,3,4 La sortie renvoie une erreur de type ValueError , mais c'est celle lev\u00e9e dans le deuxi\u00e8me if , car le tuple donn\u00e9 ne correspond pas \u00e0 un polyn\u00f4me de degr\u00e9 2. Lever les bonnes erreurs Dans l'exemple pr\u00e9c\u00e9dent, les trois erreurs, pourtant tr\u00e8s diff\u00e9rentes, sont signal\u00e9es par le m\u00eame message. L'utilisateur, qui lui ne conna\u00eet pas l'impl\u00e9mentation, ne peut donc pas savoir d'o\u00f9 provient son erreur** (ce qui peut donner des s\u00e9ances de d\u00e9buggage particuli\u00e8rement frustrantes). Il est donc n\u00e9cessaire de pr\u00e9ciser mieux les erreurs commises par l'utilisateur, pour qu'il n'ait pas \u00e0 ses pr\u00e9occuper des d\u00e9tails d'impl\u00e9mentation. Il est par exemple possible de rajouter un message lorsque l'erreur est lev\u00e9e, en la passant en param\u00e8tre directement dans l'instruction ValueError() : def polynome ( t ) : a , b , * c = t if len ( c ) > 1 : raise ValueError ( \"length of tuple argument greater than 3\" ) if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or not ( isinstance ( * c ,( int , float ))) : raise ValueError ( \"argment Error : argument must be a tuple integers or float\" ) if a == 0 : raise ValueError ( \"First element of tuple must not be 0\" ) return t Tyes d'exceptions Voici quelques exceptions courantes, et leurs utilisations Exception Contexte NameError acc\u00e8s \u00e0 une variable inexistante dans l'espace de nom courant IndexError acc\u00e8s \u00e0 un indice invalide d'une liste, d'un tuple, d'une chaine de caract\u00e8res... KeyError acc\u00e8s \u00e0 une cl\u00e9 inexistante d'un dictionnaire ZeroDivisionError division par z\u00e9ro TypeError op\u00e9ration appliqu\u00e9es \u00e0 un ou des objets incompatibles Lever des exceptions Une exception peut \u00eatre lev\u00e9e (c'est-\u00e0-dire volontairement d\u00e9clench\u00e9e) par l'interm\u00e9diaire de l'instruction raise . Dans ce cas le programme est interrompu , et la pile d'erreurs est renvoy\u00e9es dans le terminal \u00e0 l'utilisateur. Corriger le code\"\" Malgr\u00e9 nos corrections, il reste plusieurs possibilit\u00e9s d'erreurs dans l'utilisation de la fonction polynome(t) . Quelles sont-elles et comment les corriger pour lever une exception explicite ? Solution Ex\u00e9cution de polynome((2,3)) ou polynome((4)) Que se passe-t-il lorsqu'on utilise la fonction polynome avec un tuple de 1 ou 2 \u00e9l\u00e9ments ? Dans le cas d'un seul \u00e9l\u00e9ment, l'erreur ressortie est : a,b,*c = t TypeError: cannot unpack non-iterable int object Dans le cas de deux \u00e9l\u00e9ments, l'erreur lev\u00e9e est : ) or not(isinstance(*c,(int, float))) : TypeError: isinstance expected 2 arguments, got 1 Dans les deux cas, on voit appara\u00eetre les d\u00e9tails d'impl\u00e9mentation du code de la fonction, qui sont peu clairs en particulier pour le cas n\u00b02. Ex\u00e9cution de polynome(3,4,5) Une erreur possible, et que vous avez probablement commise, est celle de passer non pas un seul argument sous la forme d'un tuple (ou d'une liste) mais de multiples param\u00e8tres. Cette erreur d\u00e9clenche alors l'exception TypeError car les trois arguments pass\u00e9s ne sont pas du bon type. Une correction possible Le code suivant est une solution possible (certainement perfectible) \u00e0 la lev\u00e9e d'erreurs plus explicites : def polynome ( * t ) : try : if len ( t ) == 1 : # si on passe un tuple ou un tableau (1,2,3), # *t le convertit en [(1,2,3)] t = t [ 0 ] # d'o\u00f9 cette ligne a , b , * c = t #Puis on unpack, c \u00e9tant une liste \u00e9ventuellement vide except TypeError : raise TypeError ( \"Must pass three argument or a tuple of 3 element.\" ) if len ( c ) != 1 : # si c est vide ou contient au moins 2 \u00e9l\u00e9ments raise ValueError ( \"Bad Number of argument.\" ) if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or not ( isinstance ( * c ,( int , float ))) : raise TypeError ( \"argment Error : argument must be a tuple of integers or floats.\" ) if a == 0 : raise ValueError ( \"First element of tuple must not be 0.\" ) return t Intercepter des exceptions Vous avez constat\u00e9 dans la solution pr\u00e9c\u00e9dente un bloc que nous n'avons encore jamais utilis\u00e9 : try : if len ( t ) == 1 : t = t [ 0 ] a , b , * c = t except TypeError : raise TypeError ( \"Must pass three argument or a tuple of 3 element.\" ) On a ici l'utilisation d'une structure sp\u00e9ciale : l'interception d'ereurs. Interception des exceptions Il arrive souvent en programmation que l'on doive utiliser une instructions oui une s\u00e9rie d'instruction dont on sait \u00e0 l'avance qu'elle peuvent g\u00e9n\u00e9rer des erreurs. La structure suivante est l\u00e0 pour \u00e7a : try : # Bloc try except error : # Bloc except Le code du bloc try va \u00eatre ex\u00e9cut\u00e9, et si une erreur du type fournie en argument de l'instruction except est lev\u00e9e, alors le code du bloc except est ex\u00e9cut\u00e9. Exemple : En premi\u00e8re nous avons vu l'importance de rendre parfois un code dumbproof , et que cela g\u00e9n\u00e8rais parfois de nombreuses difficult\u00e9s. Le simple fait de coder une fonction demandant \u00e0 un utilisateur de saisir un nombre entier entre 1 et 10 inclus pouvaiet rapidement p\u00e9nible \u00e0 \u00e9crire. Les deux onglets ci-dessous donnent deux versions d'une fonction permettant de r\u00e9aliser cette fonction, la version utilis\u00e9e en premi\u00e8re, et celle levant des excpetions. Version avec des structures conditionnelles def askIntFrom1To10 () : while True : nb = input ( \"Entrez un entier entre 1 et 10 :\" ) if nb . isnumeric () and \".\" not in ( nb ) : nb = int ( nb ) if 1 <= nb and nb <= 10 : return nb else : print ( \"L'entier saisi n'est pas entre 1 et 10. Veuillez recommencer\" ) else : print ( \"Ce n'est pas un entier, veuillez recommencer !\" ) Version avec interception d'erreurs def askIntFrom1To10 () : while True : try : nb = int ( input ( \"Entrez un entier entre 1 et 10 :\" )) if 1 <= nb and nb <= 10 : return nb else : print ( \"L'entier saisi n'est pas entre 1 et 10. Veuillez recommencer\" ) except ValueError : print ( \"Ce n'est pas un entier, veuillez recommencer !\" ) Exercice Evidemment, la diff\u00e9rence ne saute pas vraiment aux yeux... Pourquoi faire tout un plat d'une seule ligne gagn\u00e9e ? Essayez donc, pour chacune des 2 fonctions pr\u00e9c\u00e9dentes, avec les chaines de caract\u00e8res suivantes : \u00bd 3\u00b2 R\u00e9ponse En fait le probl\u00e8me provient de la m\u00e9thode isnumeric() , dont on ne contr\u00f4le pas vraiment le fonctionnement. On sait que cette m\u00e9thode permet de v\u00e9rifier si une chaine de caract\u00e8res est bien constitu\u00e9e uniquement de caract\u00e8res num\u00e9riques. Mais sans lire r\u00e9ellement la documentation, qui peut se douter que les fractions d\u00e9finies dans la table utf8 , ainsi que les caract\u00e8res en exposant et en indice *, sont consid\u00e9r\u00e9s comme des valeurs num\u00e9riques. L'int\u00e9r\u00eat du bloc try est qu'il se d\u00e9clenchera d\u00e8s qu'il y aura une exception lev\u00e9e. Et cette exception a peu de chance de se produire dans le bloc if / else . La fonction devient dumbproof (mais si vous r\u00e9ussissez \u00e0 d\u00e9clencher une erreur bloquante, signalez-le moi !!). Enchainer les interceptions Il est aussi possible d'avoir plusieurs blocs except successifs, en utilisant : try : # Bloc try except error1 : # Bloc except1 except error2 : # Bloc except2 ... Etendre la gestion des exceptions Il existe de nombreuses autres possibilit\u00e9s utilisant la lev\u00e9e d'exceptions, mais elles d\u00e9passent largement le programme de Terminale. Les plus curieux parmi vous pourront toujours aller lire la doc Python \", qui reste la r\u00e9f\u00e9rence absolue...","title":"Exceptions"},{"location":"NSI/Terminale/C01/Exceptions/#gestion-des-exceptions","text":"","title":"Gestion des exceptions"},{"location":"NSI/Terminale/C01/Exceptions/#un-exemple-derreur-a-ne-pas-commettre","text":"Utilisation malheureuse d'un module Reprenons le module secondDegre.py , mais en temps qu'utilisateur. Nous connaissons l'interface qui nous a \u00e9t\u00e9 fournie par l'auteur. Pour tester le module nous lan\u00e7ons le script suivant, nomm\u00e9 testModule.py , et situ\u00e9 dans le m\u00eame dossier que secondDegre.py : import secondDegre as sD p = input ( \"Donnez les coefficients du polynome s\u00e9par\u00e9s par des virgules :\" ) p = tuple ( map ( float , p . split ( \",\" ))) p = sD . polynome ( p ) print ( sD . tangente ( p , 3 )) Un probl\u00e8me ? Copiez-collez le code ci-dessus dans un fichier testModule.py , puis ex\u00e9cutez-le en saisissant : 3,4,5 ; \"trois\",4,5 3,4,5,6 0,3,4 Dans chacun des cas, qu'obtient-on en sortie ? Pourquoi ? Solution 3,4,5 La sortie est : `y = 22.0(x-3) + 44.0` qui est correcte. \"trois\",4,5 La sortie renvoie une erreur de type ValueError , mais c'est celle lev\u00e9e dans le premier if , car un \u00e9l\u00e9ment du tuple n'est pas du bon type. 3,4,5,6 La sortie renvoie une erreur de type ValueError , mais c'est celle lev\u00e9e dans le premier if , car le tuple donn\u00e9 n'est pas de la bonne taille. 0,3,4 La sortie renvoie une erreur de type ValueError , mais c'est celle lev\u00e9e dans le deuxi\u00e8me if , car le tuple donn\u00e9 ne correspond pas \u00e0 un polyn\u00f4me de degr\u00e9 2. Lever les bonnes erreurs Dans l'exemple pr\u00e9c\u00e9dent, les trois erreurs, pourtant tr\u00e8s diff\u00e9rentes, sont signal\u00e9es par le m\u00eame message. L'utilisateur, qui lui ne conna\u00eet pas l'impl\u00e9mentation, ne peut donc pas savoir d'o\u00f9 provient son erreur** (ce qui peut donner des s\u00e9ances de d\u00e9buggage particuli\u00e8rement frustrantes). Il est donc n\u00e9cessaire de pr\u00e9ciser mieux les erreurs commises par l'utilisateur, pour qu'il n'ait pas \u00e0 ses pr\u00e9occuper des d\u00e9tails d'impl\u00e9mentation. Il est par exemple possible de rajouter un message lorsque l'erreur est lev\u00e9e, en la passant en param\u00e8tre directement dans l'instruction ValueError() : def polynome ( t ) : a , b , * c = t if len ( c ) > 1 : raise ValueError ( \"length of tuple argument greater than 3\" ) if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or not ( isinstance ( * c ,( int , float ))) : raise ValueError ( \"argment Error : argument must be a tuple integers or float\" ) if a == 0 : raise ValueError ( \"First element of tuple must not be 0\" ) return t","title":"Un exemple d'erreur \u00e0 ne pas commettre"},{"location":"NSI/Terminale/C01/Exceptions/#tyes-dexceptions","text":"Voici quelques exceptions courantes, et leurs utilisations Exception Contexte NameError acc\u00e8s \u00e0 une variable inexistante dans l'espace de nom courant IndexError acc\u00e8s \u00e0 un indice invalide d'une liste, d'un tuple, d'une chaine de caract\u00e8res... KeyError acc\u00e8s \u00e0 une cl\u00e9 inexistante d'un dictionnaire ZeroDivisionError division par z\u00e9ro TypeError op\u00e9ration appliqu\u00e9es \u00e0 un ou des objets incompatibles Lever des exceptions Une exception peut \u00eatre lev\u00e9e (c'est-\u00e0-dire volontairement d\u00e9clench\u00e9e) par l'interm\u00e9diaire de l'instruction raise . Dans ce cas le programme est interrompu , et la pile d'erreurs est renvoy\u00e9es dans le terminal \u00e0 l'utilisateur. Corriger le code\"\" Malgr\u00e9 nos corrections, il reste plusieurs possibilit\u00e9s d'erreurs dans l'utilisation de la fonction polynome(t) . Quelles sont-elles et comment les corriger pour lever une exception explicite ? Solution Ex\u00e9cution de polynome((2,3)) ou polynome((4)) Que se passe-t-il lorsqu'on utilise la fonction polynome avec un tuple de 1 ou 2 \u00e9l\u00e9ments ? Dans le cas d'un seul \u00e9l\u00e9ment, l'erreur ressortie est : a,b,*c = t TypeError: cannot unpack non-iterable int object Dans le cas de deux \u00e9l\u00e9ments, l'erreur lev\u00e9e est : ) or not(isinstance(*c,(int, float))) : TypeError: isinstance expected 2 arguments, got 1 Dans les deux cas, on voit appara\u00eetre les d\u00e9tails d'impl\u00e9mentation du code de la fonction, qui sont peu clairs en particulier pour le cas n\u00b02. Ex\u00e9cution de polynome(3,4,5) Une erreur possible, et que vous avez probablement commise, est celle de passer non pas un seul argument sous la forme d'un tuple (ou d'une liste) mais de multiples param\u00e8tres. Cette erreur d\u00e9clenche alors l'exception TypeError car les trois arguments pass\u00e9s ne sont pas du bon type. Une correction possible Le code suivant est une solution possible (certainement perfectible) \u00e0 la lev\u00e9e d'erreurs plus explicites : def polynome ( * t ) : try : if len ( t ) == 1 : # si on passe un tuple ou un tableau (1,2,3), # *t le convertit en [(1,2,3)] t = t [ 0 ] # d'o\u00f9 cette ligne a , b , * c = t #Puis on unpack, c \u00e9tant une liste \u00e9ventuellement vide except TypeError : raise TypeError ( \"Must pass three argument or a tuple of 3 element.\" ) if len ( c ) != 1 : # si c est vide ou contient au moins 2 \u00e9l\u00e9ments raise ValueError ( \"Bad Number of argument.\" ) if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or not ( isinstance ( * c ,( int , float ))) : raise TypeError ( \"argment Error : argument must be a tuple of integers or floats.\" ) if a == 0 : raise ValueError ( \"First element of tuple must not be 0.\" ) return t","title":"Tyes d'exceptions"},{"location":"NSI/Terminale/C01/Exceptions/#intercepter-des-exceptions","text":"Vous avez constat\u00e9 dans la solution pr\u00e9c\u00e9dente un bloc que nous n'avons encore jamais utilis\u00e9 : try : if len ( t ) == 1 : t = t [ 0 ] a , b , * c = t except TypeError : raise TypeError ( \"Must pass three argument or a tuple of 3 element.\" ) On a ici l'utilisation d'une structure sp\u00e9ciale : l'interception d'ereurs. Interception des exceptions Il arrive souvent en programmation que l'on doive utiliser une instructions oui une s\u00e9rie d'instruction dont on sait \u00e0 l'avance qu'elle peuvent g\u00e9n\u00e9rer des erreurs. La structure suivante est l\u00e0 pour \u00e7a : try : # Bloc try except error : # Bloc except Le code du bloc try va \u00eatre ex\u00e9cut\u00e9, et si une erreur du type fournie en argument de l'instruction except est lev\u00e9e, alors le code du bloc except est ex\u00e9cut\u00e9. Exemple : En premi\u00e8re nous avons vu l'importance de rendre parfois un code dumbproof , et que cela g\u00e9n\u00e8rais parfois de nombreuses difficult\u00e9s. Le simple fait de coder une fonction demandant \u00e0 un utilisateur de saisir un nombre entier entre 1 et 10 inclus pouvaiet rapidement p\u00e9nible \u00e0 \u00e9crire. Les deux onglets ci-dessous donnent deux versions d'une fonction permettant de r\u00e9aliser cette fonction, la version utilis\u00e9e en premi\u00e8re, et celle levant des excpetions. Version avec des structures conditionnelles def askIntFrom1To10 () : while True : nb = input ( \"Entrez un entier entre 1 et 10 :\" ) if nb . isnumeric () and \".\" not in ( nb ) : nb = int ( nb ) if 1 <= nb and nb <= 10 : return nb else : print ( \"L'entier saisi n'est pas entre 1 et 10. Veuillez recommencer\" ) else : print ( \"Ce n'est pas un entier, veuillez recommencer !\" ) Version avec interception d'erreurs def askIntFrom1To10 () : while True : try : nb = int ( input ( \"Entrez un entier entre 1 et 10 :\" )) if 1 <= nb and nb <= 10 : return nb else : print ( \"L'entier saisi n'est pas entre 1 et 10. Veuillez recommencer\" ) except ValueError : print ( \"Ce n'est pas un entier, veuillez recommencer !\" ) Exercice Evidemment, la diff\u00e9rence ne saute pas vraiment aux yeux... Pourquoi faire tout un plat d'une seule ligne gagn\u00e9e ? Essayez donc, pour chacune des 2 fonctions pr\u00e9c\u00e9dentes, avec les chaines de caract\u00e8res suivantes : \u00bd 3\u00b2 R\u00e9ponse En fait le probl\u00e8me provient de la m\u00e9thode isnumeric() , dont on ne contr\u00f4le pas vraiment le fonctionnement. On sait que cette m\u00e9thode permet de v\u00e9rifier si une chaine de caract\u00e8res est bien constitu\u00e9e uniquement de caract\u00e8res num\u00e9riques. Mais sans lire r\u00e9ellement la documentation, qui peut se douter que les fractions d\u00e9finies dans la table utf8 , ainsi que les caract\u00e8res en exposant et en indice *, sont consid\u00e9r\u00e9s comme des valeurs num\u00e9riques. L'int\u00e9r\u00eat du bloc try est qu'il se d\u00e9clenchera d\u00e8s qu'il y aura une exception lev\u00e9e. Et cette exception a peu de chance de se produire dans le bloc if / else . La fonction devient dumbproof (mais si vous r\u00e9ussissez \u00e0 d\u00e9clencher une erreur bloquante, signalez-le moi !!). Enchainer les interceptions Il est aussi possible d'avoir plusieurs blocs except successifs, en utilisant : try : # Bloc try except error1 : # Bloc except1 except error2 : # Bloc except2 ... Etendre la gestion des exceptions Il existe de nombreuses autres possibilit\u00e9s utilisant la lev\u00e9e d'exceptions, mais elles d\u00e9passent largement le programme de Terminale. Les plus curieux parmi vous pourront toujours aller lire la doc Python \", qui reste la r\u00e9f\u00e9rence absolue...","title":"Intercepter des exceptions"},{"location":"NSI/Terminale/C01/Intro/","text":"Modularit\u00e9 et initiation \u00e0 la Programmation Orient\u00e9e Objet Quand nous utilisons certaines fonctions o\u00f9 certains objets Python, qu'ils soient built-in ou bien import\u00e9s \u00e0 partir de modules , nous nous posons rarement la question de savoir quelle est leur impl\u00e9mentation , c'est-\u00e0-dire la mani\u00e8re dont-ils ont \u00e9t\u00e9 con\u00e7u et programm\u00e9. Nous faisons globalement confiance aux concepteurs du langage ou du module. Ce qui nous importe est plut\u00f4t l'interface de ces objets, c'est-\u00e0-dire la fa\u00e7on dont nous pouvons interagir avec ces objets : les cr\u00e9er, les affecter, les additionner, les supprimer,... Dans cette partie nous verrons comment cr\u00e9er un module, le documenter, et d\u00e9finir une interface claire. Nous verrons les pr\u00e9mices d'un nouveau paradigme de programmation : la Programmation Orient\u00e9e Objet( POO ). La suite de cette partie est grandement inspir\u00e9e de Num\u00e9riques et Sciences Informatique, 24 le\u00e7ons avec exercices corrig\u00e9, Ellipse Un premier probl\u00e8me Abstract Voici une propri\u00e9t\u00e9 probabiliste peu intuitive : il suffit d'avoir un groupe de 23 personnes pour que la probabilit\u00e9 que deux personnes aient la m\u00eame date d'anniversaire soit sup\u00e9rieure \u00e0 50%. Nous allons construire un programme Python qui permettra de v\u00e9rifier exp\u00e9rimentalement cette propri\u00e9t\u00e9. Pour mod\u00e9liser le probl\u00e8me : plut\u00f4t que d'utiliser des dates, nous allons utiliser des entiers de 1 \u00e0 365 ; nous allons cr\u00e9er une proc\u00e9dure ( une fonction sans param\u00e8tres ) genere_groupe() qui renvoie un tableau al\u00e9atoire de 23 entiers de 1 \u00e0 365 ; nous allons cr\u00e9er une fonction contient_doublon(t) qui renverra True si le tableau contient un doublon, et False sinon ; puis nous cr\u00e9erons une proc\u00e9dure teste_hypothese() qui testera sur un \u00e9chantillon de 100 groupes la pr\u00e9sence d'un doublon ou non, et renverra le nombre de groupes ayant eu des doublons. Exercice Cr\u00e9er un fichier recherchesDates.py et impl\u00e9menter les fonctions pr\u00e9c\u00e9dentes. Des solutions sont propos\u00e9es dans les parties ci-dessous, mais vous devez d'abord tester par vous-m\u00eames . Solutions genere_groupe() from random import randint def genere_groupe () : \"\"\"fonction renvoyant un tableau de 23 nombres al\u00e9atoires entre 1 et 365\"\"\" return [ randint ( 1 , 365 ) for _ in range ( 23 )] contient_doublon(t) def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = [] # s est un tableau temporaire contenant les valeurs test\u00e9es for data in t : if data in s : # si data est d\u00e9j\u00e0 dans s, alors c'est un doublon return True else : # sinon on ajoute data \u00e0 la liste des valeurs test\u00e9es. s . append ( data ) return False teste_hypothese() def teste_hypothese () : \"\"\"fonction renvoyant le nombre de groupes contenant un doublon sur un \u00e9chantillon de 100 groupes\"\"\" nbDoublons = 0 for _ in range ( 100 ) : t = genere_groupe () if contient_doublon ( t ) : nbDoublons += 1 return nbDoublons Ex\u00e9cution dans Basthon Preuve math\u00e9matique Cette pruve est donn\u00e9e \u00e0 titre indicatif, et n'a ni \u00e0 \u00eatre connue, ni m\u00eame \u00e0 \u00eatre comprise. Consid\u00e9rons notre groupe de 23 personnes, et cherchons la probabilit\u00e9 que les 23 personnes n'aient pas la m\u00eame date anniversaire : la premi\u00e8re peut avoir n'importe quel date anniversaire, donc 365 possibilit\u00e9 sur 365 dates possibles. La deuxi\u00e8me ne peut pas avoir la m\u00eame date que les deux premiers, donc 364 possibilit\u00e9s sur 365. La troisi\u00e8me ne peut avoir la m\u00eame date que les deux premiers, donc 363 possibilit\u00e9s sur 365. ... La \\(n-i\u00e8me\\) ne peut avoir la m\u00eame date que les \\(n-1\\) pr\u00e9c\u00e9dents, donc \\(365-(n-1)\\) possibilit\u00e9s. ... La 23\u00e8me ne peut avoir la m\u00eame date que les 22 pr\u00e9c\u00e9dents, donc \\(365-22 = 343\\) possibilit\u00e9s. La probabilit\u00e9 cherch\u00e9e est donc \\(p = \\dfrac{365}{365} \\times \\dfrac{364}{365} \\times ... \\times \\dfrac{343}{365} = \\dfrac{365~!}{342~!.365^{23}}\\) o\u00f9 \\(365~!\\) est la factorielle de 365, soit la multiplication \\(365 \\times 364 \\times 363 \\times ... \\times 2 \\times 1\\) . Or l'\u00e9v\u00e9nement contraire de \"les 23 personnes n'ont pas la m\u00eame date anniversaire\" est l'\u00e9v\u00e9nement \"au moins 2 personnes parmi les 23 ont la m\u00eame date d'anniversaire\" . Donc sa probabilit\u00e9 est \\(p' = 1-p\\) soit en calculant environ \\(0,5073\\) , soit \\(50,73\\) \\%. Plus d'informations peuvent \u00eatre trouv\u00e9es sur l' article correspondant de wikipedia . Diff\u00e9rentes solutions ? Bien entendu, les solutions propos\u00e9es ci-dessus ne sont pas uniques. Elles sont m\u00eames non optimales (en tout cas pour la fonction contient_doublon(t) ). Il est tout \u00e0 fait possible de proposer d'autres impl\u00e9mentations du code, c'est-\u00e0-dire d'autres fa\u00e7ons de coder la fonctionnalit\u00e9 voulue. Ainsi on pourrait regarder les impl\u00e9mentations suivantes, et les comparer entre elles : Exercice : autres impl\u00e9mentations de contient_doublon(t) Tableau de bool\u00e9ens def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = [ False ] * 365 # s est un tableau temporaire contenant false pour chaque date for data in t : if s [ data ] : # si s[data] est vrai (True), alors il y a doublon return True else : # sinon on bascule s[data] \u00e0 True s [ data ] = True return False C'est une solution simple. Mais que dire de ses avantages et de ses inconv\u00e9nients ? Tableau de bits def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = 0 for data in t : if s & ( 1 << data ) != 0 : return True else : s = s | ( 1 << data ) return False C'est une solution beaucoup plus complexe (et hors programme de Terminale dans sa conception). Quels sont ses avantages et ses inconv\u00e9nients ? Table de hachage def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = [[] for _ in range ( 23 )] for data in t : if data in s [ data % 23 ] : return True else : s [ data % 23 ] . append ( data ) return False Solution Solution originale L'avantage est la simplicit\u00e9 du code, et c'est \u00e0 peu pr\u00e8s tout... Par contre les inconv\u00e9nients sont nombreux, en particulier le co\u00fbt en temps : en effet \u00e0 chaque tour de boucle for data in t , on ex\u00e9cute l'instruction data in s , qui parcoure tout le tableau s ... On a donc une complexit\u00e9 en temps en \\(\\mathscr{O}(n^2)\\) (au pire). Pour un tableau de 23 \u00e9l\u00e9ments, c'est acceptable, mais dans l'hypoth\u00e8se d'un tableau de plus grande taille, c'est absolument \u00e0 \u00e9viter ! Solution tableau de bool\u00e9ens Un des avantages est que la complexit\u00e9 en temps est bien meilleure que pour la premi\u00e8re solution. Il n'y a plus les deux boucles imbriqu\u00e9es, d'o\u00f9 un gain consid\u00e9rable. Cependant on peut avoir un probl\u00e8me de co\u00fbt en m\u00e9moire , car on utilise un tableau de taille 365 pour uniquement v\u00e9rifier 23 dates. Dans le cadre d'une comparaison sur un ensemble de valeurs possibles sup\u00e9rieures \u00e0 365, le co\u00fbt en m\u00e9moire peut vite devenir probl\u00e9matique. Solution tableau de bits La solution est tr\u00e8s complexe, mais elle a un grand m\u00e9rite : un bool\u00e9en, en python, est en fait un entier (0 ou 1), donc stock\u00e9 sur... 8 octets ! (source ici ) Or il n'est pas n\u00e9cessaire d'utilier 8 octets, soit 64 bits, pour stocker un bool\u00e9en... En fait il suffit d'un seul bit ! Cette solution divise donc par 64 la taille m\u00e9moire par rapport \u00e0 la solution pr\u00e9c\u00e9dente ! C'est globalement un bon avantage dans cette situation,; mais cela reste rapidement insuffisant si le nombre d'\u00e9l\u00e9ments auquel on s'int\u00e9rese est bien plus grand que 365. Il faut noter que le tableau de bits (ou bit set ou bit array ) est une structure compacte qui permet de repr\u00e9senter facilement des tableaux de bool\u00e9ens. Elle permet une meilleure utilisation des ressources m\u00e9moires dans les cas o\u00f9 celle-ci est limit\u00e9e, comme par exemple dans la m\u00e9moire cache du processeur. Solution table de hachage Comme nous l'avons vu en classede premi\u00e8re, la table de hachage est une solkution efficace et \u00e9l\u00e9gante qui permet de gangner \u00e0 la fois du co\u00fbt en temps (on ne parcoure pas un tableau, on atteint directement l'objet par sa cl\u00e9 , ou en tout on parcoure un sous-ensemble beaucoup plus petit), et du co\u00fbt en m\u00e9moire (le tableau des cl\u00e9s est de la taille strictement n\u00e9cessaire). Une m\u00eame interface Exercice Quand on observe les 4 propositions de codes pour la fonction contient_doublon(t) , on peut constater que ces 4 codes sont quasiment identiques. Quelles sont ces parties identiques ? Solution def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = ... for data in t : if ... : return True else : ... return False Les parties en pointill\u00e9 de la solution pr\u00e9c\u00e9dente v\u00e9rifient les conditions suivantes : s repr\u00e9sente un ensemble de date, et le premier trou correspond \u00e0 la cr\u00e9ation de cette structure. Le deuxi\u00e8me trou consiste \u00e0 v\u00e9rifier si data est contenu dans s . le troisi\u00e8me trou consiste \u00e0 ajouter data \u00e0 s Seules ces trois parties changent dans les 4 programmes. On pourrait alors isoler ces trois aspects dans trois fonctions diff\u00e9rentes et obtenir le code factoris\u00e9 suivant : Code factoris\u00e9 def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = cree () for data in t : if contient ( data , s ) : return True else : ajoute ( data , s ) return False On d\u00e9finit ainsi une fonction contient_doublon(t) compl\u00e8tement s\u00e9par\u00e9e de la repr\u00e9sentation de la structure s . Le programmeur qui souhaite simplement utiliser la structure de donn\u00e9e s n'a pas \u00e0 se pr\u00e9occuper de la fa\u00e7on dont elle a \u00e9t\u00e9 impl\u00e9ment\u00e9e . Il n'a besoin que de conna\u00eetre son interface : la fonction cree() sert \u00e0 construire une structure ; la fonction contient(data,s) sert \u00e0 regarder si data est contenu dans la structure s ; La fonction ajoute(data,s) ajoute l'\u00e9l\u00e9ment data \u00e0 la structure s . C'est exactement ce qui se passe quand on utilise des modules python : on ne cherche pas \u00e0 savoir comment sont programm\u00e9s les fonctions du modules(= l'impl\u00e9mentation du module ) - car on fait confiance aux programmeurs de ce module, mais juste \u00e0 savoir comment utiliser ces fonctions(= l'interface du module ). Encore mieux, le programmeur du module peut, si il ne change pas l' interface (= la mani\u00e8re d'utiliser les fonctions), am\u00e9liorer ces fonctions (en temps, en m\u00e9moire, etc...) sans m\u00eame que l'utilisateur n'ait \u00e0 changer quoi que ce soit \u00e0 son propre programme, qui continuera \u00e0 fonctionner (mieux, du moins on esp\u00e8re...).","title":"Introduction"},{"location":"NSI/Terminale/C01/Intro/#modularite-et-initiation-a-la-programmation-orientee-objet","text":"Quand nous utilisons certaines fonctions o\u00f9 certains objets Python, qu'ils soient built-in ou bien import\u00e9s \u00e0 partir de modules , nous nous posons rarement la question de savoir quelle est leur impl\u00e9mentation , c'est-\u00e0-dire la mani\u00e8re dont-ils ont \u00e9t\u00e9 con\u00e7u et programm\u00e9. Nous faisons globalement confiance aux concepteurs du langage ou du module. Ce qui nous importe est plut\u00f4t l'interface de ces objets, c'est-\u00e0-dire la fa\u00e7on dont nous pouvons interagir avec ces objets : les cr\u00e9er, les affecter, les additionner, les supprimer,... Dans cette partie nous verrons comment cr\u00e9er un module, le documenter, et d\u00e9finir une interface claire. Nous verrons les pr\u00e9mices d'un nouveau paradigme de programmation : la Programmation Orient\u00e9e Objet( POO ). La suite de cette partie est grandement inspir\u00e9e de Num\u00e9riques et Sciences Informatique, 24 le\u00e7ons avec exercices corrig\u00e9, Ellipse","title":"Modularit\u00e9 et initiation \u00e0 la Programmation Orient\u00e9e Objet"},{"location":"NSI/Terminale/C01/Intro/#un-premier-probleme","text":"Abstract Voici une propri\u00e9t\u00e9 probabiliste peu intuitive : il suffit d'avoir un groupe de 23 personnes pour que la probabilit\u00e9 que deux personnes aient la m\u00eame date d'anniversaire soit sup\u00e9rieure \u00e0 50%. Nous allons construire un programme Python qui permettra de v\u00e9rifier exp\u00e9rimentalement cette propri\u00e9t\u00e9. Pour mod\u00e9liser le probl\u00e8me : plut\u00f4t que d'utiliser des dates, nous allons utiliser des entiers de 1 \u00e0 365 ; nous allons cr\u00e9er une proc\u00e9dure ( une fonction sans param\u00e8tres ) genere_groupe() qui renvoie un tableau al\u00e9atoire de 23 entiers de 1 \u00e0 365 ; nous allons cr\u00e9er une fonction contient_doublon(t) qui renverra True si le tableau contient un doublon, et False sinon ; puis nous cr\u00e9erons une proc\u00e9dure teste_hypothese() qui testera sur un \u00e9chantillon de 100 groupes la pr\u00e9sence d'un doublon ou non, et renverra le nombre de groupes ayant eu des doublons. Exercice Cr\u00e9er un fichier recherchesDates.py et impl\u00e9menter les fonctions pr\u00e9c\u00e9dentes. Des solutions sont propos\u00e9es dans les parties ci-dessous, mais vous devez d'abord tester par vous-m\u00eames . Solutions genere_groupe() from random import randint def genere_groupe () : \"\"\"fonction renvoyant un tableau de 23 nombres al\u00e9atoires entre 1 et 365\"\"\" return [ randint ( 1 , 365 ) for _ in range ( 23 )] contient_doublon(t) def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = [] # s est un tableau temporaire contenant les valeurs test\u00e9es for data in t : if data in s : # si data est d\u00e9j\u00e0 dans s, alors c'est un doublon return True else : # sinon on ajoute data \u00e0 la liste des valeurs test\u00e9es. s . append ( data ) return False teste_hypothese() def teste_hypothese () : \"\"\"fonction renvoyant le nombre de groupes contenant un doublon sur un \u00e9chantillon de 100 groupes\"\"\" nbDoublons = 0 for _ in range ( 100 ) : t = genere_groupe () if contient_doublon ( t ) : nbDoublons += 1 return nbDoublons Ex\u00e9cution dans Basthon Preuve math\u00e9matique Cette pruve est donn\u00e9e \u00e0 titre indicatif, et n'a ni \u00e0 \u00eatre connue, ni m\u00eame \u00e0 \u00eatre comprise. Consid\u00e9rons notre groupe de 23 personnes, et cherchons la probabilit\u00e9 que les 23 personnes n'aient pas la m\u00eame date anniversaire : la premi\u00e8re peut avoir n'importe quel date anniversaire, donc 365 possibilit\u00e9 sur 365 dates possibles. La deuxi\u00e8me ne peut pas avoir la m\u00eame date que les deux premiers, donc 364 possibilit\u00e9s sur 365. La troisi\u00e8me ne peut avoir la m\u00eame date que les deux premiers, donc 363 possibilit\u00e9s sur 365. ... La \\(n-i\u00e8me\\) ne peut avoir la m\u00eame date que les \\(n-1\\) pr\u00e9c\u00e9dents, donc \\(365-(n-1)\\) possibilit\u00e9s. ... La 23\u00e8me ne peut avoir la m\u00eame date que les 22 pr\u00e9c\u00e9dents, donc \\(365-22 = 343\\) possibilit\u00e9s. La probabilit\u00e9 cherch\u00e9e est donc \\(p = \\dfrac{365}{365} \\times \\dfrac{364}{365} \\times ... \\times \\dfrac{343}{365} = \\dfrac{365~!}{342~!.365^{23}}\\) o\u00f9 \\(365~!\\) est la factorielle de 365, soit la multiplication \\(365 \\times 364 \\times 363 \\times ... \\times 2 \\times 1\\) . Or l'\u00e9v\u00e9nement contraire de \"les 23 personnes n'ont pas la m\u00eame date anniversaire\" est l'\u00e9v\u00e9nement \"au moins 2 personnes parmi les 23 ont la m\u00eame date d'anniversaire\" . Donc sa probabilit\u00e9 est \\(p' = 1-p\\) soit en calculant environ \\(0,5073\\) , soit \\(50,73\\) \\%. Plus d'informations peuvent \u00eatre trouv\u00e9es sur l' article correspondant de wikipedia .","title":"Un premier probl\u00e8me"},{"location":"NSI/Terminale/C01/Intro/#differentes-solutions","text":"Bien entendu, les solutions propos\u00e9es ci-dessus ne sont pas uniques. Elles sont m\u00eames non optimales (en tout cas pour la fonction contient_doublon(t) ). Il est tout \u00e0 fait possible de proposer d'autres impl\u00e9mentations du code, c'est-\u00e0-dire d'autres fa\u00e7ons de coder la fonctionnalit\u00e9 voulue. Ainsi on pourrait regarder les impl\u00e9mentations suivantes, et les comparer entre elles : Exercice : autres impl\u00e9mentations de contient_doublon(t) Tableau de bool\u00e9ens def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = [ False ] * 365 # s est un tableau temporaire contenant false pour chaque date for data in t : if s [ data ] : # si s[data] est vrai (True), alors il y a doublon return True else : # sinon on bascule s[data] \u00e0 True s [ data ] = True return False C'est une solution simple. Mais que dire de ses avantages et de ses inconv\u00e9nients ? Tableau de bits def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = 0 for data in t : if s & ( 1 << data ) != 0 : return True else : s = s | ( 1 << data ) return False C'est une solution beaucoup plus complexe (et hors programme de Terminale dans sa conception). Quels sont ses avantages et ses inconv\u00e9nients ? Table de hachage def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = [[] for _ in range ( 23 )] for data in t : if data in s [ data % 23 ] : return True else : s [ data % 23 ] . append ( data ) return False Solution Solution originale L'avantage est la simplicit\u00e9 du code, et c'est \u00e0 peu pr\u00e8s tout... Par contre les inconv\u00e9nients sont nombreux, en particulier le co\u00fbt en temps : en effet \u00e0 chaque tour de boucle for data in t , on ex\u00e9cute l'instruction data in s , qui parcoure tout le tableau s ... On a donc une complexit\u00e9 en temps en \\(\\mathscr{O}(n^2)\\) (au pire). Pour un tableau de 23 \u00e9l\u00e9ments, c'est acceptable, mais dans l'hypoth\u00e8se d'un tableau de plus grande taille, c'est absolument \u00e0 \u00e9viter ! Solution tableau de bool\u00e9ens Un des avantages est que la complexit\u00e9 en temps est bien meilleure que pour la premi\u00e8re solution. Il n'y a plus les deux boucles imbriqu\u00e9es, d'o\u00f9 un gain consid\u00e9rable. Cependant on peut avoir un probl\u00e8me de co\u00fbt en m\u00e9moire , car on utilise un tableau de taille 365 pour uniquement v\u00e9rifier 23 dates. Dans le cadre d'une comparaison sur un ensemble de valeurs possibles sup\u00e9rieures \u00e0 365, le co\u00fbt en m\u00e9moire peut vite devenir probl\u00e9matique. Solution tableau de bits La solution est tr\u00e8s complexe, mais elle a un grand m\u00e9rite : un bool\u00e9en, en python, est en fait un entier (0 ou 1), donc stock\u00e9 sur... 8 octets ! (source ici ) Or il n'est pas n\u00e9cessaire d'utilier 8 octets, soit 64 bits, pour stocker un bool\u00e9en... En fait il suffit d'un seul bit ! Cette solution divise donc par 64 la taille m\u00e9moire par rapport \u00e0 la solution pr\u00e9c\u00e9dente ! C'est globalement un bon avantage dans cette situation,; mais cela reste rapidement insuffisant si le nombre d'\u00e9l\u00e9ments auquel on s'int\u00e9rese est bien plus grand que 365. Il faut noter que le tableau de bits (ou bit set ou bit array ) est une structure compacte qui permet de repr\u00e9senter facilement des tableaux de bool\u00e9ens. Elle permet une meilleure utilisation des ressources m\u00e9moires dans les cas o\u00f9 celle-ci est limit\u00e9e, comme par exemple dans la m\u00e9moire cache du processeur. Solution table de hachage Comme nous l'avons vu en classede premi\u00e8re, la table de hachage est une solkution efficace et \u00e9l\u00e9gante qui permet de gangner \u00e0 la fois du co\u00fbt en temps (on ne parcoure pas un tableau, on atteint directement l'objet par sa cl\u00e9 , ou en tout on parcoure un sous-ensemble beaucoup plus petit), et du co\u00fbt en m\u00e9moire (le tableau des cl\u00e9s est de la taille strictement n\u00e9cessaire).","title":"Diff\u00e9rentes solutions ?"},{"location":"NSI/Terminale/C01/Intro/#une-meme-interface","text":"Exercice Quand on observe les 4 propositions de codes pour la fonction contient_doublon(t) , on peut constater que ces 4 codes sont quasiment identiques. Quelles sont ces parties identiques ? Solution def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = ... for data in t : if ... : return True else : ... return False Les parties en pointill\u00e9 de la solution pr\u00e9c\u00e9dente v\u00e9rifient les conditions suivantes : s repr\u00e9sente un ensemble de date, et le premier trou correspond \u00e0 la cr\u00e9ation de cette structure. Le deuxi\u00e8me trou consiste \u00e0 v\u00e9rifier si data est contenu dans s . le troisi\u00e8me trou consiste \u00e0 ajouter data \u00e0 s Seules ces trois parties changent dans les 4 programmes. On pourrait alors isoler ces trois aspects dans trois fonctions diff\u00e9rentes et obtenir le code factoris\u00e9 suivant : Code factoris\u00e9 def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = cree () for data in t : if contient ( data , s ) : return True else : ajoute ( data , s ) return False On d\u00e9finit ainsi une fonction contient_doublon(t) compl\u00e8tement s\u00e9par\u00e9e de la repr\u00e9sentation de la structure s . Le programmeur qui souhaite simplement utiliser la structure de donn\u00e9e s n'a pas \u00e0 se pr\u00e9occuper de la fa\u00e7on dont elle a \u00e9t\u00e9 impl\u00e9ment\u00e9e . Il n'a besoin que de conna\u00eetre son interface : la fonction cree() sert \u00e0 construire une structure ; la fonction contient(data,s) sert \u00e0 regarder si data est contenu dans la structure s ; La fonction ajoute(data,s) ajoute l'\u00e9l\u00e9ment data \u00e0 la structure s . C'est exactement ce qui se passe quand on utilise des modules python : on ne cherche pas \u00e0 savoir comment sont programm\u00e9s les fonctions du modules(= l'impl\u00e9mentation du module ) - car on fait confiance aux programmeurs de ce module, mais juste \u00e0 savoir comment utiliser ces fonctions(= l'interface du module ). Encore mieux, le programmeur du module peut, si il ne change pas l' interface (= la mani\u00e8re d'utiliser les fonctions), am\u00e9liorer ces fonctions (en temps, en m\u00e9moire, etc...) sans m\u00eame que l'utilisateur n'ait \u00e0 changer quoi que ce soit \u00e0 son propre programme, qui continuera \u00e0 fonctionner (mieux, du moins on esp\u00e8re...).","title":"Une m\u00eame interface"},{"location":"NSI/Terminale/C01/IntroPOO/","text":"Introduction \u00e0 la promgrammation orient\u00e9e objet Un premier exemple issu de Scratch Observons ce jeu assez minable en Scratch (non, mais vraiment, allez-voir sur le site...). Ce jeu sommaire est construit autour de trois \u00e9l\u00e9ments : la chauve-souris ; l'\u00e9clair ; le chat. Chacun de ces trois \u00e9l\u00e9ments poss\u00e8de : sa propre zone de script; ses propres caract\u00e9ristiques (nom, taille, costumes, position de d\u00e9part, orientation...). Et ces trois \u00e9l\u00e9ments r\u00e9agissent en fonction d'\u00e9v\u00e9nements li\u00e9s soit \u00e0 l'action du joueur, soit \u00e0 leurs propres interactions. L'\u00e9clair et le chat ont la possibilit\u00e9 d'exister sous la forme de clones , chacun des clones ayant ses propres caract\u00e9ristiques bien que partageant le m\u00eame comportement . Aussi simpliste que Scratch paraisse, il n'en est n\u00e9anmoins pas un v\u00e9ritable langage de programmation , qui plus est multiparadigme : il est en effet con\u00e7u pour g\u00e9rer la programmation imp\u00e9rative , la programmation orient\u00e9e objet ainsi que la programmation \u00e9v\u00e9nementielle . Paradigmes de programmation Un paradigme est * \"une repr\u00e9sentation du monde, une mani\u00e8re de voir les choses, un mod\u00e8le coh\u00e9rent du monde qui repose sur un fondement d\u00e9fini\" *. Wkipedia . En programmation, plus pr\u00e9cisemment, on parle de paradigmes de programmation pour exprimer lma mabi\u00e8re dont sont con\u00e7u et envisag\u00e9s les programmes. On distingue entre autres : le paradigme de la programmation imp\u00e9rative , qui est celui que nous avons utilis\u00e9 jusqu'ici : on d\u00e9crit les op\u00e9rations en s\u00e9quences d'instructions ex\u00e9cut\u00e9es par l'ordinateur dans un ordre pr\u00e9cis (que le langage soit compil\u00e9 ou interpr\u00e9t\u00e9). C'est le paradigme classique, celui auquel tout le monde pense quand on parle de programme informatique. le paradigme de la programmation orient\u00e9 objet , qui \"consiste en la d\u00e9finition et l'interaction de briques logicielles appel\u00e9es objets ; un objet repr\u00e9sente un concept, une id\u00e9e ou toute entit\u00e9 du monde physique, comme une voiture, une personne ou encore une page d'un livre. Il poss\u00e8de une structure interne et un comportement, et il sait interagir avec ses pairs. Il s'agit donc de repr\u00e9senter ces objets et leurs relation[...]\". Wikipedia . le paradigme de la programmation fonctionnelle , qui consid\u00e8re le calcul en tant qu'\u00e9valuation de fonctions math\u00e9matiques. le paradigme de la programmation \u00e9v\u00e9nementielle , qui est fond\u00e9 sur la notion d'\u00e9v\u00e9nements. Le programme sera principalement d\u00e9fini par ses r\u00e9actions aux diff\u00e9rents \u00e9v\u00e9nements qui peuvent se produire, c'est-\u00e0-dire des changements d'\u00e9tat de variable, par exemple l'incr\u00e9mentation d'une liste, un d\u00e9placement ou un click de souris, une saisie au clavier... et bien d'autres ... Les diff\u00e9rents langages de programmation peuvent \u00eatre plus ou moins sp\u00e9cialis\u00e9 selon un certain nombre de paradigmes. Quasim\u00f9ent tous respectent le paradigme originel imp\u00e9ratif . Certains langages ne d\u00e9passent pas ce paradigme (assembleur, Fortran, Algol, BASIC,... ). D'autres sont sp\u00e9cialis\u00e9s sur un paradigme sp\u00e9cifique ( comme Lisp, ML, OCaml en programmation fonctionnelle, Ada, Smalltalk, C++, Ruby, C# Swift... en POO). Mais en g\u00e9n\u00e9ral tous les langages cit\u00e9s poss\u00e8dent des composantes multiparadigmes . C'est le cas de Python, qui supporte la programmation : imp\u00e9rative ; fonctionnelle ; proc\u00e9durale ; orient\u00e9e objet ; et en partie \u00e9v\u00e9nementielle. Principes Le concept principal de la programmation orient\u00e9e objet (POO) est celui d' objet . Nous avons d\u00e9j\u00e0 rencontr\u00e9 un certain nombres d'objets pr\u00e9d\u00e9finis dans Python : la classe int , pour repr\u00e9senter les entiers relatifs ; la classe float , pour repr\u00e9senter les nombre \u00e0 virgule flottante (une partie des d\u00e9cimaux) ; la classe str pour repr\u00e9senter les cha\u00eenes de caract\u00e8res ; la classe list , pour repr\u00e9senter un ensemble ordonn\u00e9 et mutable de toute autre collection d'objets ; la classe tuple , pour repr\u00e9senter un ensemble ordonn\u00e9 et non-mutable de toute autre collection d'objets ; la classe set , pour repr\u00e9senter un ensemble non ordonn\u00e9 et sans doublons ; la classe dict , pour repr\u00e9senter une collection non ordonn\u00e9e index\u00e9e par des cl\u00e9s. Chacun de ces types pr\u00e9c\u00e9dents poss\u00e8de ses propres attributs et ses propres m\u00e9thodes : un objet de la classe str poss\u00e8de une longueur, donn\u00e9 par la fonction built-in len() , et plusieurs m\u00e9thodes associ\u00e9es comme lower() , upper() , etc... un objet de la classe list poss\u00e8de lui aussi une longueur, et ses propres m\u00e9thodes comme append() , pop() , etc... Classes et constructeurs d'objets En Programmation Orient\u00e9e Objet, on va construire de nouvelles classes d'objets plus ou moins complexes, poss\u00e9dant : des attributs , c'est-\u00e0-dire des variables sp\u00e9cifiques qui lui sont directement associ\u00e9es ; des m\u00e9thodes , c'est-\u00e0-dire des fonctions modifiant l'objet, ou interagissant avec l'environnement ext\u00e9rieur \u00e0 cet objet. Personnages de JDR/MMORPG Prenons un JDR ou MMORPG lambda, dont les personnages sont constitu\u00e9s ainsi : ils ont 4 caract\u00e9ristiques num\u00e9riques entre \\(1\\) et \\(40\\) , \u00e0 savoir force, endurance, rapidit\u00e9, intelligence ; ils ont un nombre de points de vie de d\u00e9part calcul\u00e9 \u00e0 partir des caract\u00e9ristiques endurance + force//2 ; ils poss\u00e8dent bien s\u00fbr un nom ; leur nombre de points d'exp\u00e9rience au d\u00e9part est de \\(0\\) , et leur niveau est de \\(1\\) .","title":"Introduction \u00e0 la POO"},{"location":"NSI/Terminale/C01/IntroPOO/#introduction-a-la-promgrammation-orientee-objet","text":"","title":"Introduction \u00e0 la promgrammation orient\u00e9e objet"},{"location":"NSI/Terminale/C01/IntroPOO/#un-premier-exemple-issu-de-scratch","text":"Observons ce jeu assez minable en Scratch (non, mais vraiment, allez-voir sur le site...). Ce jeu sommaire est construit autour de trois \u00e9l\u00e9ments : la chauve-souris ; l'\u00e9clair ; le chat. Chacun de ces trois \u00e9l\u00e9ments poss\u00e8de : sa propre zone de script; ses propres caract\u00e9ristiques (nom, taille, costumes, position de d\u00e9part, orientation...). Et ces trois \u00e9l\u00e9ments r\u00e9agissent en fonction d'\u00e9v\u00e9nements li\u00e9s soit \u00e0 l'action du joueur, soit \u00e0 leurs propres interactions. L'\u00e9clair et le chat ont la possibilit\u00e9 d'exister sous la forme de clones , chacun des clones ayant ses propres caract\u00e9ristiques bien que partageant le m\u00eame comportement . Aussi simpliste que Scratch paraisse, il n'en est n\u00e9anmoins pas un v\u00e9ritable langage de programmation , qui plus est multiparadigme : il est en effet con\u00e7u pour g\u00e9rer la programmation imp\u00e9rative , la programmation orient\u00e9e objet ainsi que la programmation \u00e9v\u00e9nementielle . Paradigmes de programmation Un paradigme est * \"une repr\u00e9sentation du monde, une mani\u00e8re de voir les choses, un mod\u00e8le coh\u00e9rent du monde qui repose sur un fondement d\u00e9fini\" *. Wkipedia . En programmation, plus pr\u00e9cisemment, on parle de paradigmes de programmation pour exprimer lma mabi\u00e8re dont sont con\u00e7u et envisag\u00e9s les programmes. On distingue entre autres : le paradigme de la programmation imp\u00e9rative , qui est celui que nous avons utilis\u00e9 jusqu'ici : on d\u00e9crit les op\u00e9rations en s\u00e9quences d'instructions ex\u00e9cut\u00e9es par l'ordinateur dans un ordre pr\u00e9cis (que le langage soit compil\u00e9 ou interpr\u00e9t\u00e9). C'est le paradigme classique, celui auquel tout le monde pense quand on parle de programme informatique. le paradigme de la programmation orient\u00e9 objet , qui \"consiste en la d\u00e9finition et l'interaction de briques logicielles appel\u00e9es objets ; un objet repr\u00e9sente un concept, une id\u00e9e ou toute entit\u00e9 du monde physique, comme une voiture, une personne ou encore une page d'un livre. Il poss\u00e8de une structure interne et un comportement, et il sait interagir avec ses pairs. Il s'agit donc de repr\u00e9senter ces objets et leurs relation[...]\". Wikipedia . le paradigme de la programmation fonctionnelle , qui consid\u00e8re le calcul en tant qu'\u00e9valuation de fonctions math\u00e9matiques. le paradigme de la programmation \u00e9v\u00e9nementielle , qui est fond\u00e9 sur la notion d'\u00e9v\u00e9nements. Le programme sera principalement d\u00e9fini par ses r\u00e9actions aux diff\u00e9rents \u00e9v\u00e9nements qui peuvent se produire, c'est-\u00e0-dire des changements d'\u00e9tat de variable, par exemple l'incr\u00e9mentation d'une liste, un d\u00e9placement ou un click de souris, une saisie au clavier... et bien d'autres ... Les diff\u00e9rents langages de programmation peuvent \u00eatre plus ou moins sp\u00e9cialis\u00e9 selon un certain nombre de paradigmes. Quasim\u00f9ent tous respectent le paradigme originel imp\u00e9ratif . Certains langages ne d\u00e9passent pas ce paradigme (assembleur, Fortran, Algol, BASIC,... ). D'autres sont sp\u00e9cialis\u00e9s sur un paradigme sp\u00e9cifique ( comme Lisp, ML, OCaml en programmation fonctionnelle, Ada, Smalltalk, C++, Ruby, C# Swift... en POO). Mais en g\u00e9n\u00e9ral tous les langages cit\u00e9s poss\u00e8dent des composantes multiparadigmes . C'est le cas de Python, qui supporte la programmation : imp\u00e9rative ; fonctionnelle ; proc\u00e9durale ; orient\u00e9e objet ; et en partie \u00e9v\u00e9nementielle.","title":"Un premier exemple issu de Scratch"},{"location":"NSI/Terminale/C01/IntroPOO/#principes","text":"Le concept principal de la programmation orient\u00e9e objet (POO) est celui d' objet . Nous avons d\u00e9j\u00e0 rencontr\u00e9 un certain nombres d'objets pr\u00e9d\u00e9finis dans Python : la classe int , pour repr\u00e9senter les entiers relatifs ; la classe float , pour repr\u00e9senter les nombre \u00e0 virgule flottante (une partie des d\u00e9cimaux) ; la classe str pour repr\u00e9senter les cha\u00eenes de caract\u00e8res ; la classe list , pour repr\u00e9senter un ensemble ordonn\u00e9 et mutable de toute autre collection d'objets ; la classe tuple , pour repr\u00e9senter un ensemble ordonn\u00e9 et non-mutable de toute autre collection d'objets ; la classe set , pour repr\u00e9senter un ensemble non ordonn\u00e9 et sans doublons ; la classe dict , pour repr\u00e9senter une collection non ordonn\u00e9e index\u00e9e par des cl\u00e9s. Chacun de ces types pr\u00e9c\u00e9dents poss\u00e8de ses propres attributs et ses propres m\u00e9thodes : un objet de la classe str poss\u00e8de une longueur, donn\u00e9 par la fonction built-in len() , et plusieurs m\u00e9thodes associ\u00e9es comme lower() , upper() , etc... un objet de la classe list poss\u00e8de lui aussi une longueur, et ses propres m\u00e9thodes comme append() , pop() , etc... Classes et constructeurs d'objets En Programmation Orient\u00e9e Objet, on va construire de nouvelles classes d'objets plus ou moins complexes, poss\u00e9dant : des attributs , c'est-\u00e0-dire des variables sp\u00e9cifiques qui lui sont directement associ\u00e9es ; des m\u00e9thodes , c'est-\u00e0-dire des fonctions modifiant l'objet, ou interagissant avec l'environnement ext\u00e9rieur \u00e0 cet objet. Personnages de JDR/MMORPG Prenons un JDR ou MMORPG lambda, dont les personnages sont constitu\u00e9s ainsi : ils ont 4 caract\u00e9ristiques num\u00e9riques entre \\(1\\) et \\(40\\) , \u00e0 savoir force, endurance, rapidit\u00e9, intelligence ; ils ont un nombre de points de vie de d\u00e9part calcul\u00e9 \u00e0 partir des caract\u00e9ristiques endurance + force//2 ; ils poss\u00e8dent bien s\u00fbr un nom ; leur nombre de points d'exp\u00e9rience au d\u00e9part est de \\(0\\) , et leur niveau est de \\(1\\) .","title":"Principes"},{"location":"NSI/Terminale/C01/Modularite/","text":"Modules, Interfaces et Encapsulation Retour sur les modules Un module python est un fichier python contenant des fonctions, des constantes (et des constructeurs d' objets , mais nous verrons \u00e7a un peu plus tard), regroup\u00e9es dans ce fichier car elles traitent de la m\u00eame structure de donn\u00e9es . Un exemple Par exemple, dans un jeu vid\u00e9o tel que Space Invaders , on aura : un module qui traitera du vaisseau du joueur ; un module pour construire et g\u00e9rer les vaisseaux ennemis ; un ou des modules pour construire et actualiser l'interface graphique ; un module contenant des constantes (points de vie de d\u00e9part du joueur, nombre d'ennemis, etc) ; et le programme principal qui importera les modules pr\u00e9c\u00e9dents et g\u00e9rera les \u00e9v\u00e9nements liant tous les objets du jeu. On dira que ce programme d\u00e9pend des autres modules. Importer un module Il existe plusieurs possibilit\u00e9s pour importer un module. Dans la suite des exemples, le module toto , contenant les fonctions bidule() et truc() est situ\u00e9 : soit dans le m\u00eame dossier que le fichier qui l'importe ; soit dans un dossier accessible par le syst\u00e8me ( dossier faisant partie de la variable PATH de windows par exemple). Import complet import toto toto . bidule () toto . truc () Toutes les fonctions du module toto sont import\u00e9es, et elles le sont dans un namespace (= espace de nommage\") sp\u00e9cifique. Les fonctions sont alors appel\u00e9es en les pr\u00e9fixant** par le nom du module ( toto. ). Import complet avec alias import toto as to to . bidule () to . truc () Comme pour l'import complet, toutes les fonctions du module toto sont import\u00e9es, et elles le sont dans un namespace (= espace de nommage\") sp\u00e9cifique. Les fonctions sont alors appel\u00e9es en les pr\u00e9fixant par l'alias** du module ( to1. ). Import partiel dans le namespace courant from toto import bidule bidule () Ici, seul la fonction bidule() est import\u00e9e, mais elle l'est directement dans le namespace principal (= main ) du fichier effectuant l'import. La fonction truc() n'est pas appelable (elle n'existe pas pour l'interpr\u00e9teur). Import complet dans le namespace courant from toto import * bidule () truc () Toutes les fonctions sont appel\u00e9es directement dans le namespace principal (= main ) du fichier effectuant l'import. \u26a0\ufe0f C'est une pratique p\u00e9rilleuse ! Si une fonction du module porte le m\u00eame nom qu'une fonction du fichier appelant, celle import\u00e9e \u00e9crasera celle du fichiert courant, et \u00e7a peut-\u00eatre facheux... Voir l'exemple ci-dessous... Fichier principal from mon_module import * print ( \"Pain \" ) Fichier mon_module.py def print ( truc ) : print ( truc * 3 + \"Tarte Tatin\" * 2 ) Sortie attendue Probablement, ce qui est attendu par la sortie du fichier principal est juste la cha\u00eene de caract\u00e8res \"Pain \" . Mais la fonction built-in print() a \u00e9t\u00e9 \u00e9cras\u00e9e par celle du module mon_module.py . Sortie r\u00e9elle \"Pain Pain Pain Tarte Tatin Tarte Tatin\u00a8 La v\u00e9ritable fonction appel\u00e9e est celle du module mon_module.py . (Pour ceux qui ont en t\u00eate la marche imp\u00e9riale, c'est normal...) Remarque Il est toutefois possible d'importer un fichier pr\u00e9sent dans un autre dossier : soit en utilisant une adresse absolue import 'C:\\Mes_Programmes\\Python\\toto.py' ; soit en utilisant une adresse relatice import '..\\toto.py' ( si toto.py est situ\u00e9 dans le dossier parent du fichier qui importe). Interfaces Conception logicielle Dans la conception de logiciels \u00e0 grande \u00e9chelle, ou \u00e0 pluseiurs programmeurs (et \u00e0 l'heure actuelle il est fr\u00e9quent d'avoir plusieurs milliers de programmeurs concevant un logiciel), il est important de pouvoir s\u00e9parer les diff\u00e9rents \u00e9l\u00e9ments du programme en sous-ensembles coh\u00e9rents et ayant le minimum d'interactions entre eux. En particuliers ils se doivent d'\u00eatre le plus \u00e9tanches possibles quant \u00e0 leur fonctionnement. On retrouve ici que la notion d' interface est essentielle. Pour chaque module, on peut donc distinguer : une interface , c'est-\u00e0-dire la description des diff\u00e9rentes fonctions du module et de leurs arguments (obligatoires ou facultatifs). Il s'agit donc d'une documentation la plus claire possible sur la mani\u00e8re d' utiliser le module. une impl\u00e9mentation , c'est-\u00e0-dire la mani\u00e8re dont sont cod\u00e9es ces fonctions (choix de structures, nom des variables interm\u00e9diaires, etc...). Un exemple d'interface Un module utilisable pour la fonction factoris\u00e9e contient_doublon(t) aura pour interface : fonction Description cree() cr\u00e9e et renvoie un ensemble de date vide contient(data,s) renvoie True si la structure s contient la donn\u00e9e data ajoute(data,s) ajoute la donn\u00e9e data \u00e0 la structure s Vous constaterez que dans cette description, il n'est nul part fait mention de la nature de la structure . Il pourrait s'agir aussi bien de liste, de tableau de bits, de tables de hachage... Exercice : r\u00e9alisation de modules Dans chacun des cas suivant, construire un module r\u00e9alisant l'interface ci-dessus, et le tester en l'important dans le fichier rechercheDates.py o\u00f9 vous aurez modifier la fonction contient_doublon(t) par la version factoris\u00e9e de celle-ci. un module dateTab , dont la structure est impl\u00e9ment\u00e9e sous la forme d'un tableau. un module dateBool , dont la structure est impl\u00e9ment\u00e9e sous la forme d'un tableau de bool\u00e9en. un module dateHash , dont la structure est impl\u00e9ment\u00e9e sous la forme d'une table de hachage. \ud83e\udde9 Il est bien entendu essentiel de s'inspirer des exemples donn\u00e9 dans la page d'introduction . Notions d'encapsulation Notion d'encapsulation Le contrat qu'une interface \u00e9tablit entre l'utilisateur et l'auteur d'un module ne porte pas sur les moyens, mais sur les r\u00e9sultats : l'auteur s'engage \u00e0 ce que les r\u00e9sultats produits par l'utilisation de ses fonctions soient bien ceux d\u00e9crits dans l'interface, mais il est libre de s'y prendre comme il le souhaite. En particulier il est libre d'introduire des fonctions, variables, constantes, ..., qui ne sont pas inclues dans l'interface . On parle alors de fonctions, variables, constantes encapsul\u00e9es dans le module. Le contrat explicite est que l'utilisateur ne doit en aucun cas utiliser ces donn\u00e9es encapsul\u00e9es. Dans le cas contraire, si l'auteur du module change son approche et modifie ces donn\u00e9es internes, le programme du client risque de devenir non fonctionnel. Norme en Python En Python, l'auteur d'un module peut indiquer que certains \u00e9l\u00e9ments sont priv\u00e9s (= encapsul\u00e9s) en faisant commencer leur nom par un cracat\u00e8re underscore _ Exemple Imaginons un module secondDegre.py dont l'interface est d\u00e9finie ainsi : fonction Description polynome(t) V\u00e9rifie que le tuple t sous la forme (a,b,c) repr\u00e9sente bien un polyn\u00f4me de degr\u00e9 2 valeursRacines(p) Renvoie les valeurs des racines, et None si il n'existe pas de recines r\u00e9elles convexite(p) Renvoie la convexit\u00e9 de la courbe repr\u00e9sentative du polyn\u00f4me sous la forme d'une cha\u00eene de caract\u00e8re en minuscule tangente(p,x) Renvoie l'\u00e9quation de la tangente \u00e0 la courbe du polyn\u00f4me p en x Dans l'interface de ce module, on consid\u00e8re que le calcul du discriminant est une op\u00e9ration priv\u00e9e. On aurait alors comme possibilit\u00e9 d'impl\u00e9mentation (non compl\u00e8te): from math import sqrt def polynome ( t ) : a , b , * c = t if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or len ( c ) > 1 or not ( isinstance ( * c ,( int , float ))) : raise ValueError () if a == 0 : raise ValueError () return t def _discriminant ( p ) : a , b , c = polynome ( p ) return b ** 2 - 4 * a * c def _nombreRacines ( p ) : ... def valeursracines ( p ) : ... def convexite ( p ) : ... def _calcule ( p , x ) : ... def _nombreDerive ( p , x ) : ... def tangente ( p , x ) : ... Dans ce module, les fonctions pr\u00e9fix\u00e9es par _ sont consid\u00e9r\u00e9es comme priv\u00e9es, et ne faisant pas partie de l'interface. Exercice Cr\u00e9er un module secondDegre.py contenant a minima la totalit\u00e9 des fonctions pr\u00e9c\u00e9dentes, et impl\u00e9menter toutes ces fonctions. Une solution possible from math import sqrt def polynome ( t ) : a , b , * c = t if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or len ( c ) > 1 or not ( isinstance ( * c ,( int , float ))) : raise ValueError () if a == 0 : raise ValueError () return t def _discriminant ( p ) : a , b , c = polynome ( p ) return b ** 2 - 4 * a * c def _nombreRacines ( p ) : d = _discriminant ( p ) if d < 0 : return 0 elif d == 0 : return 1 else : return 2 def valeursRacines ( p ) : nbR = _nombreRacines ( p ) if nbR == 0 : return None elif nbR == 1 : a , b , c = p return - b / ( 2 * a ) else : a , b , c = p d = _discriminant ( p ) return ( - b - sqrt ( d )) / ( 2 * a ), ( - b + sqrt ( d )) / ( 2 * a ) def convexite ( p ) : a , b , c = polynome ( p ) if a > 0 : return \"convexe\" else : return \"concave\" def _calcule ( p , x ) : a , b , c = polynome ( p ) if not ( isinstance ( x , ( float , int ))) : raise valueError () else : return a * x ** 2 + b * x + c def _nombreDerive ( p , x ) : a , b , c = polynome ( p ) if not ( isinstance ( x , ( float , int ))) : raise valueError () else : return 2 * a * x + b def tangente ( p , x ) : return f 'y = { _nombreDerive ( p , x ) } (x- { x } ) + { _calcule ( p , x ) } ' Encapsulation dans d'autres langages Il faut noter que la notion de fonction ou variable priv\u00e9e en Python n'est qu'une convention. Rien n'emp\u00eache r\u00e9ellement l'utilisateur du module d'utiliser ces fonctions priv\u00e9es . C'est loin d'\u00eatre le cas dans d'autres langages (comme C++ ou Java ), qui introduisent un contr\u00f4le strict de l'encapsulation en rendant l'acc\u00e8s aux \u00e9l\u00e9ments priv\u00e9s impossible.","title":"Modules, interfaces, encapsulation"},{"location":"NSI/Terminale/C01/Modularite/#modules-interfaces-et-encapsulation","text":"","title":"Modules, Interfaces et Encapsulation"},{"location":"NSI/Terminale/C01/Modularite/#retour-sur-les-modules","text":"Un module python est un fichier python contenant des fonctions, des constantes (et des constructeurs d' objets , mais nous verrons \u00e7a un peu plus tard), regroup\u00e9es dans ce fichier car elles traitent de la m\u00eame structure de donn\u00e9es . Un exemple Par exemple, dans un jeu vid\u00e9o tel que Space Invaders , on aura : un module qui traitera du vaisseau du joueur ; un module pour construire et g\u00e9rer les vaisseaux ennemis ; un ou des modules pour construire et actualiser l'interface graphique ; un module contenant des constantes (points de vie de d\u00e9part du joueur, nombre d'ennemis, etc) ; et le programme principal qui importera les modules pr\u00e9c\u00e9dents et g\u00e9rera les \u00e9v\u00e9nements liant tous les objets du jeu. On dira que ce programme d\u00e9pend des autres modules. Importer un module Il existe plusieurs possibilit\u00e9s pour importer un module. Dans la suite des exemples, le module toto , contenant les fonctions bidule() et truc() est situ\u00e9 : soit dans le m\u00eame dossier que le fichier qui l'importe ; soit dans un dossier accessible par le syst\u00e8me ( dossier faisant partie de la variable PATH de windows par exemple). Import complet import toto toto . bidule () toto . truc () Toutes les fonctions du module toto sont import\u00e9es, et elles le sont dans un namespace (= espace de nommage\") sp\u00e9cifique. Les fonctions sont alors appel\u00e9es en les pr\u00e9fixant** par le nom du module ( toto. ). Import complet avec alias import toto as to to . bidule () to . truc () Comme pour l'import complet, toutes les fonctions du module toto sont import\u00e9es, et elles le sont dans un namespace (= espace de nommage\") sp\u00e9cifique. Les fonctions sont alors appel\u00e9es en les pr\u00e9fixant par l'alias** du module ( to1. ). Import partiel dans le namespace courant from toto import bidule bidule () Ici, seul la fonction bidule() est import\u00e9e, mais elle l'est directement dans le namespace principal (= main ) du fichier effectuant l'import. La fonction truc() n'est pas appelable (elle n'existe pas pour l'interpr\u00e9teur). Import complet dans le namespace courant from toto import * bidule () truc () Toutes les fonctions sont appel\u00e9es directement dans le namespace principal (= main ) du fichier effectuant l'import. \u26a0\ufe0f C'est une pratique p\u00e9rilleuse ! Si une fonction du module porte le m\u00eame nom qu'une fonction du fichier appelant, celle import\u00e9e \u00e9crasera celle du fichiert courant, et \u00e7a peut-\u00eatre facheux... Voir l'exemple ci-dessous... Fichier principal from mon_module import * print ( \"Pain \" ) Fichier mon_module.py def print ( truc ) : print ( truc * 3 + \"Tarte Tatin\" * 2 ) Sortie attendue Probablement, ce qui est attendu par la sortie du fichier principal est juste la cha\u00eene de caract\u00e8res \"Pain \" . Mais la fonction built-in print() a \u00e9t\u00e9 \u00e9cras\u00e9e par celle du module mon_module.py . Sortie r\u00e9elle \"Pain Pain Pain Tarte Tatin Tarte Tatin\u00a8 La v\u00e9ritable fonction appel\u00e9e est celle du module mon_module.py . (Pour ceux qui ont en t\u00eate la marche imp\u00e9riale, c'est normal...) Remarque Il est toutefois possible d'importer un fichier pr\u00e9sent dans un autre dossier : soit en utilisant une adresse absolue import 'C:\\Mes_Programmes\\Python\\toto.py' ; soit en utilisant une adresse relatice import '..\\toto.py' ( si toto.py est situ\u00e9 dans le dossier parent du fichier qui importe).","title":"Retour sur les modules"},{"location":"NSI/Terminale/C01/Modularite/#interfaces","text":"Conception logicielle Dans la conception de logiciels \u00e0 grande \u00e9chelle, ou \u00e0 pluseiurs programmeurs (et \u00e0 l'heure actuelle il est fr\u00e9quent d'avoir plusieurs milliers de programmeurs concevant un logiciel), il est important de pouvoir s\u00e9parer les diff\u00e9rents \u00e9l\u00e9ments du programme en sous-ensembles coh\u00e9rents et ayant le minimum d'interactions entre eux. En particuliers ils se doivent d'\u00eatre le plus \u00e9tanches possibles quant \u00e0 leur fonctionnement. On retrouve ici que la notion d' interface est essentielle. Pour chaque module, on peut donc distinguer : une interface , c'est-\u00e0-dire la description des diff\u00e9rentes fonctions du module et de leurs arguments (obligatoires ou facultatifs). Il s'agit donc d'une documentation la plus claire possible sur la mani\u00e8re d' utiliser le module. une impl\u00e9mentation , c'est-\u00e0-dire la mani\u00e8re dont sont cod\u00e9es ces fonctions (choix de structures, nom des variables interm\u00e9diaires, etc...). Un exemple d'interface Un module utilisable pour la fonction factoris\u00e9e contient_doublon(t) aura pour interface : fonction Description cree() cr\u00e9e et renvoie un ensemble de date vide contient(data,s) renvoie True si la structure s contient la donn\u00e9e data ajoute(data,s) ajoute la donn\u00e9e data \u00e0 la structure s Vous constaterez que dans cette description, il n'est nul part fait mention de la nature de la structure . Il pourrait s'agir aussi bien de liste, de tableau de bits, de tables de hachage... Exercice : r\u00e9alisation de modules Dans chacun des cas suivant, construire un module r\u00e9alisant l'interface ci-dessus, et le tester en l'important dans le fichier rechercheDates.py o\u00f9 vous aurez modifier la fonction contient_doublon(t) par la version factoris\u00e9e de celle-ci. un module dateTab , dont la structure est impl\u00e9ment\u00e9e sous la forme d'un tableau. un module dateBool , dont la structure est impl\u00e9ment\u00e9e sous la forme d'un tableau de bool\u00e9en. un module dateHash , dont la structure est impl\u00e9ment\u00e9e sous la forme d'une table de hachage. \ud83e\udde9 Il est bien entendu essentiel de s'inspirer des exemples donn\u00e9 dans la page d'introduction .","title":"Interfaces"},{"location":"NSI/Terminale/C01/Modularite/#notions-dencapsulation","text":"Notion d'encapsulation Le contrat qu'une interface \u00e9tablit entre l'utilisateur et l'auteur d'un module ne porte pas sur les moyens, mais sur les r\u00e9sultats : l'auteur s'engage \u00e0 ce que les r\u00e9sultats produits par l'utilisation de ses fonctions soient bien ceux d\u00e9crits dans l'interface, mais il est libre de s'y prendre comme il le souhaite. En particulier il est libre d'introduire des fonctions, variables, constantes, ..., qui ne sont pas inclues dans l'interface . On parle alors de fonctions, variables, constantes encapsul\u00e9es dans le module. Le contrat explicite est que l'utilisateur ne doit en aucun cas utiliser ces donn\u00e9es encapsul\u00e9es. Dans le cas contraire, si l'auteur du module change son approche et modifie ces donn\u00e9es internes, le programme du client risque de devenir non fonctionnel. Norme en Python En Python, l'auteur d'un module peut indiquer que certains \u00e9l\u00e9ments sont priv\u00e9s (= encapsul\u00e9s) en faisant commencer leur nom par un cracat\u00e8re underscore _ Exemple Imaginons un module secondDegre.py dont l'interface est d\u00e9finie ainsi : fonction Description polynome(t) V\u00e9rifie que le tuple t sous la forme (a,b,c) repr\u00e9sente bien un polyn\u00f4me de degr\u00e9 2 valeursRacines(p) Renvoie les valeurs des racines, et None si il n'existe pas de recines r\u00e9elles convexite(p) Renvoie la convexit\u00e9 de la courbe repr\u00e9sentative du polyn\u00f4me sous la forme d'une cha\u00eene de caract\u00e8re en minuscule tangente(p,x) Renvoie l'\u00e9quation de la tangente \u00e0 la courbe du polyn\u00f4me p en x Dans l'interface de ce module, on consid\u00e8re que le calcul du discriminant est une op\u00e9ration priv\u00e9e. On aurait alors comme possibilit\u00e9 d'impl\u00e9mentation (non compl\u00e8te): from math import sqrt def polynome ( t ) : a , b , * c = t if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or len ( c ) > 1 or not ( isinstance ( * c ,( int , float ))) : raise ValueError () if a == 0 : raise ValueError () return t def _discriminant ( p ) : a , b , c = polynome ( p ) return b ** 2 - 4 * a * c def _nombreRacines ( p ) : ... def valeursracines ( p ) : ... def convexite ( p ) : ... def _calcule ( p , x ) : ... def _nombreDerive ( p , x ) : ... def tangente ( p , x ) : ... Dans ce module, les fonctions pr\u00e9fix\u00e9es par _ sont consid\u00e9r\u00e9es comme priv\u00e9es, et ne faisant pas partie de l'interface. Exercice Cr\u00e9er un module secondDegre.py contenant a minima la totalit\u00e9 des fonctions pr\u00e9c\u00e9dentes, et impl\u00e9menter toutes ces fonctions. Une solution possible from math import sqrt def polynome ( t ) : a , b , * c = t if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or len ( c ) > 1 or not ( isinstance ( * c ,( int , float ))) : raise ValueError () if a == 0 : raise ValueError () return t def _discriminant ( p ) : a , b , c = polynome ( p ) return b ** 2 - 4 * a * c def _nombreRacines ( p ) : d = _discriminant ( p ) if d < 0 : return 0 elif d == 0 : return 1 else : return 2 def valeursRacines ( p ) : nbR = _nombreRacines ( p ) if nbR == 0 : return None elif nbR == 1 : a , b , c = p return - b / ( 2 * a ) else : a , b , c = p d = _discriminant ( p ) return ( - b - sqrt ( d )) / ( 2 * a ), ( - b + sqrt ( d )) / ( 2 * a ) def convexite ( p ) : a , b , c = polynome ( p ) if a > 0 : return \"convexe\" else : return \"concave\" def _calcule ( p , x ) : a , b , c = polynome ( p ) if not ( isinstance ( x , ( float , int ))) : raise valueError () else : return a * x ** 2 + b * x + c def _nombreDerive ( p , x ) : a , b , c = polynome ( p ) if not ( isinstance ( x , ( float , int ))) : raise valueError () else : return 2 * a * x + b def tangente ( p , x ) : return f 'y = { _nombreDerive ( p , x ) } (x- { x } ) + { _calcule ( p , x ) } ' Encapsulation dans d'autres langages Il faut noter que la notion de fonction ou variable priv\u00e9e en Python n'est qu'une convention. Rien n'emp\u00eache r\u00e9ellement l'utilisateur du module d'utiliser ces fonctions priv\u00e9es . C'est loin d'\u00eatre le cas dans d'autres langages (comme C++ ou Java ), qui introduisent un contr\u00f4le strict de l'encapsulation en rendant l'acc\u00e8s aux \u00e9l\u00e9ments priv\u00e9s impossible.","title":"Notions d'encapsulation"}]}