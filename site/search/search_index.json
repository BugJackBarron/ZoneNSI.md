{"config":{"indexing":"full","lang":["fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nouvelle version Ceci est mon nouveau site. Il est prioritairement \u00e0 destination de mes \u00e9l\u00e8ves, mais vous pouvez m'envoyer vos commentaires par le lien situ\u00e9 en bas de page. L'ancien site peut-\u00eatre trouv\u00e9 ici .","title":"Home"},{"location":"#nouvelle-version","text":"Ceci est mon nouveau site. Il est prioritairement \u00e0 destination de mes \u00e9l\u00e8ves, mais vous pouvez m'envoyer vos commentaires par le lien situ\u00e9 en bas de page. L'ancien site peut-\u00eatre trouv\u00e9 ici .","title":"Nouvelle version"},{"location":"WorkInProgress/","text":"","title":"Manim"},{"location":"Maths/Seconde/home/","text":"Le programme Documents officiels Le programme de maths de seconde se trouve ici . Pr\u00e9vision de progression annuelle 2021-2022 Cette progression n'est valable que pour les \u00e9l\u00e8ves de seconde I du Lyc\u00e9e Pavie de Guingamp, et est sujette \u00e0 modifications au cours de l'ann\u00e9e... N\u00b0 Chapitre Dur\u00e9e Estim\u00e9e Dates pr\u00e9vues Dates effectives Remarques 1 Ensembles et intervalles 2 Notions de vecteurs 3 G\u00e9n\u00e9ralit\u00e9s sur les fonctions 4 Configuration du plan et orthogonalit\u00e9 5 Calcul litt\u00e9ral 6 Fonctions de r\u00e9f\u00e9rences 1 (affines et carr\u00e9s) 7 G\u00e9om\u00e9trie rep\u00e9r\u00e9e 8 Arithm\u00e9tique 9 Pourcentages 10 Fonctions de r\u00e9f\u00e9rences 2 11 Probabilit\u00e9s 12 Equations cart\u00e9siennes et syst\u00e8mes 13 Statistiques 14 Echantillonage A toutes ces notions, il faut rajouter les bases d'algorithmique et de programmation en Python : Types de variables ; Affectations de variables ; Structures conditionnelles : Boucles born\u00e9es et non-born\u00e9es. Epreuves communes Deux \u00e9preuves communes sont pr\u00e9vues pour l'ann\u00e9e 2021-2022 : la premi\u00e8re juste avant les vacances de la toussaint, sur les chapitres 1 \u00e0 3 La deuxi\u00e8me avant les vacances de f\u00e9vrier, sur les chapitres 1 \u00e0 7.","title":"Pr\u00e9sentation"},{"location":"Maths/Seconde/home/#le-programme","text":"","title":"Le programme"},{"location":"Maths/Seconde/home/#documents-officiels","text":"Le programme de maths de seconde se trouve ici .","title":"Documents officiels"},{"location":"Maths/Seconde/home/#prevision-de-progression-annuelle-2021-2022","text":"Cette progression n'est valable que pour les \u00e9l\u00e8ves de seconde I du Lyc\u00e9e Pavie de Guingamp, et est sujette \u00e0 modifications au cours de l'ann\u00e9e... N\u00b0 Chapitre Dur\u00e9e Estim\u00e9e Dates pr\u00e9vues Dates effectives Remarques 1 Ensembles et intervalles 2 Notions de vecteurs 3 G\u00e9n\u00e9ralit\u00e9s sur les fonctions 4 Configuration du plan et orthogonalit\u00e9 5 Calcul litt\u00e9ral 6 Fonctions de r\u00e9f\u00e9rences 1 (affines et carr\u00e9s) 7 G\u00e9om\u00e9trie rep\u00e9r\u00e9e 8 Arithm\u00e9tique 9 Pourcentages 10 Fonctions de r\u00e9f\u00e9rences 2 11 Probabilit\u00e9s 12 Equations cart\u00e9siennes et syst\u00e8mes 13 Statistiques 14 Echantillonage A toutes ces notions, il faut rajouter les bases d'algorithmique et de programmation en Python : Types de variables ; Affectations de variables ; Structures conditionnelles : Boucles born\u00e9es et non-born\u00e9es.","title":"Pr\u00e9vision de progression annuelle 2021-2022"},{"location":"Maths/Seconde/home/#epreuves-communes","text":"Deux \u00e9preuves communes sont pr\u00e9vues pour l'ann\u00e9e 2021-2022 : la premi\u00e8re juste avant les vacances de la toussaint, sur les chapitres 1 \u00e0 3 La deuxi\u00e8me avant les vacances de f\u00e9vrier, sur les chapitres 1 \u00e0 7.","title":"Epreuves communes"},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/","text":"C01-01 : Ensembles de Nombres La version pdf de ce cours est t\u00e9l\u00e9chargeable ici . (version 2021-2022) Activit\u00e9 : Classer des nombres Dans la liste ci-dessus, deux \u00e9critures sont interdites. Lesquelles et pourquoi ? Classer les nombres restants en cinq groupes , en justifiant vos choix. Diff\u00e9rence entres propri\u00e9t\u00e9s et \u00e9critures Un nombre peut \u00eatre \u00e9crit de diff\u00e9rentes mani\u00e8res, plus ou moins compliqu\u00e9es. Par exemple : \\[ 2 = \\cfrac{6}{3} = 20 \\times 10^{-1} = \\sqrt{4}= - \\left(-2\\right) = 2,0000 \\] Pour autant, ce qui nous int\u00e9resse en math\u00e9matiques c'est d'\u00e9tudier les propri\u00e9t\u00e9s de ce nombre, qui elles sont ind\u00e9pendantes de l'\u00e9criture de ce nombre. Nombres entiers naturels et relatifs D\u00e9finitions L'ensemble des entiers naturels , not\u00e9 \\(\\mathbb{N}\\) , est l'ensemble des nombres permettant de d\u00e9nombrer une collection d'objets, de personnes, etc, c'est-\u00e0-dire la suite naturelle \\(0~;~1~;~2~;~3~;~...\\) L'ensemble des entiers relatifs , not\u00e9 \\(\\mathbb{Z}\\) , est l'ensemble des entiers naturels et leurs oppos\u00e9s , c'est-\u00e0-dire la suite \\(...~;~-3~;~-2~;~-1~;~0~;~1~;~2~;~3~;~...\\) Info L'ensemble \\(\\mathbb{N}\\) poss\u00e8de un plus petit \u00e9l\u00e9ment, c'est \\(0\\) . Les nombres entiers naturels sont tous positifs ou nuls . Tous les entiers naturels sont aussi des entiers relatifs . Vocabulaire et notations Appartenance : On dit que \\(5\\) appartient \u00e0 \\(\\mathbb{N}\\) , et on note \\(5 \\in \\mathbb{N}\\) . De m\u00eame \\(-2\\) n'appartient pas \u00e0 \\(\\mathbb{N}\\) , et on note \\(-12 \\notin \\mathbb{N}\\) . Inclusion : Tous les \u00e9l\u00e9ments de \\(\\mathbb{N}\\) sont aussi des \u00e9l\u00e9ments de \\(\\mathbb{Z}\\) . On dit alors que \\(\\mathbb{N}\\) est un sous-ensemble de \\(\\mathbb{Z}\\) et on note alors \\(\\mathbb{N} \\subset \\mathbb{Z}\\) (qui se lit \\(\\mathbb{N}\\) est inclus dans \\(\\mathbb{Z}\\) ). Application : choix du bon symbole Exercice Compl\u00e9ter avec \\(\\in\\) ou \\(\\notin\\) : \\(7 \\dots \\mathbb{N}\\) \\(-3 \\dots \\mathbb{N}\\) \\(-5 \\dots \\mathbb{Z}\\) \\(7 \\dots \\mathbb{Z}\\) \\(\\dfrac{1}{3} \\dots \\mathbb{N}\\) \\(\\sqrt{9} \\dots \\mathbb{N}\\) \\(-\\sqrt{25} \\dots \\mathbb{N}\\) \\(-\\sqrt{2} \\dots \\mathbb{Z}\\) \\(5 \\times 10^{3} \\dots \\mathbb{N}\\) \\(5 \\times 10 ^{-3} \\dots \\mathbb{Z}\\) \\(-4,2 \\dots \\mathbb{Z}\\) \\(3 \\times (1 - \\dfrac{1}{3}) \\dots \\mathbb{N}\\) Solution Compl\u00e9ter avec \\(\\in\\) ou \\(\\notin\\) : \\(7 \\in \\mathbb{N}\\) \\(-3 \\notin \\mathbb{N}\\) \\(-5 \\in \\mathbb{Z}\\) \\(7 \\in \\mathbb{Z}\\) \\(\\dfrac{1}{3} \\notin \\mathbb{N}\\) \\(\\sqrt{9} \\in \\mathbb{N}\\) car \\(\\sqrt{9} = 3\\) \\(-\\sqrt{25} \\notin \\mathbb{N}\\) car \\(-\\sqrt{25} = -5\\) \\(-\\sqrt{2} \\notin \\mathbb{Z}\\) car \\(-\\sqrt{2} \\simeq -1,414...\\) \\(5 \\times 10^{3} \\in \\mathbb{N}\\) car \\(5 \\times 10^3 = 5 \\times 1000 = 5000\\) \\(5 \\times 10 ^{-3} \\notin \\mathbb{Z}\\) car \\(5 \\times 10 ^{-3} = 5 \\times 0,001 = 0,005\\) \\(-4,2 \\notin \\mathbb{Z}\\) \\(3 \\times (1 - \\dfrac{1}{3}) \\in \\mathbb{N}\\) car \\(3 \\times (1 - \\dfrac{1}{3}) = 3 - 1 = 2\\) (en d\u00e9veloppant) ou \\(3 \\times (1 - \\dfrac{1}{3}) = 3 \\times \\dfrac{2}{3} = 2\\) (en calculant entre parenth\u00e8ses). Nombres d\u00e9cimaux d\u00e9finition : Nombres d\u00e9cimaux Un nombre d\u00e9cimal est un nombre pouvant s'\u00e9crire sous la forme d'une fraction d\u00e9cimale , c'est \u00e0 dire sous la forme $$ \\dfrac{a}{10^n} $$ avec \\(a\\in \\mathbb{Z}\\) et \\(n\\in \\mathbb{N}\\) . L'ensemble des d\u00e9cimaux est not\u00e9 \\(\\mathbb{D}\\) . Application : Nombres d\u00e9cimaux et puissances de 10 Exercice Pour chacun des nombres suivants, d\u00e9terminer si possible une \u00e9criture de la forme \\(\\dfrac{k}{10^n}\\) . \\(4,37\\) \\(0,002\\) \\(-12\\) \\(\\dfrac{1}{3}\\) \\(\\dfrac{2}{5}\\) \\(\\sqrt{0,16}\\) \\(10^3\\) \\(10^{-5}\\) \\(-10^5\\) \\(\\dfrac{3.10^5}{10^7}\\) \\(\\dfrac{10^7}{3.10^5}\\) Solution Pour chacun des nombres suivants, d\u00e9terminer si possible une \u00e9criture de la forme \\(\\dfrac{k}{10^n}\\) . \\(4,37 = \\dfrac{437}{100} = \\dfrac{437}{10^{2}}\\) \\(0,002 = \\dfrac{2}{1~000} = \\dfrac{2}{10^{3}}\\) \\(-12 = \\dfrac{-12}{1} = \\dfrac{-12}{10^{0}}\\) ( car \\(a^0 =1\\) pour tout nombre \\(a \\neq 0\\) ). \\(\\dfrac{1}{3} \\notin \\mathbb{D}\\) car \\(\\dfrac{1}{3} \\simeq 0,333...\\) (La d\u00e9monstration r\u00e9elle sera donn\u00e9e plus tard dans l'ann\u00e9e) \\(\\dfrac{2}{5} = \\dfrac{4}{10} = \\dfrac{4}{10^1}\\) \\(\\sqrt{0,16} = 0,4 = \\dfrac{4}{10} = \\dfrac{4}{10^1}\\) \\(10^3 = \\dfrac{1~000}{1} = \\dfrac{1~000}{10^{0}}\\) \\(10^{-5} = \\dfrac{1}{10^5}\\) (par d\u00e9finition des exposants n\u00e9gatifs \\(a^{-n} = \\dfrac{1}{a^n}\\) pour tout \\(n \\in \\mathbb{Z}\\) si \\(a \\neq 0\\) ) \\(-10^5 = - 100~000 = \\dfrac{- 100~000}{1} = \\dfrac{- 100~000}{10^{0}}\\) $ \\(\\dfrac{3.10^5}{10^7} = \\dfrac{3}{10^2}\\) par division des puissances ( \\(\\dfrac{a^m}{a^n} = a^{m-n}\\) pour tout \\(m,n \\in \\Z\\) ) \\(\\dfrac{10^7}{3.10^5} = \\dfrac{10^2}{3} \\simeq 33,333.... \\notin \\mathbb{D}\\) Remarques Les entiers relatifs sont des d\u00e9cimaux, car si \\(k \\in \\mathbb{Z}\\) , on peut aussi \u00e9crire \\(k=\\dfrac{k}{1}=\\dfrac{k}{10^0}\\) . On a donc la propri\u00e9t\u00e9 \\(\\mathbb{Z} \\subset \\mathbb{D}\\) . Un nombre d\u00e9cimal poss\u00e8de une \u00e9criture d\u00e9cimale finie . Nombres rationnels D\u00e9finition : Nombres rationnels Un nombre rationnel est un nombre pouvant s'\u00e9crire sous la forme \\(\\dfrac{a}{b}\\) avec \\(a\\in \\mathbb{Z}\\) et \\(b\\in \\mathbb{N}^{*}\\) (c'est-\u00e0-dire \\(\\mathbb{N}\\) priv\u00e9 de \\(0\\) ). L'ensemble des nombres rationnels est not\u00e9 \\(\\mathbb{Q}\\) . Remarque Un nombre d\u00e9cimal est par d\u00e9finition un nombre rationnel. Par d\u00e9finition de \\(\\mathbb{D}\\) et \\(\\mathbb{Q}\\) , on a la propri\u00e9t\u00e9 \\(\\mathbb{D} \\subset \\mathbb{Q}\\) . Propri\u00e9t\u00e9 : Caract\u00e9risation des rationnels non d\u00e9cimaux Tous les nombres rationnels ne poss\u00e8dent pas d'\u00e9criture d\u00e9cimale finie. En particulier, \\(\\dfrac{1}{3}\\) n'est pas d\u00e9cimal. Preuve La d\u00e9monstration de cette propri\u00e9t\u00e9 sera faite plus tard dans l'ann\u00e9e, dans le chapitre arithm\u00e9tique. Remarques Les nombres rationnels non d\u00e9cimaux poss\u00e8dent une \u00e9criture d\u00e9cimale infinie p\u00e9riodique , c'est-\u00e0-dire avec une s\u00e9rie de chiffres qui se r\u00e9p\u00e8tent \u00e0 l'infini. Par exemple \\(\\dfrac{1}{7} = 0,14285714285714...\\) (on constate la r\u00e9p\u00e9tition de la s\u00e9quence 142857}). R\u00e9ciproquement, si un nombre poss\u00e8de une \u00e9criture d\u00e9cimale infinie p\u00e9riodique, alors c'est un rationnel. M\u00e9thode : D\u00e9terminer une fraction \u00e9gale \u00e0 une \u00e9criture d\u00e9cimale infinie p\u00e9riodique On consid\u00e8re le nombre \\(a\\) dont l'\u00e9criture d\u00e9cimale est infinie p\u00e9riodique \\(a = 2,71347134...\\) . D\u00e9montrons que ce nombre est rationnel. Solution On constate que la partie r\u00e9p\u00e9titive des chiffres de \\(a\\) est \\(7134\\) , donc de taille 4. Donc \\(10^4 \\times a = 10~000\\times a = 27134,71347134...\\) . D'o\u00f9 \\(10~000\\times a - a = 27134,71347134... - 2,71347134... = 27134 -2 = 27~132\\) . Or \\(10~000\\times a - a = 9~999\\times a\\) . D'apr\u00e8s les deux lignes pr\u00e9c\u00e9dentes, on a alors \\(9~999\\times a = 27132\\) soit \\(a = \\dfrac{27~132}{9~999} = \\dfrac{9~044}{3~333}\\) . Donc \\(a\\) est bien un nombre rationnel puisqu'il s'\u00e9crit sous la forme d'une fraction. Application : Calculs avec les rationnels Exercice Dans chacun des cas suivants, calculer \u00e0 la main chacune des expressions suivantes : \\(A = \\dfrac {5}{7} - \\dfrac{3}{11}\\) \\(B = -\\dfrac {4}{3} + \\dfrac{7}{8}\\) \\(C = \\dfrac {3}{8} - \\dfrac{5}{12}\\) \\(D = \\dfrac {-6}{7} \\times \\dfrac{8}{9}\\) \\(E = \\dfrac {3}{2} \\times \\left(-\\dfrac{7}{3}\\right)\\) \\(F = \\dfrac {48}{35} \\times \\dfrac{25}{64}\\) \\(G = \\dfrac {4}{7} \\div \\dfrac{8}{21}\\) \\(H = \\dfrac{~~\\dfrac{3}{4}~~}{\\dfrac{18}{20}}\\) \\(I = \\dfrac{~~7~~}{\\dfrac{5}{3}}\\) \\(J = \\dfrac{~~\\dfrac{7}{5}~~}{3}\\) Solution \\(A = \\dfrac {5}{7} - \\dfrac{3}{11} = \\dfrac {5\\times 11}{7\\times 11} - \\dfrac{3\\times 7}{11\\times 7} = \\dfrac {55}{77} - \\dfrac{21}{77} = \\dfrac{34}{77}\\) \\(B = -\\dfrac {4}{3} + \\dfrac{7}{8} = -\\dfrac {4 \\times 8}{3 \\times 8} + \\dfrac{7 \\times 3}{8 \\times 3} = -\\dfrac {32}{24} + \\dfrac{21}{24} -\\dfrac {11}{24}\\) \\(C = \\dfrac {3}{8} - \\dfrac{5}{12} = \\dfrac {3\\times 3}{8\\times 3} - \\dfrac{5 \\times 2}{12 \\times 2} = \\dfrac {9}{24} - \\dfrac{10}{24} = - \\dfrac{1}{24}\\) \\(D = \\dfrac {-6}{7} \\times \\dfrac{8}{9} = \\dfrac{-6 \\times 8}{7 \\times 9} = \\dfrac{-2 \\times 3 \\times 8}{7 \\times 3 \\times 3} = -\\dfrac{16}{21}\\) N'oubliez pas de simplifier ! \\(E = \\dfrac {3}{2} \\times \\left(-\\dfrac{7}{3}\\right) = -\\dfrac {3 \\times 7}{2 \\times3} = - \\dfrac{7}{2}\\) \\(F = \\dfrac {48}{35} \\times \\dfrac{25}{64} = \\dfrac{48 \\times 25}{35 \\times 64} = \\dfrac{2 \\times 3 \\times 8 \\times 5 \\times 5}{5\\times 7 \\times 2 \\times 4 \\times 8} = \\dfrac{15}{28}\\) \\(G = \\dfrac {4}{7} \\div \\dfrac{8}{21} = \\dfrac {4}{7} \\times \\dfrac{21}{8} = \\dfrac{4 \\times 21}{7 \\times 8} = \\dfrac{ 4 \\times 3 \\times 7}{7 \\times 2 \\times 4} = \\dfrac{3}{2}\\) \\(H = \\dfrac{~~\\dfrac{3}{4}~~}{\\dfrac{18}{20}} = \\dfrac{3}{4}\\div\\dfrac{18}{20} = \\dfrac{3}{4}\\div\\dfrac{20}{18} = \\dfrac{3 \\times 4 \\times 5}{ 4 \\times 3 \\times 6} = \\dfrac{5}{6}\\) . \\(I = \\dfrac{~~7~~}{\\dfrac{5}{3}} = 7 \\div \\dfrac{5}{3} = 7 \\times \\dfrac{3}{5} = \\dfrac{21}{5}\\) \\(J = \\dfrac{~~\\dfrac{7}{5}~~}{3} = \\dfrac{7}{5} \\div 3 = \\dfrac{7}{5} \\times \\dfrac{1}{3} = \\dfrac{7}{15}\\) Nombres r\u00e9els D\u00e9finition : Nombres r\u00e9els Un {==nombre r\u00e9el est un nombre exprimant une longueur, ou l'oppos\u00e9 d'un nombre exprimant une longueur. L'ensemble des nombres rationnels est not\u00e9 \\(\\mathbb{R}\\) . Remarques Un nombre r\u00e9el est un nombre dont le carr\u00e9 est positif ou nul . Par d\u00e9finition, tous les nombres rationnels sont des r\u00e9els. On a alors \\(\\mathbb{Q} \\subset \\mathbb{R}\\) . Certains nombres r\u00e9els ne sont pas rationnels. Par exemple \\(\\pi\\) n'est pas rationnel, tout comme \\(\\sqrt{2}\\) ( on le montrera en exercice ). Ces nombres sont dits irrationnels . Propri\u00e9t\u00e9 : Ensembles de nombres Des remarques pr\u00e9c\u00e9dentes, on \u00e0 la propri\u00e9t\u00e9 : \\[ \\mathbb{N} \\subset \\mathbb{Z} \\subset \\mathbb{D} \\subset \\mathbb{Q} \\subset \\mathbb{R} \\] Propri\u00e9t\u00e9 : Droite des r\u00e9els Tout nombre r\u00e9el est repr\u00e9sent\u00e9 par l'abscisse d'un point sur la droite num\u00e9rique ( appel\u00e9e aussi droite des r\u00e9els ). Application : Repr\u00e9senter sur la droite des r\u00e9els D\u00e9terminer l'abscisse de chacun des points de la droite ci-dessous : Repr\u00e9senter la droite des r\u00e9els ( unit\u00e9 : 5 ) et y placer le plus pr\u00e9cis\u00e9ment possible les nombres suivants : \\[ 3 ~;~ -0,75 ~;~ \\dfrac{5}{4} ~;~\\dfrac{-2}{5} ~;~ \\dfrac{7}{3} ~;~ \\sqrt{2} \\]","title":"Ensembles de nombres "},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/#c01-01-ensembles-de-nombres","text":"La version pdf de ce cours est t\u00e9l\u00e9chargeable ici . (version 2021-2022)","title":"C01-01 : Ensembles de Nombres"},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/#activite-classer-des-nombres","text":"Dans la liste ci-dessus, deux \u00e9critures sont interdites. Lesquelles et pourquoi ? Classer les nombres restants en cinq groupes , en justifiant vos choix. Diff\u00e9rence entres propri\u00e9t\u00e9s et \u00e9critures Un nombre peut \u00eatre \u00e9crit de diff\u00e9rentes mani\u00e8res, plus ou moins compliqu\u00e9es. Par exemple : \\[ 2 = \\cfrac{6}{3} = 20 \\times 10^{-1} = \\sqrt{4}= - \\left(-2\\right) = 2,0000 \\] Pour autant, ce qui nous int\u00e9resse en math\u00e9matiques c'est d'\u00e9tudier les propri\u00e9t\u00e9s de ce nombre, qui elles sont ind\u00e9pendantes de l'\u00e9criture de ce nombre.","title":"Activit\u00e9 : Classer des nombres"},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/#nombres-entiers-naturels-et-relatifs","text":"D\u00e9finitions L'ensemble des entiers naturels , not\u00e9 \\(\\mathbb{N}\\) , est l'ensemble des nombres permettant de d\u00e9nombrer une collection d'objets, de personnes, etc, c'est-\u00e0-dire la suite naturelle \\(0~;~1~;~2~;~3~;~...\\) L'ensemble des entiers relatifs , not\u00e9 \\(\\mathbb{Z}\\) , est l'ensemble des entiers naturels et leurs oppos\u00e9s , c'est-\u00e0-dire la suite \\(...~;~-3~;~-2~;~-1~;~0~;~1~;~2~;~3~;~...\\) Info L'ensemble \\(\\mathbb{N}\\) poss\u00e8de un plus petit \u00e9l\u00e9ment, c'est \\(0\\) . Les nombres entiers naturels sont tous positifs ou nuls . Tous les entiers naturels sont aussi des entiers relatifs . Vocabulaire et notations Appartenance : On dit que \\(5\\) appartient \u00e0 \\(\\mathbb{N}\\) , et on note \\(5 \\in \\mathbb{N}\\) . De m\u00eame \\(-2\\) n'appartient pas \u00e0 \\(\\mathbb{N}\\) , et on note \\(-12 \\notin \\mathbb{N}\\) . Inclusion : Tous les \u00e9l\u00e9ments de \\(\\mathbb{N}\\) sont aussi des \u00e9l\u00e9ments de \\(\\mathbb{Z}\\) . On dit alors que \\(\\mathbb{N}\\) est un sous-ensemble de \\(\\mathbb{Z}\\) et on note alors \\(\\mathbb{N} \\subset \\mathbb{Z}\\) (qui se lit \\(\\mathbb{N}\\) est inclus dans \\(\\mathbb{Z}\\) ). Application : choix du bon symbole Exercice Compl\u00e9ter avec \\(\\in\\) ou \\(\\notin\\) : \\(7 \\dots \\mathbb{N}\\) \\(-3 \\dots \\mathbb{N}\\) \\(-5 \\dots \\mathbb{Z}\\) \\(7 \\dots \\mathbb{Z}\\) \\(\\dfrac{1}{3} \\dots \\mathbb{N}\\) \\(\\sqrt{9} \\dots \\mathbb{N}\\) \\(-\\sqrt{25} \\dots \\mathbb{N}\\) \\(-\\sqrt{2} \\dots \\mathbb{Z}\\) \\(5 \\times 10^{3} \\dots \\mathbb{N}\\) \\(5 \\times 10 ^{-3} \\dots \\mathbb{Z}\\) \\(-4,2 \\dots \\mathbb{Z}\\) \\(3 \\times (1 - \\dfrac{1}{3}) \\dots \\mathbb{N}\\) Solution Compl\u00e9ter avec \\(\\in\\) ou \\(\\notin\\) : \\(7 \\in \\mathbb{N}\\) \\(-3 \\notin \\mathbb{N}\\) \\(-5 \\in \\mathbb{Z}\\) \\(7 \\in \\mathbb{Z}\\) \\(\\dfrac{1}{3} \\notin \\mathbb{N}\\) \\(\\sqrt{9} \\in \\mathbb{N}\\) car \\(\\sqrt{9} = 3\\) \\(-\\sqrt{25} \\notin \\mathbb{N}\\) car \\(-\\sqrt{25} = -5\\) \\(-\\sqrt{2} \\notin \\mathbb{Z}\\) car \\(-\\sqrt{2} \\simeq -1,414...\\) \\(5 \\times 10^{3} \\in \\mathbb{N}\\) car \\(5 \\times 10^3 = 5 \\times 1000 = 5000\\) \\(5 \\times 10 ^{-3} \\notin \\mathbb{Z}\\) car \\(5 \\times 10 ^{-3} = 5 \\times 0,001 = 0,005\\) \\(-4,2 \\notin \\mathbb{Z}\\) \\(3 \\times (1 - \\dfrac{1}{3}) \\in \\mathbb{N}\\) car \\(3 \\times (1 - \\dfrac{1}{3}) = 3 - 1 = 2\\) (en d\u00e9veloppant) ou \\(3 \\times (1 - \\dfrac{1}{3}) = 3 \\times \\dfrac{2}{3} = 2\\) (en calculant entre parenth\u00e8ses).","title":"Nombres entiers naturels et relatifs"},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/#nombres-decimaux","text":"d\u00e9finition : Nombres d\u00e9cimaux Un nombre d\u00e9cimal est un nombre pouvant s'\u00e9crire sous la forme d'une fraction d\u00e9cimale , c'est \u00e0 dire sous la forme $$ \\dfrac{a}{10^n} $$ avec \\(a\\in \\mathbb{Z}\\) et \\(n\\in \\mathbb{N}\\) . L'ensemble des d\u00e9cimaux est not\u00e9 \\(\\mathbb{D}\\) . Application : Nombres d\u00e9cimaux et puissances de 10 Exercice Pour chacun des nombres suivants, d\u00e9terminer si possible une \u00e9criture de la forme \\(\\dfrac{k}{10^n}\\) . \\(4,37\\) \\(0,002\\) \\(-12\\) \\(\\dfrac{1}{3}\\) \\(\\dfrac{2}{5}\\) \\(\\sqrt{0,16}\\) \\(10^3\\) \\(10^{-5}\\) \\(-10^5\\) \\(\\dfrac{3.10^5}{10^7}\\) \\(\\dfrac{10^7}{3.10^5}\\) Solution Pour chacun des nombres suivants, d\u00e9terminer si possible une \u00e9criture de la forme \\(\\dfrac{k}{10^n}\\) . \\(4,37 = \\dfrac{437}{100} = \\dfrac{437}{10^{2}}\\) \\(0,002 = \\dfrac{2}{1~000} = \\dfrac{2}{10^{3}}\\) \\(-12 = \\dfrac{-12}{1} = \\dfrac{-12}{10^{0}}\\) ( car \\(a^0 =1\\) pour tout nombre \\(a \\neq 0\\) ). \\(\\dfrac{1}{3} \\notin \\mathbb{D}\\) car \\(\\dfrac{1}{3} \\simeq 0,333...\\) (La d\u00e9monstration r\u00e9elle sera donn\u00e9e plus tard dans l'ann\u00e9e) \\(\\dfrac{2}{5} = \\dfrac{4}{10} = \\dfrac{4}{10^1}\\) \\(\\sqrt{0,16} = 0,4 = \\dfrac{4}{10} = \\dfrac{4}{10^1}\\) \\(10^3 = \\dfrac{1~000}{1} = \\dfrac{1~000}{10^{0}}\\) \\(10^{-5} = \\dfrac{1}{10^5}\\) (par d\u00e9finition des exposants n\u00e9gatifs \\(a^{-n} = \\dfrac{1}{a^n}\\) pour tout \\(n \\in \\mathbb{Z}\\) si \\(a \\neq 0\\) ) \\(-10^5 = - 100~000 = \\dfrac{- 100~000}{1} = \\dfrac{- 100~000}{10^{0}}\\) $ \\(\\dfrac{3.10^5}{10^7} = \\dfrac{3}{10^2}\\) par division des puissances ( \\(\\dfrac{a^m}{a^n} = a^{m-n}\\) pour tout \\(m,n \\in \\Z\\) ) \\(\\dfrac{10^7}{3.10^5} = \\dfrac{10^2}{3} \\simeq 33,333.... \\notin \\mathbb{D}\\) Remarques Les entiers relatifs sont des d\u00e9cimaux, car si \\(k \\in \\mathbb{Z}\\) , on peut aussi \u00e9crire \\(k=\\dfrac{k}{1}=\\dfrac{k}{10^0}\\) . On a donc la propri\u00e9t\u00e9 \\(\\mathbb{Z} \\subset \\mathbb{D}\\) . Un nombre d\u00e9cimal poss\u00e8de une \u00e9criture d\u00e9cimale finie .","title":"Nombres d\u00e9cimaux"},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/#nombres-rationnels","text":"D\u00e9finition : Nombres rationnels Un nombre rationnel est un nombre pouvant s'\u00e9crire sous la forme \\(\\dfrac{a}{b}\\) avec \\(a\\in \\mathbb{Z}\\) et \\(b\\in \\mathbb{N}^{*}\\) (c'est-\u00e0-dire \\(\\mathbb{N}\\) priv\u00e9 de \\(0\\) ). L'ensemble des nombres rationnels est not\u00e9 \\(\\mathbb{Q}\\) . Remarque Un nombre d\u00e9cimal est par d\u00e9finition un nombre rationnel. Par d\u00e9finition de \\(\\mathbb{D}\\) et \\(\\mathbb{Q}\\) , on a la propri\u00e9t\u00e9 \\(\\mathbb{D} \\subset \\mathbb{Q}\\) . Propri\u00e9t\u00e9 : Caract\u00e9risation des rationnels non d\u00e9cimaux Tous les nombres rationnels ne poss\u00e8dent pas d'\u00e9criture d\u00e9cimale finie. En particulier, \\(\\dfrac{1}{3}\\) n'est pas d\u00e9cimal. Preuve La d\u00e9monstration de cette propri\u00e9t\u00e9 sera faite plus tard dans l'ann\u00e9e, dans le chapitre arithm\u00e9tique. Remarques Les nombres rationnels non d\u00e9cimaux poss\u00e8dent une \u00e9criture d\u00e9cimale infinie p\u00e9riodique , c'est-\u00e0-dire avec une s\u00e9rie de chiffres qui se r\u00e9p\u00e8tent \u00e0 l'infini. Par exemple \\(\\dfrac{1}{7} = 0,14285714285714...\\) (on constate la r\u00e9p\u00e9tition de la s\u00e9quence 142857}). R\u00e9ciproquement, si un nombre poss\u00e8de une \u00e9criture d\u00e9cimale infinie p\u00e9riodique, alors c'est un rationnel. M\u00e9thode : D\u00e9terminer une fraction \u00e9gale \u00e0 une \u00e9criture d\u00e9cimale infinie p\u00e9riodique On consid\u00e8re le nombre \\(a\\) dont l'\u00e9criture d\u00e9cimale est infinie p\u00e9riodique \\(a = 2,71347134...\\) . D\u00e9montrons que ce nombre est rationnel. Solution On constate que la partie r\u00e9p\u00e9titive des chiffres de \\(a\\) est \\(7134\\) , donc de taille 4. Donc \\(10^4 \\times a = 10~000\\times a = 27134,71347134...\\) . D'o\u00f9 \\(10~000\\times a - a = 27134,71347134... - 2,71347134... = 27134 -2 = 27~132\\) . Or \\(10~000\\times a - a = 9~999\\times a\\) . D'apr\u00e8s les deux lignes pr\u00e9c\u00e9dentes, on a alors \\(9~999\\times a = 27132\\) soit \\(a = \\dfrac{27~132}{9~999} = \\dfrac{9~044}{3~333}\\) . Donc \\(a\\) est bien un nombre rationnel puisqu'il s'\u00e9crit sous la forme d'une fraction. Application : Calculs avec les rationnels Exercice Dans chacun des cas suivants, calculer \u00e0 la main chacune des expressions suivantes : \\(A = \\dfrac {5}{7} - \\dfrac{3}{11}\\) \\(B = -\\dfrac {4}{3} + \\dfrac{7}{8}\\) \\(C = \\dfrac {3}{8} - \\dfrac{5}{12}\\) \\(D = \\dfrac {-6}{7} \\times \\dfrac{8}{9}\\) \\(E = \\dfrac {3}{2} \\times \\left(-\\dfrac{7}{3}\\right)\\) \\(F = \\dfrac {48}{35} \\times \\dfrac{25}{64}\\) \\(G = \\dfrac {4}{7} \\div \\dfrac{8}{21}\\) \\(H = \\dfrac{~~\\dfrac{3}{4}~~}{\\dfrac{18}{20}}\\) \\(I = \\dfrac{~~7~~}{\\dfrac{5}{3}}\\) \\(J = \\dfrac{~~\\dfrac{7}{5}~~}{3}\\) Solution \\(A = \\dfrac {5}{7} - \\dfrac{3}{11} = \\dfrac {5\\times 11}{7\\times 11} - \\dfrac{3\\times 7}{11\\times 7} = \\dfrac {55}{77} - \\dfrac{21}{77} = \\dfrac{34}{77}\\) \\(B = -\\dfrac {4}{3} + \\dfrac{7}{8} = -\\dfrac {4 \\times 8}{3 \\times 8} + \\dfrac{7 \\times 3}{8 \\times 3} = -\\dfrac {32}{24} + \\dfrac{21}{24} -\\dfrac {11}{24}\\) \\(C = \\dfrac {3}{8} - \\dfrac{5}{12} = \\dfrac {3\\times 3}{8\\times 3} - \\dfrac{5 \\times 2}{12 \\times 2} = \\dfrac {9}{24} - \\dfrac{10}{24} = - \\dfrac{1}{24}\\) \\(D = \\dfrac {-6}{7} \\times \\dfrac{8}{9} = \\dfrac{-6 \\times 8}{7 \\times 9} = \\dfrac{-2 \\times 3 \\times 8}{7 \\times 3 \\times 3} = -\\dfrac{16}{21}\\) N'oubliez pas de simplifier ! \\(E = \\dfrac {3}{2} \\times \\left(-\\dfrac{7}{3}\\right) = -\\dfrac {3 \\times 7}{2 \\times3} = - \\dfrac{7}{2}\\) \\(F = \\dfrac {48}{35} \\times \\dfrac{25}{64} = \\dfrac{48 \\times 25}{35 \\times 64} = \\dfrac{2 \\times 3 \\times 8 \\times 5 \\times 5}{5\\times 7 \\times 2 \\times 4 \\times 8} = \\dfrac{15}{28}\\) \\(G = \\dfrac {4}{7} \\div \\dfrac{8}{21} = \\dfrac {4}{7} \\times \\dfrac{21}{8} = \\dfrac{4 \\times 21}{7 \\times 8} = \\dfrac{ 4 \\times 3 \\times 7}{7 \\times 2 \\times 4} = \\dfrac{3}{2}\\) \\(H = \\dfrac{~~\\dfrac{3}{4}~~}{\\dfrac{18}{20}} = \\dfrac{3}{4}\\div\\dfrac{18}{20} = \\dfrac{3}{4}\\div\\dfrac{20}{18} = \\dfrac{3 \\times 4 \\times 5}{ 4 \\times 3 \\times 6} = \\dfrac{5}{6}\\) . \\(I = \\dfrac{~~7~~}{\\dfrac{5}{3}} = 7 \\div \\dfrac{5}{3} = 7 \\times \\dfrac{3}{5} = \\dfrac{21}{5}\\) \\(J = \\dfrac{~~\\dfrac{7}{5}~~}{3} = \\dfrac{7}{5} \\div 3 = \\dfrac{7}{5} \\times \\dfrac{1}{3} = \\dfrac{7}{15}\\)","title":"Nombres rationnels"},{"location":"Maths/Seconde/C01/C01_01_Ensembles_Nombres/#nombres-reels","text":"D\u00e9finition : Nombres r\u00e9els Un {==nombre r\u00e9el est un nombre exprimant une longueur, ou l'oppos\u00e9 d'un nombre exprimant une longueur. L'ensemble des nombres rationnels est not\u00e9 \\(\\mathbb{R}\\) . Remarques Un nombre r\u00e9el est un nombre dont le carr\u00e9 est positif ou nul . Par d\u00e9finition, tous les nombres rationnels sont des r\u00e9els. On a alors \\(\\mathbb{Q} \\subset \\mathbb{R}\\) . Certains nombres r\u00e9els ne sont pas rationnels. Par exemple \\(\\pi\\) n'est pas rationnel, tout comme \\(\\sqrt{2}\\) ( on le montrera en exercice ). Ces nombres sont dits irrationnels . Propri\u00e9t\u00e9 : Ensembles de nombres Des remarques pr\u00e9c\u00e9dentes, on \u00e0 la propri\u00e9t\u00e9 : \\[ \\mathbb{N} \\subset \\mathbb{Z} \\subset \\mathbb{D} \\subset \\mathbb{Q} \\subset \\mathbb{R} \\] Propri\u00e9t\u00e9 : Droite des r\u00e9els Tout nombre r\u00e9el est repr\u00e9sent\u00e9 par l'abscisse d'un point sur la droite num\u00e9rique ( appel\u00e9e aussi droite des r\u00e9els ). Application : Repr\u00e9senter sur la droite des r\u00e9els D\u00e9terminer l'abscisse de chacun des points de la droite ci-dessous : Repr\u00e9senter la droite des r\u00e9els ( unit\u00e9 : 5 ) et y placer le plus pr\u00e9cis\u00e9ment possible les nombres suivants : \\[ 3 ~;~ -0,75 ~;~ \\dfrac{5}{4} ~;~\\dfrac{-2}{5} ~;~ \\dfrac{7}{3} ~;~ \\sqrt{2} \\]","title":"Nombres r\u00e9els"},{"location":"Maths/Seconde/C01/C01_02_Intervalles/","text":"\\(C01-02\\) Intervalles Intervalles de nombres r\u00e9els D\u00e9finition Soient \\(a\\) et \\(b\\) deux nombres r\u00e9els tels que \\(a \\leqslant b\\) . On appelle intervalle ferm\u00e9 \\([a;b]\\) l\u2019ensemble des nombres r\u00e9els \\(x\\) tels que \\(a\\leqslant x\\leqslant b\\) . On appelle intervalle ouvert \\(]a;b[\\) l\u2019ensemble des nombres r\u00e9els \\(x\\) tels que \\(a<x<b\\) . On d\u00e9finit de m\u00eame les intervalles \\([a;b[\\) et \\(]a;b]\\) . On note \\([a;+\\infty[\\) l\u2019ensemble des nombres r\u00e9els \\(x\\) tels que \\(x\\geqslant a\\) . On note \\(]a;+\\infty[\\) l\u2019ensemble des nombres r\u00e9els \\(x\\) tels que \\(x>a\\) . On d\u00e9finit de m\u00eame \\(]- \\infty;a]\\) et \\(]-\\infty;a[\\) . Remarques Le symbole \\(+\\infty\\) se lit \" Plus l'infini \". Le symbole \\(-\\infty\\) se lit \" Moins l'infini \". Repr\u00e9senter des intervalles Enonc\u00e9 Ecrire les in\u00e9galit\u00e9s suivantes sous la forme d'un intervalle, puis repr\u00e9senter cet intervalle sur la droite des r\u00e9els : \\(x\\leqslant 5\\) \\(x>-3\\) \\(2<x<5\\) \\(-4\\leqslant x \\leqslant -3\\) \\(-3\\leqslant x < 8\\) \\(-2< x \\leqslant 0\\) Solution \\(]-\\infty ; 5]\\) \\(]-3 ; +\\infty[\\) \\(]2;5[\\) \\([-4;-3]\\) \\([-3;8[\\) \\(]-2;0]\\) Appartient ou pas ? Enonc\u00e9 Compl\u00e9ter avec un symbole \\(\\in\\) ou \\(\\notin\\) : \\(-2 \\dots [-2; 1[\\) \\(-3 \\dots [-5; -1[\\) \\(-\\dfrac{26}{5} \\dots ]-5; -4[\\) \\(4 \\dots [-3; 4[\\) \\(2\\pi \\dots [7;8]\\) \\(0 \\dots \\mathbb{R}\\) \\(0 \\dots \\mathbb{R}^*\\) Solution \\(-2 \\in [-2; 1[\\) \\(-3 \\in [-5; -1[\\) \\(-\\dfrac{26}{5} \\notin ]-5; -4[\\) \\(4 \\notin [-3; 4[\\) \\(2\\pi \\notin [7;8]\\) \\(0 \\in \\mathbb{R}\\) \\(0 \\notin \\mathbb{R}^*\\) Travailler les repr\u00e9sentations Enonc\u00e9 Recopier et compl\u00e9ter : Solution A venir.... Unions et intersections d'intervalles D\u00e9finition Soient \\(I\\) et \\(J\\) deux intervalles. L\u2019intersection de \\(I\\) et \\(J\\) est l\u2019ensemble des r\u00e9els qui appartiennent \u00e0 la fois \u00e0 \\(I\\) \\textbf{ET} \u00e0 \\(J\\) . On note cet ensemble \\(I \\cap J\\) . La r\u00e9union de \\(I\\) et \\(J\\) est l\u2019ensemble des r\u00e9els qui appartiennent \u00e0 \\(I\\) \\textbf{OU} \u00e0 \\(J\\) . On note cet ensemble \\(I \\cup J\\) . Remarques La notation \\(\\cap\\) se lit \\og inter \\fg. D'o\u00f9 \\(I \\cap J\\) se lit \\og \\(I\\) inter \\(J\\) \\fg. La notation \\(\\cup\\) se lit \\og union \\fg. D'o\u00f9 \\(I \\cup J\\) se lit \\og \\(I\\) union \\(J\\) \\fg. Parfois, il n'y a aucun \u00e9l\u00e9ment qui appartiennent \u00e0 la fois \u00e0 \\(I\\) et \\(J\\) . L'intersection est donc \\textbf{vide}, et on note \\(\\emptyset\\) l'ensemble vide. Dans ce cas \\(I \\cap J = \\emptyset\\) . Exemple On consid\u00e8re les intervalles \\(I=[3;7]\\) et \\(J=]2; 5[\\) . L'ensemble \\(I\\cap J\\) est \\([3;5[\\) . L'ensemble \\(I\\cup J\\) est \\(]2;7]\\) . Utiliser les notations \\(\\cap\\) et \\(\\cup\\) Enonc\u00e9 R\\'eduire sous la forme d'un seul intervalle si possible et repr\u00e9senter sur la droite des r\u00e9els : \\(]-3;7] \\cap ]-2;8[\\) \\(]-4;3] \\cap [-2;3,5[\\) \\([-7;4[ \\cup ]-3;5]\\) \\(]-3;5] \\cup [-1;2]\\) \\([-6;6]\\cup[-2;2]\\) \\(]-\\infty;2[ \\cap ]1;+\\infty[\\) \\(]-\\infty;-1] \\cup ]2;6]\\) \\([-5;3] \\cap [6;8]\\) Solution \\(]-3;7] \\cap ]-2;8[ = ]-2;7]\\) \\(]-4;3] \\cap [-2;3,5[ = [-2;3]\\) \\([-7;4[ \\cup ]-3;5] = [-7;5]\\) \\(]-3;5] \\cup [-1;2] = ]-3;5]\\) \\([-6;6]\\cup[-2;2] = [-6;6]\\) \\(]-\\infty;2[ \\cap ]1;+\\infty[ = ]1;2[\\) \\(]-\\infty;-1] \\cup ]2;6] = ]-\\infty;-1] \\cup ]2;6]\\) \\([-5;3] \\cap [6;8] = \\emptyset\\) Ensemble vide L'ensemble vide est not\u00e9 \\(\\emptyset\\) . Travailler les in\u00e9quations et les intervalles Enonc\u00e9 Compl\u00e9ter en s'aidant de la m\u00e9thode donn\u00e9e dans l'exemple ci-dessous. Exemple On a les \u00e9quivalences : \\(x \\in [1;2]\\) \\(\\Longleftrightarrow\\) \\(1 \\leqslant x \\leqslant 2\\) par d\u00e9finition \\(\\Longleftrightarrow\\) \\(3 \\leqslant 3x \\leqslant 6\\) en multipliant chaque membre de l'in\u00e9galit\u00e9 par \\(3\\) \\(\\Longleftrightarrow\\) \\(3x \\in [3;6]\\) par d\u00e9finition d'o\u00f9 \\(x \\in [1;2]\\) si et seulement si \\(3x \\in [3;6]\\) \\(x \\in [7;20]\\) si et seulement si \\(7x \\in \\dots\\) \\(x \\in ]-1;3]\\) si et seulement si \\(x+4 \\in \\dots\\) \\(x \\in [2;6]\\) si et seuelemnt si \\(8-x \\in \\dots\\) $x \\in \\dots $ si et seulement si \\(x+6 \\in ]3 ; +\\infty[\\) $x \\in \\dots $ si et seulement si \\(-2x \\in [4 ; +\\infty[\\) $x \\in \\dots $ si et seulement si \\(4x+3 \\in [-6;5]\\) Solution A venir Repr\u00e9senter sous la forme d'intervalles Enonc\u00e9 \\(y>-3\\) et \\(y<4\\) \\(y>-3\\) ou \\(y<4\\) \\(y \\leqslant \\dfrac{1}{3}\\) et \\(y \\leqslant \\dfrac{1}{2}\\) \\(y \\leqslant \\dfrac{1}{3}\\) ou \\(y \\leqslant \\dfrac{1}{2}\\) Solution A venir R\u00e9solutions d'\u00e9quations du premier degr\u00e9 Enonc\u00e9 R\u00e9soudre dans \\(\\mathbb{R}\\) chacune des \u00e9quations suivantes : \\(3x -6 =0\\) $ 3x -4 = 0$ \\(-3x +64 = 19\\) \\(-2(x+5)=-8\\) \\(3x -\\pi=0\\) \\(\\dfrac{x-8}{3}=-4\\) Lesquelles de ces 4 \u00e9quations sont r\u00e9solubles dans \\(\\Z\\) ? Dans \\(\\Q\\) ? Solution A venir R\u00e9solutions d'in\u00e9quations du premier degr\u00e9 Enonc\u00e9 R\u00e9soudre les in\u00e9quations suivantes et pr\u00e9senter le r\u00e9sultat sous la forme d'un intervalle : \\(3x -6 >0\\) $ 3x -4 \\leqslant 0$ \\(-3x +64 < 19\\)","title":"Intervalles"},{"location":"Maths/Seconde/C01/C01_02_Intervalles/#c01-02-intervalles","text":"","title":"\\(C01-02\\) Intervalles"},{"location":"Maths/Seconde/C01/C01_02_Intervalles/#intervalles-de-nombres-reels","text":"D\u00e9finition Soient \\(a\\) et \\(b\\) deux nombres r\u00e9els tels que \\(a \\leqslant b\\) . On appelle intervalle ferm\u00e9 \\([a;b]\\) l\u2019ensemble des nombres r\u00e9els \\(x\\) tels que \\(a\\leqslant x\\leqslant b\\) . On appelle intervalle ouvert \\(]a;b[\\) l\u2019ensemble des nombres r\u00e9els \\(x\\) tels que \\(a<x<b\\) . On d\u00e9finit de m\u00eame les intervalles \\([a;b[\\) et \\(]a;b]\\) . On note \\([a;+\\infty[\\) l\u2019ensemble des nombres r\u00e9els \\(x\\) tels que \\(x\\geqslant a\\) . On note \\(]a;+\\infty[\\) l\u2019ensemble des nombres r\u00e9els \\(x\\) tels que \\(x>a\\) . On d\u00e9finit de m\u00eame \\(]- \\infty;a]\\) et \\(]-\\infty;a[\\) . Remarques Le symbole \\(+\\infty\\) se lit \" Plus l'infini \". Le symbole \\(-\\infty\\) se lit \" Moins l'infini \". Repr\u00e9senter des intervalles Enonc\u00e9 Ecrire les in\u00e9galit\u00e9s suivantes sous la forme d'un intervalle, puis repr\u00e9senter cet intervalle sur la droite des r\u00e9els : \\(x\\leqslant 5\\) \\(x>-3\\) \\(2<x<5\\) \\(-4\\leqslant x \\leqslant -3\\) \\(-3\\leqslant x < 8\\) \\(-2< x \\leqslant 0\\) Solution \\(]-\\infty ; 5]\\) \\(]-3 ; +\\infty[\\) \\(]2;5[\\) \\([-4;-3]\\) \\([-3;8[\\) \\(]-2;0]\\) Appartient ou pas ? Enonc\u00e9 Compl\u00e9ter avec un symbole \\(\\in\\) ou \\(\\notin\\) : \\(-2 \\dots [-2; 1[\\) \\(-3 \\dots [-5; -1[\\) \\(-\\dfrac{26}{5} \\dots ]-5; -4[\\) \\(4 \\dots [-3; 4[\\) \\(2\\pi \\dots [7;8]\\) \\(0 \\dots \\mathbb{R}\\) \\(0 \\dots \\mathbb{R}^*\\) Solution \\(-2 \\in [-2; 1[\\) \\(-3 \\in [-5; -1[\\) \\(-\\dfrac{26}{5} \\notin ]-5; -4[\\) \\(4 \\notin [-3; 4[\\) \\(2\\pi \\notin [7;8]\\) \\(0 \\in \\mathbb{R}\\) \\(0 \\notin \\mathbb{R}^*\\) Travailler les repr\u00e9sentations Enonc\u00e9 Recopier et compl\u00e9ter : Solution A venir....","title":"Intervalles de nombres r\u00e9els"},{"location":"Maths/Seconde/C01/C01_02_Intervalles/#unions-et-intersections-dintervalles","text":"D\u00e9finition Soient \\(I\\) et \\(J\\) deux intervalles. L\u2019intersection de \\(I\\) et \\(J\\) est l\u2019ensemble des r\u00e9els qui appartiennent \u00e0 la fois \u00e0 \\(I\\) \\textbf{ET} \u00e0 \\(J\\) . On note cet ensemble \\(I \\cap J\\) . La r\u00e9union de \\(I\\) et \\(J\\) est l\u2019ensemble des r\u00e9els qui appartiennent \u00e0 \\(I\\) \\textbf{OU} \u00e0 \\(J\\) . On note cet ensemble \\(I \\cup J\\) . Remarques La notation \\(\\cap\\) se lit \\og inter \\fg. D'o\u00f9 \\(I \\cap J\\) se lit \\og \\(I\\) inter \\(J\\) \\fg. La notation \\(\\cup\\) se lit \\og union \\fg. D'o\u00f9 \\(I \\cup J\\) se lit \\og \\(I\\) union \\(J\\) \\fg. Parfois, il n'y a aucun \u00e9l\u00e9ment qui appartiennent \u00e0 la fois \u00e0 \\(I\\) et \\(J\\) . L'intersection est donc \\textbf{vide}, et on note \\(\\emptyset\\) l'ensemble vide. Dans ce cas \\(I \\cap J = \\emptyset\\) . Exemple On consid\u00e8re les intervalles \\(I=[3;7]\\) et \\(J=]2; 5[\\) . L'ensemble \\(I\\cap J\\) est \\([3;5[\\) . L'ensemble \\(I\\cup J\\) est \\(]2;7]\\) . Utiliser les notations \\(\\cap\\) et \\(\\cup\\) Enonc\u00e9 R\\'eduire sous la forme d'un seul intervalle si possible et repr\u00e9senter sur la droite des r\u00e9els : \\(]-3;7] \\cap ]-2;8[\\) \\(]-4;3] \\cap [-2;3,5[\\) \\([-7;4[ \\cup ]-3;5]\\) \\(]-3;5] \\cup [-1;2]\\) \\([-6;6]\\cup[-2;2]\\) \\(]-\\infty;2[ \\cap ]1;+\\infty[\\) \\(]-\\infty;-1] \\cup ]2;6]\\) \\([-5;3] \\cap [6;8]\\) Solution \\(]-3;7] \\cap ]-2;8[ = ]-2;7]\\) \\(]-4;3] \\cap [-2;3,5[ = [-2;3]\\) \\([-7;4[ \\cup ]-3;5] = [-7;5]\\) \\(]-3;5] \\cup [-1;2] = ]-3;5]\\) \\([-6;6]\\cup[-2;2] = [-6;6]\\) \\(]-\\infty;2[ \\cap ]1;+\\infty[ = ]1;2[\\) \\(]-\\infty;-1] \\cup ]2;6] = ]-\\infty;-1] \\cup ]2;6]\\) \\([-5;3] \\cap [6;8] = \\emptyset\\) Ensemble vide L'ensemble vide est not\u00e9 \\(\\emptyset\\) . Travailler les in\u00e9quations et les intervalles Enonc\u00e9 Compl\u00e9ter en s'aidant de la m\u00e9thode donn\u00e9e dans l'exemple ci-dessous. Exemple On a les \u00e9quivalences : \\(x \\in [1;2]\\) \\(\\Longleftrightarrow\\) \\(1 \\leqslant x \\leqslant 2\\) par d\u00e9finition \\(\\Longleftrightarrow\\) \\(3 \\leqslant 3x \\leqslant 6\\) en multipliant chaque membre de l'in\u00e9galit\u00e9 par \\(3\\) \\(\\Longleftrightarrow\\) \\(3x \\in [3;6]\\) par d\u00e9finition d'o\u00f9 \\(x \\in [1;2]\\) si et seulement si \\(3x \\in [3;6]\\) \\(x \\in [7;20]\\) si et seulement si \\(7x \\in \\dots\\) \\(x \\in ]-1;3]\\) si et seulement si \\(x+4 \\in \\dots\\) \\(x \\in [2;6]\\) si et seuelemnt si \\(8-x \\in \\dots\\) $x \\in \\dots $ si et seulement si \\(x+6 \\in ]3 ; +\\infty[\\) $x \\in \\dots $ si et seulement si \\(-2x \\in [4 ; +\\infty[\\) $x \\in \\dots $ si et seulement si \\(4x+3 \\in [-6;5]\\) Solution A venir Repr\u00e9senter sous la forme d'intervalles Enonc\u00e9 \\(y>-3\\) et \\(y<4\\) \\(y>-3\\) ou \\(y<4\\) \\(y \\leqslant \\dfrac{1}{3}\\) et \\(y \\leqslant \\dfrac{1}{2}\\) \\(y \\leqslant \\dfrac{1}{3}\\) ou \\(y \\leqslant \\dfrac{1}{2}\\) Solution A venir R\u00e9solutions d'\u00e9quations du premier degr\u00e9 Enonc\u00e9 R\u00e9soudre dans \\(\\mathbb{R}\\) chacune des \u00e9quations suivantes : \\(3x -6 =0\\) $ 3x -4 = 0$ \\(-3x +64 = 19\\) \\(-2(x+5)=-8\\) \\(3x -\\pi=0\\) \\(\\dfrac{x-8}{3}=-4\\) Lesquelles de ces 4 \u00e9quations sont r\u00e9solubles dans \\(\\Z\\) ? Dans \\(\\Q\\) ? Solution A venir R\u00e9solutions d'in\u00e9quations du premier degr\u00e9 Enonc\u00e9 R\u00e9soudre les in\u00e9quations suivantes et pr\u00e9senter le r\u00e9sultat sous la forme d'un intervalle : \\(3x -6 >0\\) $ 3x -4 \\leqslant 0$ \\(-3x +64 < 19\\)","title":"Unions et intersections d'intervalles"},{"location":"Miscellanees/mkdocs_cmd/","text":"Syntaxe des documents MkDocs Pour la documentation compl\u00e8te : mkdocs.org . Documentation sur materials : materials reference La documentation sur le plugin macro : macro plugin Bases de la syntaxe Markdown Le langage Mardown est en langage de balise simple, utilis\u00e9 entre autres dans les notebooks Jupyter, et pour lequel les r\u00e8gles d'utilisation sont simples : La mise en gras se fait par en encadrant par 2 \u00e9toiles : **Gras** -> Gras . La mise en italique se fait par en encadrant par 1 \u00e9toile : *Italique* -> Italique . Les titres de diff\u00e9rents niveaux sont obtenus en utilisant un certain nombre de di\u00e8se # Les images sont ins\u00e9r\u00e9es par la commande ![Alt text](/path/to/img.jpg \"Optional title\") Un texte sans fortmatage est obtenu en encadrant par des guillemets invvers\u00e9s ` : '**Truc**' n'est pas mis en forme Pour utiliser un caract\u00e8re * simple, il faut l'\u00e9chapper avec un backslash \\, comme pour tous les autres caract\u00e8re sp\u00e9ciaux. Les citations Pour ins\u00e9rer une citation, on utilise le chevron > devant chaque ligne de code : > Voici une citation > sur plusieurs lignes. donnera Voici une citation sur plusieurs lignes. A noter que si on ne saute pas de ligne, MkDocs formate selon la loingueur de la ligne courante : Pour ins\u00e9rer une citation, on utilise le chevron > devant chaque ligne de code : > Voici une citation > sur une seule ligne. donnera Voici une citation sur une seule ligne. Les hyperliens Le fonctionnement des hyperlmens est particulier \u00e0 MkDocs, donc ce qui suit n'est pas toujours valable dans n'importe quel environnement lisant du MarkDown . Le principe de base : [texte de remplacement](adresse du document) Il est possible de r\u00e9f\u00e9rer \u00e0 des documents internes en utilisant leur chemin relatif. Please see the [project license](../about/license.md) for further details. Il est possible de faire une r\u00e9f\u00e9rence \u00e0 une partie sp\u00e9cifique d'un document par l'interm\u00e9diaire d'ID g\u00e9n\u00e9r\u00e9es automatiquement par MkDocs pour chaque header (\u26a0\ufe0f les noms sont en minuscules et les caract\u00e8res sp\u00e9ciaux - y compris les espaces, sont remplac\u00e9 par des tirets. lers tirets doubles sont alors r\u00e9duits \u00e0 un simple tiret). Ainsi le lien [ceci](mkdocs_cmd.md#syntaxe-des-documents-mkdocs) renvoie ici renvoie vers le header de cette partie. Modules de MkDocs-Material Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Test code 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] supprime et insere et Surligne Keys Ctrl Alt Del Latex \\[ \\dfrac{3}{4x} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) . Admonitions (?) Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note On teste l'auto deploiement","title":"MkDocs"},{"location":"Miscellanees/mkdocs_cmd/#syntaxe-des-documents-mkdocs","text":"Pour la documentation compl\u00e8te : mkdocs.org . Documentation sur materials : materials reference La documentation sur le plugin macro : macro plugin","title":"Syntaxe des documents MkDocs"},{"location":"Miscellanees/mkdocs_cmd/#bases-de-la-syntaxe-markdown","text":"Le langage Mardown est en langage de balise simple, utilis\u00e9 entre autres dans les notebooks Jupyter, et pour lequel les r\u00e8gles d'utilisation sont simples : La mise en gras se fait par en encadrant par 2 \u00e9toiles : **Gras** -> Gras . La mise en italique se fait par en encadrant par 1 \u00e9toile : *Italique* -> Italique . Les titres de diff\u00e9rents niveaux sont obtenus en utilisant un certain nombre de di\u00e8se # Les images sont ins\u00e9r\u00e9es par la commande ![Alt text](/path/to/img.jpg \"Optional title\") Un texte sans fortmatage est obtenu en encadrant par des guillemets invvers\u00e9s ` : '**Truc**' n'est pas mis en forme Pour utiliser un caract\u00e8re * simple, il faut l'\u00e9chapper avec un backslash \\, comme pour tous les autres caract\u00e8re sp\u00e9ciaux.","title":"Bases de la syntaxe Markdown"},{"location":"Miscellanees/mkdocs_cmd/#les-citations","text":"Pour ins\u00e9rer une citation, on utilise le chevron > devant chaque ligne de code : > Voici une citation > sur plusieurs lignes. donnera Voici une citation sur plusieurs lignes. A noter que si on ne saute pas de ligne, MkDocs formate selon la loingueur de la ligne courante : Pour ins\u00e9rer une citation, on utilise le chevron > devant chaque ligne de code : > Voici une citation > sur une seule ligne. donnera Voici une citation sur une seule ligne.","title":"Les citations"},{"location":"Miscellanees/mkdocs_cmd/#les-hyperliens","text":"Le fonctionnement des hyperlmens est particulier \u00e0 MkDocs, donc ce qui suit n'est pas toujours valable dans n'importe quel environnement lisant du MarkDown . Le principe de base : [texte de remplacement](adresse du document) Il est possible de r\u00e9f\u00e9rer \u00e0 des documents internes en utilisant leur chemin relatif. Please see the [project license](../about/license.md) for further details. Il est possible de faire une r\u00e9f\u00e9rence \u00e0 une partie sp\u00e9cifique d'un document par l'interm\u00e9diaire d'ID g\u00e9n\u00e9r\u00e9es automatiquement par MkDocs pour chaque header (\u26a0\ufe0f les noms sont en minuscules et les caract\u00e8res sp\u00e9ciaux - y compris les espaces, sont remplac\u00e9 par des tirets. lers tirets doubles sont alors r\u00e9duits \u00e0 un simple tiret). Ainsi le lien [ceci](mkdocs_cmd.md#syntaxe-des-documents-mkdocs) renvoie ici renvoie vers le header de cette partie.","title":"Les hyperliens"},{"location":"Miscellanees/mkdocs_cmd/#modules-de-mkdocs-material","text":"","title":"Modules de MkDocs-Material"},{"location":"Miscellanees/mkdocs_cmd/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"Miscellanees/mkdocs_cmd/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Miscellanees/mkdocs_cmd/#test-code","text":"1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] supprime et insere et Surligne","title":"Test code"},{"location":"Miscellanees/mkdocs_cmd/#keys","text":"Ctrl Alt Del","title":"Keys"},{"location":"Miscellanees/mkdocs_cmd/#latex","text":"\\[ \\dfrac{3}{4x} \\] The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\) , because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\) .","title":"Latex"},{"location":"Miscellanees/mkdocs_cmd/#admonitions","text":"Note Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Nunc eu odio eleifend, blandit leo a, volutpat sapien. Phasellus posuere in sem ut cursus. Nullam sit amet tincidunt ipsum, sit amet elementum turpis. Etiam ipsum quam, mattis in purus vitae, lacinia fermentum enim. Question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Note On teste l'auto deploiement","title":"Admonitions (?)"},{"location":"Miscellanees/Pygame/Base_pygame/","text":"Bases de Pygame Ce cours est tr\u00e8s largement et assez honteusement copi\u00e9 sur celui-ci . Merci \u00e0 vous ! En cas de soucis de droits, n'h\u00e9sitez pas \u00e0 me contacter par le lien situ\u00e9 en bas de page ! Importer Pygame et ses constantes Pygame est une biblioth\u00e8que, et en tant que telle, elle est construite \u00e0 partir de plusieurs modules. Les noms de ces modules sont : display mixer draw event image mouse time Il existe alors plusieurs possibilit\u00e9s pour importe pygame Importation compl\u00e8te : import pygame La totalit\u00e9 de la biblioth\u00e8que est alors import\u00e9e, et pour utiliser la fonction update du module display on devra alors utiliser pygame.display.update() . Importation partielle des modules n\u00e9cessaires : from pygame import display Seul le module display est alors import\u00e9, et pour utiliser la fonction update de ce module, on devra alors utiliser display.update() . Importation compl\u00e8te avec import des constantes directement dans l'espace de nommage (conseill\u00e9e) : import pygame from pygame.locals import * Dans ce cas, pour utiliser la constante repr\u00e9sentant la touche espace, au lieu d'utiliser pygame.locals.K_SPACE , on utilisera simplement K_SPACE . Cr\u00e9ation d'une fen\u00eatre graphique et boucle d'\u00e9v\u00e8nements Le projet Commen\u00e7ons un petit programme qui nous am\u00e8nera \u00e0 d\u00e9placer un personnage de gauche \u00e0 droite sur un fond d'\u00e9cran, pendant que des balles tombent depuis le haut de l'\u00e9cran \u00e0 diff\u00e9rentes vitesses. Le jeu consistera \u00e0 \u00e9viter que le personnage entre en collision avec les balles, et s'arr\u00eatera d\u00e8s qu'une collision aura lieu. Le premier point est d'afficher une fen\u00eatre graphique d'une dimension donn\u00e9e : \\(640 \\times 480~ pixels^2\\) (oui, en bon prof de maths, je respecte \u00e0 minima les unit\u00e9s...). On utilise le script suivant, dans un fichier nomm\u00e9 dodgeTheBall.py : 1 2 3 4 5 6 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) Analysons le code Dans les deux premi\u00e8res lignes, nous importons pygame en totalit\u00e9 ainsi que les constantes sp\u00e9cifiques dans l'espace de nommage courant. En ligne 4, nous initialisons tous les modules de pygame . En ligne 6, nous appelons ensuite la fonction set_mode() contenue dans le module display de pygame , qui prend en argument un tuple contenant la largeur et la hauteur de la fen\u00eatre voulue (attention, c'est bien un tuple ! pygame.display.set_mode(640, 480) ne fonctionne pas !). Y'a un bug ! La fen\u00eatre reste bloqu\u00e9e et ne se ferme pas sauf si on force l'arr\u00eat du script ! Effectivement, on se retrouve bloqu\u00e9... Il faut rajouter \u00e0 notre code une instruction suppl\u00e9mentaire pour que la fen\u00ebtre se ferme : 1 2 3 4 5 6 7 8 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) pygame . quit () Encore un Et oui ! Notre fen\u00eatre s'ouvre mais se ferme imm\u00e9diatement ! Or nous aimerions qu'elle ne se ferme que sur demande explicite de l'utilisateur, par exemple par un clic sur la croix. C'est l\u00e0 qu'intervient la notion de boucle d'\u00e9v\u00e8nements . Dans un programme classique, en programmation imp\u00e9rative , le programme se d\u00e9roule plus ou moins lin\u00e9airement de la premi\u00e8re ligne \u00e0 la derni\u00e8re. Mais lorsqu'on utilise des interfaces graphiques , on ne peut pr\u00e9voir \u00e0 l'avance le comportement de l'utilisateur, et donc suivre un chemin clairement d\u00e9fini \u00e0 l'avance. C'est pour cette raison qu'on utilise plut\u00f4t le paradigme de la programmation \u00e9v\u00e9nementielle , c'est-\u00e0-dire un paradigme o\u00f9 on pr\u00e9voira l'action de l'utilisateur, mais pas dans un ordre pr\u00e9cis. Chaque action pr\u00e9vue dans la boucle d'\u00e9v\u00e8nements aura un impact pr\u00e9cis. Dans notre cas, nous souhaiterions que la fen\u00eatre reste ouverte tant que l'utilisateur n'a pas exprim\u00e9 le d\u00e9sir de la fermer, soit par l'interm\u00e9diaire de la croix, soit par l'interm\u00e9diaire de la combinaison de touches Alt + F4 . Notion d'\u00e9v\u00e8nements Dans la construction d'interfaces graphiques, on utilise souvent la notion d' \u00e9v\u00e8nements . Un \u00e9v\u00e8nement correspond \u00e0 : un d\u00e9placement de la souris ; le survol d'une zone sp\u00e9cifique de l'\u00e9cran par le pointeur de la souris ; un appui sur une ou plusieurs touches du clavier : le rel\u00e2chement d'une touche de clavier ; un appui ou rel\u00e2chement d'un bouton de la souris ; un \u00e9v\u00e9nement sp\u00e9cifique pr\u00e9vu dans le programme ; un changement de luminosit\u00e9 devant un capteur vid\u00e9o ; ... Ces \u00e9v\u00e8nements sont stock\u00e9s \u00e0 leur apparition dans une file (fifo) de dimension limit\u00e9e , nettoy\u00e9e r\u00e9guli\u00e8rement de ses \u00e9v\u00e8nements les plus anciens. Dans pygame , les \u00e9v\u00e8nements sont des constantes, et celui qui nous int\u00e9resse est l'\u00e9v\u00e8nement QUIT . Nous allons donc parcourir la liste des \u00e9v\u00e8nements pour ensuite pouvoir quitter la fen\u00eatre si celui-ci est exprim\u00e9 : 1 2 3 4 5 6 7 8 9 10 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) for event in pygame . event . get () : if event == QUIT : pygame . quit () L'arnaque : \u00e7a ne marche pas ! On retombe sur notre probl\u00e8me pr\u00e9c\u00e9dent : la fen\u00eatre ne se ferme plus... C'est parce que la file d'\u00e9v\u00e8nements se construit et se nettoie tr\u00e8s rapidement ! Nous n'avons pas le temps de cliquer sur la croix que d\u00e9j\u00e0 le parcours par la boucle for est termin\u00e9 ! Et donc dans ce cas on ne passe jamais par l'instruction pygame.quit() . Il va donc falloir r\u00e9p\u00e9ter la lecture d'\u00e9v\u00e8nements pour pouvoir d\u00e9tecter quand l'utilisateur souhaite fermer sa fen\u00eatre. Boucle d'\u00e9v\u00e8nements Une boucle d'\u00e9v\u00e8nements est une boucle qui se r\u00e9p\u00e8te tant qu'un \u00e9v\u00e8nement pr\u00e9cis ne s'est pas produit. A chaque tour de boucle on va lire la totalit\u00e9 des \u00e9v\u00e8nements enregistr\u00e9s dans la file, et on d\u00e9clenchera la sortie de cette boucle si l'\u00e9v\u00e8nement est trouv\u00e9. Pour notre exemple, nous allons cr\u00e9er une boucle while d\u00e9pendant d'une variable continuer initialis\u00e9e \u00e0 True , que nous basculerons \u00e0 False lorsque l'\u00e9v\u00e8nement QUIT est intercept\u00e9 : Un code fonctionnel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False pygame . quit () Enfin ! Notre fen\u00eatre fonctionne ! Ajout d'image de Fond Image de fond Notre fond noir est un peu d\u00e9primant. Mettons un peu de verdure gr\u00e2ce \u00e0 l'image suivante : T\u00e9l\u00e9chargez cette image sous le nom background.jpg puis ajoutez la ligne suivante en ligne 7 : 7 fond = pygame . image . load ( \"background.jpg\" ) . convert () Bon : mauvaise nouvelle, ce ne sera pas suffisant ! La variable fond n'est qu'une r\u00e9f\u00e9rence \u00e0 une Surface de pygame , retourn\u00e9e par la fonction load() . Une Surface est une classe d'objets d\u00e9finie dans pygame qui poss\u00e8de de nombreux attributs et m\u00e9thodes (cf. la doc ). La m\u00e9thode convert() des objets Surface sert \u00e0 convertir l'image source au format utilis\u00e9 par pygame . Le principe d'affichage de la SDL (la sous-couche logicielle g\u00e9rant les images, le son, etc...) est \u00e0 conna\u00eetre pour bien afficher ses images : fenetre est une surface vide, sur laquelle on va \"coller\", ou \"empiler\" les autres images. Le fond doit donc \u00eatre empil\u00e9 sur la surface vide de la fen\u00eatre , gr\u00e2ce \u00e0 la m\u00e9thode blit() . Cette m\u00e9thode prend une Surface en argument ainsi qu'un tuple repr\u00e9sentant les coordonn\u00e9es du coin sup\u00e9rieur gauche auquel sera coll\u00e9 la Surface argument par rapport \u00e0 la Surface appelante. Syst\u00e8me de coordonn\u00e9es On peut donner comme exemples de tuple de coordonn\u00e9es ceux de l'image suivante : On pourrait donc utiliser le code suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False pygame . quit () Mais pourquoi \u00e7a n'affiche rien ! Parce que quand on blit une Surface , pygame calcule ce qu'il faut mais ne l'ex\u00e9cute pas r\u00e9ellement. Il faut forcer le rafra\u00eechissement de l'\u00e9cran pour y parvenir, par l'interm\u00e9diaire de la commande pygame.display.update() . Comme nous comptons bien faire bouger un personnage sur l'\u00e9cran, et que les mouvements de celui-ci d\u00e9pendront de la boucle d'\u00e9v\u00e8nements, autant mettre imm\u00e9diatement cette commande en fin de boucle, pour que l'image soit syst\u00e9matiquement mise \u00e0 jour. : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () fenetre . blit ( fond ,( 0 , 0 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False pygame . display . update () pygame . quit () Et voil\u00e0 ! 15 lignes de code, et nous voil\u00e0 avec une fen\u00eatre graphique digne de ce nom ! Ajout du sprite du joueur Les sprites Explications Ajoutons maintenant une nouvelle image, celle repr\u00e9sentant le personnage du joueur. Cette image est de dimension \\(100 \\times 100\\) , et nous voudrions la placer tout en bas de l'\u00e9cran, au centre. Les coordonn\u00e9es de son coin sup\u00e9rieur gauche seront donc \\((\\dfrac{640 - 100}{2} ; 480 - 100)\\) . Pour cela, on ajoute hors de la boucle la commande suivante perso = pygame.image.load(\"perso.png\").convert() , suivie de la commande fenetre.blit(perso,(270,380)) (mais apr\u00e8s avoir coll\u00e9 le fond). Code complet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () perso = pygame . image . load ( \"Perso.png\" ) . convert () fenetre . blit ( fond ,( 0 , 0 )) fenetre . blit ( perso , ( 270 , 380 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False pygame . display . update () pygame . quit () Transparence et canal alpha Canal Alpha Le r\u00e9sultat est peu probant. En effet nous voyons un cadre noir autour sprite du personnage. Il va donc falloir ajouter de la transparence \u00e0 cette image. Cette possibilit\u00e9 est offerte par le format png , qui poss\u00e8de un format de couleur bas\u00e9 sur la syst\u00e8me RGB + canal Alpha . Un pixel est donc repr\u00e9sent\u00e9 par 4 octets : Les trois premiers pour les canaux RGB , chacun \u00e9tant donc repr\u00e9sent\u00e9 par un nombre entre 0 et 255 ( sommairement 0 repr\u00e9sentant le canal \u00e9teint, et 255 le canal allum\u00e9 au maximum) ; Le dernier octet pour le canal Alpha , qui va repr\u00e9senter le niveau de transparence du pixel. Ainsi un pixel poss\u00e9dant un canal Alpha \u00e0 \\(0\\) sera totalement transparent, alors qu'avec une valeur de \\(255\\) , il sera totalement opaque. Pygame est bien entendu capable de g\u00e9rer cette transparence, il suffit d'utiliser la m\u00e9thode convert_alpha() \u00e0 la place de la m\u00e9thode convert() . Code complet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () perso = pygame . image . load ( \"Perso.png\" ) . convert_alpha () fenetre . blit ( fond ,( 0 , 0 )) fenetre . blit ( perso , ( 270 , 380 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False pygame . display . update () pygame . quit () Et les autres formats ? Le format png est \u00e0 privil\u00e9gier pour l'utilisation de sprites. cependant il est aussi possible de forcer une couleur d'une image de format quelconque \u00e0 devenir transparente, gr\u00e2ce \u00e0 la m\u00e9thode set_colorkey() utilis\u00e9e comme dans la ligne suivante : image.set_colorkey((255,255,255)) Ici on a rendu la couleur blanche (triplet RGB \\((255, 255, 255)\\) ) transparente pour l'objet image . D\u00e9placement du joueur Cette partie a pour objectif de vous faire comprendre deux points : la notion d'objet Rect de pygame ; l'utilisation d'\u00e9v\u00e8nements claviers. Elle n'est pas formellement correcte, car je n'utilise pas ici de constructeur d'objets et de capteurs d'\u00e9v\u00e8nements. Nous verrons ceci dans la partie suivante. Images et objets Rect Pygame utilises des objets de type Rect pour stocker et manipuler des surfaces rectangulaires. Un objet de type Rect peut \u00eatre cr\u00e9er par une combinaison de valeurs left, top, width, height repr\u00e9sentant respectivement l'abscisse du c\u00f4t\u00e9 gauche du rectangle, l'ordonn\u00e9e du c\u00f4t\u00e9 haut du rectangle, sa largeur puis sa hauteur en pixels. Des objets de type Rect peuvent \u00eatre aussi cr\u00e9\u00e9s \u00e0 partir d'autres objets pygame qui sont soit des Rect , soit poss\u00e8dent un attribut nomm\u00e9 rect (ce qui est le cas des images). Un objet de type Rect poss\u00e8de de nombreux attributs d\u00e9finissant la position et la taille de l'objet : x,y top, left, bottom, right topleft, bottomleft, topright, bottomright midtop, midleft, midbottom, midright center, centerx, centery size, width, height w,h On peut aussi affecter directement tous ces attributs : rect1.right = 10 rect2.center = (20,30) Affecter \u00e0 size, width, height, w ou h change les dimensions du rectangle. Toute les autres affectations d\u00e9placent le rectangle sans le redimmensionner. Notez que certains attributs sont des entiers ( x, y, top, bottom, centerx,... ), et que d'autres sont des tuples d'entiers de dimension 2 ( topleft, bottomright, center,... ) Les m\u00e9thodes ou fonctions `Rect` qui changent la position ou la taille d'un Rect renvoient une nouvelle copie de ce Rect avec les changements effectu\u00e9s . Le Rect original n'est pas modifi\u00e9. Cependant certaines m\u00e9thodes ont une version in-place qui retournent None mais affectent le Rect original. Ces m\u00e9thodes \"in-place\" sont celles pr\u00e9fix\u00e9es par ip_ . La liste compl\u00e8te des m\u00e9thodes et des d\u00e9tails est bien s\u00fbr disponible dans la doc pygame . Les \u00e9v\u00e8nements claviers Lorsque vous coderez une interface graphique, il est probable que vous assignerez des touches clavier aux diff\u00e9rentes actions. Le type d'\u00e9v\u00e9nement cr\u00e9\u00e9 lorsque l'on appuie sur une touche est rep\u00e9r\u00e9 par la constante KEYDOWN , (ou KEYUP au rel\u00e2chement de la touche). Dans la boucle d'\u00e9v\u00e8nement, on pourra alors utiliser une structure conditionnelle telle que if event.type == KEYDOWN: Mais attention, cette condition sera vraie quelque soit la touche press\u00e9e ! Pour d\u00e9finir une seule touche du clavier, vous devrez utilisez en plus event.key , qui d\u00e9termine la touche press\u00e9e, disponible uniquement lors d'un \u00e9v\u00e9nement clavier. Cet event.key peut prendre les valeurs suivantes : Lettres: K_a ... K_z Nombres: K_0 ... K_9 Contr\u00f4les: K_TAB, K_RETURN, K_ESCAPE,... Fl\u00e8ches: K_LEFT, K_UP, K_RIGHT, K_DOWN ... La liste compl\u00e8te des constantes est disponible ici D\u00e9placement du sprite de gauche \u00e0 droite Mise en place du code Bien maintenant nous savons a peu pr\u00eat quoi faire. Commen\u00e7ons par cr\u00e9er un Rect a partir de l'image du personnage, juste apr\u00e8s la ligne de cr\u00e9ation de l'image perso : persoRect = perso.get_rect() Mais attention, on ne vient que de cr\u00e9er le Rect , et il n'a pas de position d\u00e9finie. On va alors effacer la ligne de blit du personnage, et la remplacer par : persoRect.topleft = (270,380) Notre rectangle est ainsi positionn\u00e9 correctement au centre de l'\u00e9cran, en bas. Nous allons modifier ensuite persoRect pour d\u00e9placer le sprite. Nous fixons la vitesse de d\u00e9placement du sprite avec une base de \\(10\\) pixels par tour de boucle. Dans la boucle d'\u00e9v\u00e9nement, nous ajoutons alors les lignes suivantes : if event.type == KEYDOWN : if event.key == K_LEFT : if persoRect.left>=10 : persoRect = persoRect.move(-10,0) if event.key == K_RIGHT : if persoRect.right<=630 : persoRect = persoRect.move(10,0) Nous avons ainsi un d\u00e9placement, mais si vous testez le code \u00e0 ce moment, rien ne se passe. En effet, il ne faut pas oublier de blitter l'image \u00e0 la nouvelle position du Rect . On rajoute donc \u00e0 la fin de la boucle while True la ligne suivante : fenetre.blit(perso, persoRect) Code complet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () perso = pygame . image . load ( \"Perso.png\" ) . convert_alpha () persoRect = perso . get_rect () persoRect . topleft = ( 270 , 380 ) fenetre . blit ( fond ,( 0 , 0 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False if event . type == KEYDOWN : if event . key == K_LEFT : if persoRect . left >= 10 : persoRect = persoRect . move ( - 10 , 0 ) if event . key == K_RIGHT : if persoRect . right <= 630 : persoRect = persoRect . move ( 10 , 0 ) fenetre . blit ( perso , persoRect ) pygame . display . update () pygame . quit () Mais c'est nul ! raisons et corrections Et oui, pour plusieurs raisons : * la page ne se rafra\u00eechit pas totalement, et la trace des anciennes positions du sprite est gard\u00e9e; * il faut r\u00e9-appuyer sur la touche pour re-d\u00e9placer le personnage, le d\u00e9placement n'est pas fluide. Le premier probl\u00e8me vient de la ligne pygame.display.update() , qui ne change que les pixels modifi\u00e9s par rapport au dernier affichage. Une solution simple consiste \u00e0 forcer l'affichage du fond avant le blit du sprite : fenetre . blit ( fond , ( 0 , 0 )) fenetre . blit ( perso , persoRect ) Pour le second probl\u00e8me, une solution simple (mais pas toujours efficace) consiste \u00e0 utiliser la m\u00e9thode set_repeat() du module key ,qui prend en param\u00e8tres : le d\u00e9lai avant de continuer les d\u00e9placements quand la touche reste enfonc\u00e9e (en millisecondes); le temps entre chaque d\u00e9placement. (en millisecondes) Vous devez donc, apr\u00e8s initialisation de pygame placer la ligne : pygame.key.set_repeat(400, 30) Le code complet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import pygame from pygame.locals import * pygame . init () pygame . key . set_repeat ( 400 , 30 ) fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () perso = pygame . image . load ( \"Perso.png\" ) . convert_alpha () persoRect = perso . get_rect () persoRect . topleft = ( 270 , 380 ) fenetre . blit ( fond ,( 0 , 0 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False if event . type == KEYDOWN : if event . key == K_LEFT : if persoRect . left >= 10 : persoRect = persoRect . move ( - 10 , 0 ) if event . key == K_RIGHT : if persoRect . right <= 630 : persoRect = persoRect . move ( 10 , 0 ) fenetre . blit ( fond , ( 0 , 0 )) fenetre . blit ( perso , persoRect ) pygame . display . update () pygame . quit () Une solution plus \u00e9l\u00e9gante, et plus efficace (mais inutile ici) Solution Le probl\u00e8me de l'utilisation de la m\u00e9thode ci-dessus est qu'il est impossible de traiter des appuis sur des combinaisons de touches, puisqu'une seule touche est repr\u00e9sent\u00e9e par l'attribut event.key . Heureusement, les concepteurs de pygame ont pr\u00e9vu une m\u00e9thode bien plus efficace : la m\u00e9thode get_pressed() du module key , qui renvoie un dictionnaire de bool\u00e9ens ayant pour cl\u00e9 la constante repr\u00e9sentant la touche, et pour lequel les valeurs True correspondent aux touches actuellement appuy\u00e9es. On peut alors retirer de la boucle d'\u00e9v\u00e8nements toute la partie concernant les appuis de touches, et les remplacer par : dicKeys = pygame . key . get_pressed () if dicKeys [ K_LEFT ] : if persoRect . left >= 10 : persoRect = persoRect . move ( - 10 , 0 ) if dicKeys [ K_RIGHT ] : if persoRect . right <= 630 : persoRect = persoRect . move ( 10 , 0 ) Le code de remplacement 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import pygame from pygame.locals import * pygame . init () pygame . key . set_repeat ( 400 , 30 ) fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () perso = pygame . image . load ( \"Perso.png\" ) . convert_alpha () persoRect = perso . get_rect () persoRect . topleft = ( 270 , 380 ) fenetre . blit ( fond ,( 0 , 0 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False dicKeys = pygame . key . get_pressed () if dicKeys [ K_LEFT ] : if persoRect . left >= 10 : persoRect = persoRect . move ( - 10 , 0 ) if dicKeys [ K_RIGHT ] : if persoRect . right <= 630 : persoRect = persoRect . move ( 10 , 0 ) fenetre . blit ( fond , ( 0 , 0 )) fenetre . blit ( perso , persoRect ) pygame . display . update () pygame . quit () Cr\u00e9ation d'une classe d'objets \"Balle\" classe Balle Interface Sachant que plusieurs balles vont tomber simultan\u00e9ment, nous allons construire une classe d'objets pour repr\u00e9senter ces balles. Chaque balle sera repr\u00e9sent\u00e9e par une image , qui devra donc \u00eatre associ\u00e9e \u00e0 un rectangle . Chaque balle aura une position, qui sera donn\u00e9e originellement par son centre . Elle aura par ailleurs une vitesse , dont la valeur de d\u00e9part sera tir\u00e9e al\u00e9atoirement entre 1 et 5. Un certain nombre d'actions seront utilis\u00e9es sur ou par cette balle : elle se d\u00e9placera d'un nombre de pixels \u00e9gal \u00e0 sa vitesse ; on testera sa collision avec le joueur, en renvoyant un bool\u00e9en ; et bien sur on l' affichera dans la fenetre courante. On repr\u00e9sente donc la classe balle par l'interface suivante : Nous impl\u00e9mentons de cette classe dans un fichier balle.py . Le code est donn\u00e9 dans l'onglet ci contre, et ne n\u00e9cessite que peu de commentaires, \u00e0 part pour la m\u00e9thode collision(self,targetRect) . Dans le cadre de ce tutoriel, nous utiliserons la m\u00e9thode colliderect des objets Rect . Cette m\u00e9thode renvoie True si le rectangle de la balle est en collision avec le rectangle pass\u00e9 en argument et False sinon. Deux rectangles sont en collision si ils ont une partie commune. Pour les amateurs de hitbox plus pr\u00e9cises, il faudra voir du c\u00f4t\u00e9 de la classe Mask de pygame , qui utilise le canal alpha ou bien une cl\u00e9 colorim\u00e9trique pour d\u00e9tecter des collisions au pixel pr\u00e8s. Code du fichier balle.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import pygame from random import randint class Balle : def __init__ ( self , image , center ) : \"\"\" Initialisation d'un objet de classe Balle a partir de deux arguments : - image est l'adresse relative ou absolue de l'image voulue pour l'objet ; - center est un tuple de deux entiers donnant la position du centre de la balle lors de sa cr\u00e9ation.\"\"\" self . image = pygame . image . load ( image ) . convert_alpha () self . rect = self . image . get_rect () self . rect . center = center self . vitesse = randint ( 1 , 5 ) def affiche ( self , fenetre ) : fenetre . blit ( self . image , self . rect ) def deplace ( self ) : self . rect = self . rect . move ( 0 , self . vitesse ) def collision ( self , targetRect ) : return self . rect . colliderect ( targetRect ) Apparition des objets Balle et gestion des collisions \u00c9tablissons les r\u00e8gles On pose les r\u00e8gles suivantes concernant les balles : elles ne peuvent pas \u00eatre plus de 10 simultan\u00e9ment ; elles sont construites \u00e0 partir de l'image suivante, de dimension \\(50 \\times 50\\) : elles apparaissent avec une abscisse al\u00e9atoire entre 25 et 455 (pour ne pas d\u00e9passer de l'\u00e9cran ; elles disparaissent une fois compl\u00e8tement sorties de l'\u00e9cran ; le jeu s'arr\u00eate et ferme la fen\u00eatre d\u00e8s que le personnage est touch\u00e9 par une balle. Codons ! Description Commen\u00e7ons d\u00e9j\u00e0 par importer les objets de types Balle depuis balle.py , et importons aussi au passage la fonction randint du module random dont nous aurons besoin pour les tirages al\u00e9atoires des positions de d\u00e9part. from balle import Balle from random import randint Les balles existantes seront stock\u00e9es dans une liste python tout ce qui est de plus classique. Nous cr\u00e9ons donc une variable listeBalles au d\u00e9part vide, juste avant la boucle while continuer : . listeBalles = [] Ensuite il faut cr\u00e9er un syst\u00e8me d'apparition des balles. Pour cela, dans la boucle while continuer : , nous allons \u00e0 chaque tour de boucle ajouter une balle, si la longueur de la liste est inf\u00e9rieure \u00e0 10. Mais ce ne sera pas suffisant ! En effet, la boucle tourne tr\u00e8s vite ! Plusieurs centaines de fois voir plusieurs milliers de fois par seconde . Donc dans ce cas, le joueur aurait l'impression que les 10 balles arrivent de mani\u00e8re simultan\u00e9es. Il faut donc introduire un syst\u00e8me permettant de limiter ces apparitions, tout en gardant un c\u00f4t\u00e9 al\u00e9atoire pour le jeu. On utilisera alors les lignes suivantes : if len ( listeBalles ) < 10 and randint ( 1 , 500 ) <= 10 : listeBalles . append ( Balle ( 'golfBall.png' ,( randint ( 25 , 455 ), - 25 ))) Les valeurs pr\u00e9sentes dans la condition randint ont \u00e9t\u00e9 test\u00e9e sur mon PC, mais elles peuvent \u00eatre modifi\u00e9es selon la puissance de votre machine. Voil\u00e0, les objets de type Balle sont cr\u00e9es selon les conditions que nous avons pos\u00e9es au d\u00e9part. Reste \u00e0 les afficher, les d\u00e9placer et les faire dispara\u00eetre le cas \u00e9ch\u00e9ant. Pour les d\u00e9placer et les afficher, pla\u00e7ons nous juste apr\u00e8s le blit de l'image de fond. Nous parcourons alors la liste des balles et leur appliquons successivement les m\u00e9thodes deplace() et affiche() , en donnant comme argument la fen\u00eatre courante pour l'affichage : for ball in listeBalles : ball . deplace () ball . affiche ( fenetre ) Probl\u00e8me : nos balles disparaissent de l'\u00e9cran, mais de nouvelles n'apparaissent plus. C'est normal, nous avons satur\u00e9 la variable listeBalles qui ne peut contenir plus de 10 objets. Il faut donc faire dispara\u00eetre les objets de la liste quand ils sortent de l'\u00e9cran. for ball in listeBalles : ball . deplace () if ball . rect . top >= 480 : listeBalles . remove ( ball ) else : ball . affiche ( fenetre ) Il ne nous reste plus qu'\u00e0 g\u00e9rer la fin du jeu : quand une balle entre en collision avec le joueur, nous basculons la variable continuer \u00e0 False pour arr\u00eater la boucle while : for ball in listeBalles : ball . deplace () if ball . rect . top >= 480 : listeBalles . remove ( ball ) else : if ball . collision ( persoRect ) : continuer = False ball . affiche ( fenetre ) Voil\u00e0, le contrat est rempli. Bien entendu ce n'est qu'un d\u00e9but de jeu, et il reste beaucoup de points \u00e0 am\u00e9liorer. Mais vous avez maintenant les bases pour vous permettre de r\u00e9aliser des jeux d'arcades classiques. le code complet du fichier dodegTheBall.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import pygame from pygame.locals import * from balle import Balle from random import randint pygame . init () pygame . key . set_repeat ( 400 , 30 ) fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () perso = pygame . image . load ( \"Perso.png\" ) . convert_alpha () persoRect = perso . get_rect () persoRect . topleft = ( 270 , 380 ) fenetre . blit ( fond ,( 0 , 0 )) continuer = True listeBalles = [] while continuer : if len ( listeBalles ) < 10 and randint ( 1 , 500 ) <= 10 : listeBalles . append ( Balle ( 'golfBall.png' ,( randint ( 25 , 455 ), - 25 ))) for event in pygame . event . get (): if event . type == QUIT : continuer = False if event . type == KEYDOWN : if event . key == K_LEFT : if persoRect . left >= 10 : persoRect = persoRect . move ( - 10 , 0 ) if event . key == K_RIGHT : if persoRect . right <= 630 : persoRect = persoRect . move ( 10 , 0 ) fenetre . blit ( fond , ( 0 , 0 )) for ball in listeBalles : ball . deplace () if ball . rect . top >= 480 : listeBalles . remove ( ball ) else : if ball . collision ( persoRect ) : continuer = False ball . affiche ( fenetre ) fenetre . blit ( perso , persoRect ) pygame . display . update () pygame . time . wait ( 10 ) pygame . quit ()","title":"Bases de Pygame"},{"location":"Miscellanees/Pygame/Base_pygame/#bases-de-pygame","text":"Ce cours est tr\u00e8s largement et assez honteusement copi\u00e9 sur celui-ci . Merci \u00e0 vous ! En cas de soucis de droits, n'h\u00e9sitez pas \u00e0 me contacter par le lien situ\u00e9 en bas de page !","title":"Bases de Pygame"},{"location":"Miscellanees/Pygame/Base_pygame/#importer-pygame-et-ses-constantes","text":"Pygame est une biblioth\u00e8que, et en tant que telle, elle est construite \u00e0 partir de plusieurs modules. Les noms de ces modules sont : display mixer draw event image mouse time Il existe alors plusieurs possibilit\u00e9s pour importe pygame Importation compl\u00e8te : import pygame La totalit\u00e9 de la biblioth\u00e8que est alors import\u00e9e, et pour utiliser la fonction update du module display on devra alors utiliser pygame.display.update() . Importation partielle des modules n\u00e9cessaires : from pygame import display Seul le module display est alors import\u00e9, et pour utiliser la fonction update de ce module, on devra alors utiliser display.update() . Importation compl\u00e8te avec import des constantes directement dans l'espace de nommage (conseill\u00e9e) : import pygame from pygame.locals import * Dans ce cas, pour utiliser la constante repr\u00e9sentant la touche espace, au lieu d'utiliser pygame.locals.K_SPACE , on utilisera simplement K_SPACE .","title":"Importer Pygame et ses constantes"},{"location":"Miscellanees/Pygame/Base_pygame/#creation-dune-fenetre-graphique-et-boucle-devenements","text":"Le projet Commen\u00e7ons un petit programme qui nous am\u00e8nera \u00e0 d\u00e9placer un personnage de gauche \u00e0 droite sur un fond d'\u00e9cran, pendant que des balles tombent depuis le haut de l'\u00e9cran \u00e0 diff\u00e9rentes vitesses. Le jeu consistera \u00e0 \u00e9viter que le personnage entre en collision avec les balles, et s'arr\u00eatera d\u00e8s qu'une collision aura lieu. Le premier point est d'afficher une fen\u00eatre graphique d'une dimension donn\u00e9e : \\(640 \\times 480~ pixels^2\\) (oui, en bon prof de maths, je respecte \u00e0 minima les unit\u00e9s...). On utilise le script suivant, dans un fichier nomm\u00e9 dodgeTheBall.py : 1 2 3 4 5 6 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) Analysons le code Dans les deux premi\u00e8res lignes, nous importons pygame en totalit\u00e9 ainsi que les constantes sp\u00e9cifiques dans l'espace de nommage courant. En ligne 4, nous initialisons tous les modules de pygame . En ligne 6, nous appelons ensuite la fonction set_mode() contenue dans le module display de pygame , qui prend en argument un tuple contenant la largeur et la hauteur de la fen\u00eatre voulue (attention, c'est bien un tuple ! pygame.display.set_mode(640, 480) ne fonctionne pas !). Y'a un bug ! La fen\u00eatre reste bloqu\u00e9e et ne se ferme pas sauf si on force l'arr\u00eat du script ! Effectivement, on se retrouve bloqu\u00e9... Il faut rajouter \u00e0 notre code une instruction suppl\u00e9mentaire pour que la fen\u00ebtre se ferme : 1 2 3 4 5 6 7 8 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) pygame . quit () Encore un Et oui ! Notre fen\u00eatre s'ouvre mais se ferme imm\u00e9diatement ! Or nous aimerions qu'elle ne se ferme que sur demande explicite de l'utilisateur, par exemple par un clic sur la croix. C'est l\u00e0 qu'intervient la notion de boucle d'\u00e9v\u00e8nements . Dans un programme classique, en programmation imp\u00e9rative , le programme se d\u00e9roule plus ou moins lin\u00e9airement de la premi\u00e8re ligne \u00e0 la derni\u00e8re. Mais lorsqu'on utilise des interfaces graphiques , on ne peut pr\u00e9voir \u00e0 l'avance le comportement de l'utilisateur, et donc suivre un chemin clairement d\u00e9fini \u00e0 l'avance. C'est pour cette raison qu'on utilise plut\u00f4t le paradigme de la programmation \u00e9v\u00e9nementielle , c'est-\u00e0-dire un paradigme o\u00f9 on pr\u00e9voira l'action de l'utilisateur, mais pas dans un ordre pr\u00e9cis. Chaque action pr\u00e9vue dans la boucle d'\u00e9v\u00e8nements aura un impact pr\u00e9cis. Dans notre cas, nous souhaiterions que la fen\u00eatre reste ouverte tant que l'utilisateur n'a pas exprim\u00e9 le d\u00e9sir de la fermer, soit par l'interm\u00e9diaire de la croix, soit par l'interm\u00e9diaire de la combinaison de touches Alt + F4 . Notion d'\u00e9v\u00e8nements Dans la construction d'interfaces graphiques, on utilise souvent la notion d' \u00e9v\u00e8nements . Un \u00e9v\u00e8nement correspond \u00e0 : un d\u00e9placement de la souris ; le survol d'une zone sp\u00e9cifique de l'\u00e9cran par le pointeur de la souris ; un appui sur une ou plusieurs touches du clavier : le rel\u00e2chement d'une touche de clavier ; un appui ou rel\u00e2chement d'un bouton de la souris ; un \u00e9v\u00e9nement sp\u00e9cifique pr\u00e9vu dans le programme ; un changement de luminosit\u00e9 devant un capteur vid\u00e9o ; ... Ces \u00e9v\u00e8nements sont stock\u00e9s \u00e0 leur apparition dans une file (fifo) de dimension limit\u00e9e , nettoy\u00e9e r\u00e9guli\u00e8rement de ses \u00e9v\u00e8nements les plus anciens. Dans pygame , les \u00e9v\u00e8nements sont des constantes, et celui qui nous int\u00e9resse est l'\u00e9v\u00e8nement QUIT . Nous allons donc parcourir la liste des \u00e9v\u00e8nements pour ensuite pouvoir quitter la fen\u00eatre si celui-ci est exprim\u00e9 : 1 2 3 4 5 6 7 8 9 10 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) for event in pygame . event . get () : if event == QUIT : pygame . quit () L'arnaque : \u00e7a ne marche pas ! On retombe sur notre probl\u00e8me pr\u00e9c\u00e9dent : la fen\u00eatre ne se ferme plus... C'est parce que la file d'\u00e9v\u00e8nements se construit et se nettoie tr\u00e8s rapidement ! Nous n'avons pas le temps de cliquer sur la croix que d\u00e9j\u00e0 le parcours par la boucle for est termin\u00e9 ! Et donc dans ce cas on ne passe jamais par l'instruction pygame.quit() . Il va donc falloir r\u00e9p\u00e9ter la lecture d'\u00e9v\u00e8nements pour pouvoir d\u00e9tecter quand l'utilisateur souhaite fermer sa fen\u00eatre. Boucle d'\u00e9v\u00e8nements Une boucle d'\u00e9v\u00e8nements est une boucle qui se r\u00e9p\u00e8te tant qu'un \u00e9v\u00e8nement pr\u00e9cis ne s'est pas produit. A chaque tour de boucle on va lire la totalit\u00e9 des \u00e9v\u00e8nements enregistr\u00e9s dans la file, et on d\u00e9clenchera la sortie de cette boucle si l'\u00e9v\u00e8nement est trouv\u00e9. Pour notre exemple, nous allons cr\u00e9er une boucle while d\u00e9pendant d'une variable continuer initialis\u00e9e \u00e0 True , que nous basculerons \u00e0 False lorsque l'\u00e9v\u00e8nement QUIT est intercept\u00e9 : Un code fonctionnel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False pygame . quit () Enfin ! Notre fen\u00eatre fonctionne !","title":"Cr\u00e9ation d'une fen\u00eatre graphique et boucle d'\u00e9v\u00e8nements"},{"location":"Miscellanees/Pygame/Base_pygame/#ajout-dimage-de-fond","text":"Image de fond Notre fond noir est un peu d\u00e9primant. Mettons un peu de verdure gr\u00e2ce \u00e0 l'image suivante : T\u00e9l\u00e9chargez cette image sous le nom background.jpg puis ajoutez la ligne suivante en ligne 7 : 7 fond = pygame . image . load ( \"background.jpg\" ) . convert () Bon : mauvaise nouvelle, ce ne sera pas suffisant ! La variable fond n'est qu'une r\u00e9f\u00e9rence \u00e0 une Surface de pygame , retourn\u00e9e par la fonction load() . Une Surface est une classe d'objets d\u00e9finie dans pygame qui poss\u00e8de de nombreux attributs et m\u00e9thodes (cf. la doc ). La m\u00e9thode convert() des objets Surface sert \u00e0 convertir l'image source au format utilis\u00e9 par pygame . Le principe d'affichage de la SDL (la sous-couche logicielle g\u00e9rant les images, le son, etc...) est \u00e0 conna\u00eetre pour bien afficher ses images : fenetre est une surface vide, sur laquelle on va \"coller\", ou \"empiler\" les autres images. Le fond doit donc \u00eatre empil\u00e9 sur la surface vide de la fen\u00eatre , gr\u00e2ce \u00e0 la m\u00e9thode blit() . Cette m\u00e9thode prend une Surface en argument ainsi qu'un tuple repr\u00e9sentant les coordonn\u00e9es du coin sup\u00e9rieur gauche auquel sera coll\u00e9 la Surface argument par rapport \u00e0 la Surface appelante. Syst\u00e8me de coordonn\u00e9es On peut donner comme exemples de tuple de coordonn\u00e9es ceux de l'image suivante : On pourrait donc utiliser le code suivant : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False pygame . quit () Mais pourquoi \u00e7a n'affiche rien ! Parce que quand on blit une Surface , pygame calcule ce qu'il faut mais ne l'ex\u00e9cute pas r\u00e9ellement. Il faut forcer le rafra\u00eechissement de l'\u00e9cran pour y parvenir, par l'interm\u00e9diaire de la commande pygame.display.update() . Comme nous comptons bien faire bouger un personnage sur l'\u00e9cran, et que les mouvements de celui-ci d\u00e9pendront de la boucle d'\u00e9v\u00e8nements, autant mettre imm\u00e9diatement cette commande en fin de boucle, pour que l'image soit syst\u00e9matiquement mise \u00e0 jour. : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () fenetre . blit ( fond ,( 0 , 0 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False pygame . display . update () pygame . quit () Et voil\u00e0 ! 15 lignes de code, et nous voil\u00e0 avec une fen\u00eatre graphique digne de ce nom !","title":"Ajout d'image de Fond"},{"location":"Miscellanees/Pygame/Base_pygame/#ajout-du-sprite-du-joueur","text":"Les sprites Explications Ajoutons maintenant une nouvelle image, celle repr\u00e9sentant le personnage du joueur. Cette image est de dimension \\(100 \\times 100\\) , et nous voudrions la placer tout en bas de l'\u00e9cran, au centre. Les coordonn\u00e9es de son coin sup\u00e9rieur gauche seront donc \\((\\dfrac{640 - 100}{2} ; 480 - 100)\\) . Pour cela, on ajoute hors de la boucle la commande suivante perso = pygame.image.load(\"perso.png\").convert() , suivie de la commande fenetre.blit(perso,(270,380)) (mais apr\u00e8s avoir coll\u00e9 le fond). Code complet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () perso = pygame . image . load ( \"Perso.png\" ) . convert () fenetre . blit ( fond ,( 0 , 0 )) fenetre . blit ( perso , ( 270 , 380 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False pygame . display . update () pygame . quit () Transparence et canal alpha Canal Alpha Le r\u00e9sultat est peu probant. En effet nous voyons un cadre noir autour sprite du personnage. Il va donc falloir ajouter de la transparence \u00e0 cette image. Cette possibilit\u00e9 est offerte par le format png , qui poss\u00e8de un format de couleur bas\u00e9 sur la syst\u00e8me RGB + canal Alpha . Un pixel est donc repr\u00e9sent\u00e9 par 4 octets : Les trois premiers pour les canaux RGB , chacun \u00e9tant donc repr\u00e9sent\u00e9 par un nombre entre 0 et 255 ( sommairement 0 repr\u00e9sentant le canal \u00e9teint, et 255 le canal allum\u00e9 au maximum) ; Le dernier octet pour le canal Alpha , qui va repr\u00e9senter le niveau de transparence du pixel. Ainsi un pixel poss\u00e9dant un canal Alpha \u00e0 \\(0\\) sera totalement transparent, alors qu'avec une valeur de \\(255\\) , il sera totalement opaque. Pygame est bien entendu capable de g\u00e9rer cette transparence, il suffit d'utiliser la m\u00e9thode convert_alpha() \u00e0 la place de la m\u00e9thode convert() . Code complet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () perso = pygame . image . load ( \"Perso.png\" ) . convert_alpha () fenetre . blit ( fond ,( 0 , 0 )) fenetre . blit ( perso , ( 270 , 380 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False pygame . display . update () pygame . quit () Et les autres formats ? Le format png est \u00e0 privil\u00e9gier pour l'utilisation de sprites. cependant il est aussi possible de forcer une couleur d'une image de format quelconque \u00e0 devenir transparente, gr\u00e2ce \u00e0 la m\u00e9thode set_colorkey() utilis\u00e9e comme dans la ligne suivante : image.set_colorkey((255,255,255)) Ici on a rendu la couleur blanche (triplet RGB \\((255, 255, 255)\\) ) transparente pour l'objet image .","title":"Ajout du sprite du joueur"},{"location":"Miscellanees/Pygame/Base_pygame/#deplacement-du-joueur","text":"Cette partie a pour objectif de vous faire comprendre deux points : la notion d'objet Rect de pygame ; l'utilisation d'\u00e9v\u00e8nements claviers. Elle n'est pas formellement correcte, car je n'utilise pas ici de constructeur d'objets et de capteurs d'\u00e9v\u00e8nements. Nous verrons ceci dans la partie suivante. Images et objets Rect Pygame utilises des objets de type Rect pour stocker et manipuler des surfaces rectangulaires. Un objet de type Rect peut \u00eatre cr\u00e9er par une combinaison de valeurs left, top, width, height repr\u00e9sentant respectivement l'abscisse du c\u00f4t\u00e9 gauche du rectangle, l'ordonn\u00e9e du c\u00f4t\u00e9 haut du rectangle, sa largeur puis sa hauteur en pixels. Des objets de type Rect peuvent \u00eatre aussi cr\u00e9\u00e9s \u00e0 partir d'autres objets pygame qui sont soit des Rect , soit poss\u00e8dent un attribut nomm\u00e9 rect (ce qui est le cas des images). Un objet de type Rect poss\u00e8de de nombreux attributs d\u00e9finissant la position et la taille de l'objet : x,y top, left, bottom, right topleft, bottomleft, topright, bottomright midtop, midleft, midbottom, midright center, centerx, centery size, width, height w,h On peut aussi affecter directement tous ces attributs : rect1.right = 10 rect2.center = (20,30) Affecter \u00e0 size, width, height, w ou h change les dimensions du rectangle. Toute les autres affectations d\u00e9placent le rectangle sans le redimmensionner. Notez que certains attributs sont des entiers ( x, y, top, bottom, centerx,... ), et que d'autres sont des tuples d'entiers de dimension 2 ( topleft, bottomright, center,... ) Les m\u00e9thodes ou fonctions `Rect` qui changent la position ou la taille d'un Rect renvoient une nouvelle copie de ce Rect avec les changements effectu\u00e9s . Le Rect original n'est pas modifi\u00e9. Cependant certaines m\u00e9thodes ont une version in-place qui retournent None mais affectent le Rect original. Ces m\u00e9thodes \"in-place\" sont celles pr\u00e9fix\u00e9es par ip_ . La liste compl\u00e8te des m\u00e9thodes et des d\u00e9tails est bien s\u00fbr disponible dans la doc pygame . Les \u00e9v\u00e8nements claviers Lorsque vous coderez une interface graphique, il est probable que vous assignerez des touches clavier aux diff\u00e9rentes actions. Le type d'\u00e9v\u00e9nement cr\u00e9\u00e9 lorsque l'on appuie sur une touche est rep\u00e9r\u00e9 par la constante KEYDOWN , (ou KEYUP au rel\u00e2chement de la touche). Dans la boucle d'\u00e9v\u00e8nement, on pourra alors utiliser une structure conditionnelle telle que if event.type == KEYDOWN: Mais attention, cette condition sera vraie quelque soit la touche press\u00e9e ! Pour d\u00e9finir une seule touche du clavier, vous devrez utilisez en plus event.key , qui d\u00e9termine la touche press\u00e9e, disponible uniquement lors d'un \u00e9v\u00e9nement clavier. Cet event.key peut prendre les valeurs suivantes : Lettres: K_a ... K_z Nombres: K_0 ... K_9 Contr\u00f4les: K_TAB, K_RETURN, K_ESCAPE,... Fl\u00e8ches: K_LEFT, K_UP, K_RIGHT, K_DOWN ... La liste compl\u00e8te des constantes est disponible ici D\u00e9placement du sprite de gauche \u00e0 droite Mise en place du code Bien maintenant nous savons a peu pr\u00eat quoi faire. Commen\u00e7ons par cr\u00e9er un Rect a partir de l'image du personnage, juste apr\u00e8s la ligne de cr\u00e9ation de l'image perso : persoRect = perso.get_rect() Mais attention, on ne vient que de cr\u00e9er le Rect , et il n'a pas de position d\u00e9finie. On va alors effacer la ligne de blit du personnage, et la remplacer par : persoRect.topleft = (270,380) Notre rectangle est ainsi positionn\u00e9 correctement au centre de l'\u00e9cran, en bas. Nous allons modifier ensuite persoRect pour d\u00e9placer le sprite. Nous fixons la vitesse de d\u00e9placement du sprite avec une base de \\(10\\) pixels par tour de boucle. Dans la boucle d'\u00e9v\u00e9nement, nous ajoutons alors les lignes suivantes : if event.type == KEYDOWN : if event.key == K_LEFT : if persoRect.left>=10 : persoRect = persoRect.move(-10,0) if event.key == K_RIGHT : if persoRect.right<=630 : persoRect = persoRect.move(10,0) Nous avons ainsi un d\u00e9placement, mais si vous testez le code \u00e0 ce moment, rien ne se passe. En effet, il ne faut pas oublier de blitter l'image \u00e0 la nouvelle position du Rect . On rajoute donc \u00e0 la fin de la boucle while True la ligne suivante : fenetre.blit(perso, persoRect) Code complet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import pygame from pygame.locals import * pygame . init () fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () perso = pygame . image . load ( \"Perso.png\" ) . convert_alpha () persoRect = perso . get_rect () persoRect . topleft = ( 270 , 380 ) fenetre . blit ( fond ,( 0 , 0 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False if event . type == KEYDOWN : if event . key == K_LEFT : if persoRect . left >= 10 : persoRect = persoRect . move ( - 10 , 0 ) if event . key == K_RIGHT : if persoRect . right <= 630 : persoRect = persoRect . move ( 10 , 0 ) fenetre . blit ( perso , persoRect ) pygame . display . update () pygame . quit () Mais c'est nul ! raisons et corrections Et oui, pour plusieurs raisons : * la page ne se rafra\u00eechit pas totalement, et la trace des anciennes positions du sprite est gard\u00e9e; * il faut r\u00e9-appuyer sur la touche pour re-d\u00e9placer le personnage, le d\u00e9placement n'est pas fluide. Le premier probl\u00e8me vient de la ligne pygame.display.update() , qui ne change que les pixels modifi\u00e9s par rapport au dernier affichage. Une solution simple consiste \u00e0 forcer l'affichage du fond avant le blit du sprite : fenetre . blit ( fond , ( 0 , 0 )) fenetre . blit ( perso , persoRect ) Pour le second probl\u00e8me, une solution simple (mais pas toujours efficace) consiste \u00e0 utiliser la m\u00e9thode set_repeat() du module key ,qui prend en param\u00e8tres : le d\u00e9lai avant de continuer les d\u00e9placements quand la touche reste enfonc\u00e9e (en millisecondes); le temps entre chaque d\u00e9placement. (en millisecondes) Vous devez donc, apr\u00e8s initialisation de pygame placer la ligne : pygame.key.set_repeat(400, 30) Le code complet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import pygame from pygame.locals import * pygame . init () pygame . key . set_repeat ( 400 , 30 ) fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () perso = pygame . image . load ( \"Perso.png\" ) . convert_alpha () persoRect = perso . get_rect () persoRect . topleft = ( 270 , 380 ) fenetre . blit ( fond ,( 0 , 0 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False if event . type == KEYDOWN : if event . key == K_LEFT : if persoRect . left >= 10 : persoRect = persoRect . move ( - 10 , 0 ) if event . key == K_RIGHT : if persoRect . right <= 630 : persoRect = persoRect . move ( 10 , 0 ) fenetre . blit ( fond , ( 0 , 0 )) fenetre . blit ( perso , persoRect ) pygame . display . update () pygame . quit () Une solution plus \u00e9l\u00e9gante, et plus efficace (mais inutile ici) Solution Le probl\u00e8me de l'utilisation de la m\u00e9thode ci-dessus est qu'il est impossible de traiter des appuis sur des combinaisons de touches, puisqu'une seule touche est repr\u00e9sent\u00e9e par l'attribut event.key . Heureusement, les concepteurs de pygame ont pr\u00e9vu une m\u00e9thode bien plus efficace : la m\u00e9thode get_pressed() du module key , qui renvoie un dictionnaire de bool\u00e9ens ayant pour cl\u00e9 la constante repr\u00e9sentant la touche, et pour lequel les valeurs True correspondent aux touches actuellement appuy\u00e9es. On peut alors retirer de la boucle d'\u00e9v\u00e8nements toute la partie concernant les appuis de touches, et les remplacer par : dicKeys = pygame . key . get_pressed () if dicKeys [ K_LEFT ] : if persoRect . left >= 10 : persoRect = persoRect . move ( - 10 , 0 ) if dicKeys [ K_RIGHT ] : if persoRect . right <= 630 : persoRect = persoRect . move ( 10 , 0 ) Le code de remplacement 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import pygame from pygame.locals import * pygame . init () pygame . key . set_repeat ( 400 , 30 ) fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () perso = pygame . image . load ( \"Perso.png\" ) . convert_alpha () persoRect = perso . get_rect () persoRect . topleft = ( 270 , 380 ) fenetre . blit ( fond ,( 0 , 0 )) continuer = True while continuer : for event in pygame . event . get (): if event . type == QUIT : continuer = False dicKeys = pygame . key . get_pressed () if dicKeys [ K_LEFT ] : if persoRect . left >= 10 : persoRect = persoRect . move ( - 10 , 0 ) if dicKeys [ K_RIGHT ] : if persoRect . right <= 630 : persoRect = persoRect . move ( 10 , 0 ) fenetre . blit ( fond , ( 0 , 0 )) fenetre . blit ( perso , persoRect ) pygame . display . update () pygame . quit ()","title":"D\u00e9placement du joueur"},{"location":"Miscellanees/Pygame/Base_pygame/#creation-dune-classe-dobjets-balle","text":"classe Balle Interface Sachant que plusieurs balles vont tomber simultan\u00e9ment, nous allons construire une classe d'objets pour repr\u00e9senter ces balles. Chaque balle sera repr\u00e9sent\u00e9e par une image , qui devra donc \u00eatre associ\u00e9e \u00e0 un rectangle . Chaque balle aura une position, qui sera donn\u00e9e originellement par son centre . Elle aura par ailleurs une vitesse , dont la valeur de d\u00e9part sera tir\u00e9e al\u00e9atoirement entre 1 et 5. Un certain nombre d'actions seront utilis\u00e9es sur ou par cette balle : elle se d\u00e9placera d'un nombre de pixels \u00e9gal \u00e0 sa vitesse ; on testera sa collision avec le joueur, en renvoyant un bool\u00e9en ; et bien sur on l' affichera dans la fenetre courante. On repr\u00e9sente donc la classe balle par l'interface suivante : Nous impl\u00e9mentons de cette classe dans un fichier balle.py . Le code est donn\u00e9 dans l'onglet ci contre, et ne n\u00e9cessite que peu de commentaires, \u00e0 part pour la m\u00e9thode collision(self,targetRect) . Dans le cadre de ce tutoriel, nous utiliserons la m\u00e9thode colliderect des objets Rect . Cette m\u00e9thode renvoie True si le rectangle de la balle est en collision avec le rectangle pass\u00e9 en argument et False sinon. Deux rectangles sont en collision si ils ont une partie commune. Pour les amateurs de hitbox plus pr\u00e9cises, il faudra voir du c\u00f4t\u00e9 de la classe Mask de pygame , qui utilise le canal alpha ou bien une cl\u00e9 colorim\u00e9trique pour d\u00e9tecter des collisions au pixel pr\u00e8s. Code du fichier balle.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import pygame from random import randint class Balle : def __init__ ( self , image , center ) : \"\"\" Initialisation d'un objet de classe Balle a partir de deux arguments : - image est l'adresse relative ou absolue de l'image voulue pour l'objet ; - center est un tuple de deux entiers donnant la position du centre de la balle lors de sa cr\u00e9ation.\"\"\" self . image = pygame . image . load ( image ) . convert_alpha () self . rect = self . image . get_rect () self . rect . center = center self . vitesse = randint ( 1 , 5 ) def affiche ( self , fenetre ) : fenetre . blit ( self . image , self . rect ) def deplace ( self ) : self . rect = self . rect . move ( 0 , self . vitesse ) def collision ( self , targetRect ) : return self . rect . colliderect ( targetRect )","title":"Cr\u00e9ation d'une classe d'objets \"Balle\""},{"location":"Miscellanees/Pygame/Base_pygame/#apparition-des-objets-balle-et-gestion-des-collisions","text":"\u00c9tablissons les r\u00e8gles On pose les r\u00e8gles suivantes concernant les balles : elles ne peuvent pas \u00eatre plus de 10 simultan\u00e9ment ; elles sont construites \u00e0 partir de l'image suivante, de dimension \\(50 \\times 50\\) : elles apparaissent avec une abscisse al\u00e9atoire entre 25 et 455 (pour ne pas d\u00e9passer de l'\u00e9cran ; elles disparaissent une fois compl\u00e8tement sorties de l'\u00e9cran ; le jeu s'arr\u00eate et ferme la fen\u00eatre d\u00e8s que le personnage est touch\u00e9 par une balle. Codons ! Description Commen\u00e7ons d\u00e9j\u00e0 par importer les objets de types Balle depuis balle.py , et importons aussi au passage la fonction randint du module random dont nous aurons besoin pour les tirages al\u00e9atoires des positions de d\u00e9part. from balle import Balle from random import randint Les balles existantes seront stock\u00e9es dans une liste python tout ce qui est de plus classique. Nous cr\u00e9ons donc une variable listeBalles au d\u00e9part vide, juste avant la boucle while continuer : . listeBalles = [] Ensuite il faut cr\u00e9er un syst\u00e8me d'apparition des balles. Pour cela, dans la boucle while continuer : , nous allons \u00e0 chaque tour de boucle ajouter une balle, si la longueur de la liste est inf\u00e9rieure \u00e0 10. Mais ce ne sera pas suffisant ! En effet, la boucle tourne tr\u00e8s vite ! Plusieurs centaines de fois voir plusieurs milliers de fois par seconde . Donc dans ce cas, le joueur aurait l'impression que les 10 balles arrivent de mani\u00e8re simultan\u00e9es. Il faut donc introduire un syst\u00e8me permettant de limiter ces apparitions, tout en gardant un c\u00f4t\u00e9 al\u00e9atoire pour le jeu. On utilisera alors les lignes suivantes : if len ( listeBalles ) < 10 and randint ( 1 , 500 ) <= 10 : listeBalles . append ( Balle ( 'golfBall.png' ,( randint ( 25 , 455 ), - 25 ))) Les valeurs pr\u00e9sentes dans la condition randint ont \u00e9t\u00e9 test\u00e9e sur mon PC, mais elles peuvent \u00eatre modifi\u00e9es selon la puissance de votre machine. Voil\u00e0, les objets de type Balle sont cr\u00e9es selon les conditions que nous avons pos\u00e9es au d\u00e9part. Reste \u00e0 les afficher, les d\u00e9placer et les faire dispara\u00eetre le cas \u00e9ch\u00e9ant. Pour les d\u00e9placer et les afficher, pla\u00e7ons nous juste apr\u00e8s le blit de l'image de fond. Nous parcourons alors la liste des balles et leur appliquons successivement les m\u00e9thodes deplace() et affiche() , en donnant comme argument la fen\u00eatre courante pour l'affichage : for ball in listeBalles : ball . deplace () ball . affiche ( fenetre ) Probl\u00e8me : nos balles disparaissent de l'\u00e9cran, mais de nouvelles n'apparaissent plus. C'est normal, nous avons satur\u00e9 la variable listeBalles qui ne peut contenir plus de 10 objets. Il faut donc faire dispara\u00eetre les objets de la liste quand ils sortent de l'\u00e9cran. for ball in listeBalles : ball . deplace () if ball . rect . top >= 480 : listeBalles . remove ( ball ) else : ball . affiche ( fenetre ) Il ne nous reste plus qu'\u00e0 g\u00e9rer la fin du jeu : quand une balle entre en collision avec le joueur, nous basculons la variable continuer \u00e0 False pour arr\u00eater la boucle while : for ball in listeBalles : ball . deplace () if ball . rect . top >= 480 : listeBalles . remove ( ball ) else : if ball . collision ( persoRect ) : continuer = False ball . affiche ( fenetre ) Voil\u00e0, le contrat est rempli. Bien entendu ce n'est qu'un d\u00e9but de jeu, et il reste beaucoup de points \u00e0 am\u00e9liorer. Mais vous avez maintenant les bases pour vous permettre de r\u00e9aliser des jeux d'arcades classiques. le code complet du fichier dodegTheBall.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import pygame from pygame.locals import * from balle import Balle from random import randint pygame . init () pygame . key . set_repeat ( 400 , 30 ) fenetre = pygame . display . set_mode (( 640 , 480 )) fond = pygame . image . load ( \"background.jpg\" ) . convert () perso = pygame . image . load ( \"Perso.png\" ) . convert_alpha () persoRect = perso . get_rect () persoRect . topleft = ( 270 , 380 ) fenetre . blit ( fond ,( 0 , 0 )) continuer = True listeBalles = [] while continuer : if len ( listeBalles ) < 10 and randint ( 1 , 500 ) <= 10 : listeBalles . append ( Balle ( 'golfBall.png' ,( randint ( 25 , 455 ), - 25 ))) for event in pygame . event . get (): if event . type == QUIT : continuer = False if event . type == KEYDOWN : if event . key == K_LEFT : if persoRect . left >= 10 : persoRect = persoRect . move ( - 10 , 0 ) if event . key == K_RIGHT : if persoRect . right <= 630 : persoRect = persoRect . move ( 10 , 0 ) fenetre . blit ( fond , ( 0 , 0 )) for ball in listeBalles : ball . deplace () if ball . rect . top >= 480 : listeBalles . remove ( ball ) else : if ball . collision ( persoRect ) : continuer = False ball . affiche ( fenetre ) fenetre . blit ( perso , persoRect ) pygame . display . update () pygame . time . wait ( 10 ) pygame . quit ()","title":"Apparition des objets Balle et gestion des collisions"},{"location":"Miscellanees/Pygame/InstallationPygame/","text":"Installation de Pygame dans Thonny C'est quoi Pygame Pygame Pygame est une biblioth\u00e8que (= un ensemble de modules), libre, multiplate-forme, qui facilite le d\u00e9veloppement de jeux vid\u00e9o temps r\u00e9el avec le langage de programmation Python. \"Construite sur la biblioth\u00e8que SDL , elle permet de programmer la partie multim\u00e9dia (graphismes, son et entr\u00e9es au clavier, \u00e0 la souris ou au joystick), sans se heurter aux difficult\u00e9s des langages de bas niveaux comme le C et ses d\u00e9riv\u00e9s. Cela se fonde sur la supposition que la partie multim\u00e9dia, souvent la plus contraignante \u00e0 programmer dans un tel jeu, est suffisamment ind\u00e9pendante de la logique m\u00eame du jeu pour qu'on puisse utiliser un langage de haut niveau (en l'occurrence le Python) pour la structure du jeu. Pygame, en plus d'adapter la SDL au Python, fournit \u00e9galement un petit nombre de fonctions sp\u00e9cifiques au d\u00e9veloppement de jeux. On peut aussi remarquer que Pygame n'est plus utilis\u00e9e exclusivement pour des jeux vid\u00e9o, mais \u00e9galement pour des applications diverses n\u00e9cessitant du graphisme. \" wikipedia . Depuis Octobre 2020, apr\u00e8s 20 ans d'existence, pygame est pass\u00e9 en version 2, et c'est une tr\u00e8s bonne nouvelle ! O\u00f9 trouver de la documentation ? La documentation en fran\u00e7ais de Pygame est \u00e0 la fois assez limit\u00e9e (il n'y a pas un site de r\u00e9f\u00e9rence) et en m\u00eame temps tr\u00e8s touffue (on trouve des dizaines de vid\u00e9os tutorielles sur Youtube). On trouvera cependant l'excellent tutoriel situ\u00e9 autrefois sur le site du z\u00e9ro (c'est une copie de mauvaise qualit\u00e9 graphique, mais le document en lui m\u00eame est excellent). Pour les plus anglophones d'entre-vous (mais vous l'\u00eates tous \ud83d\ude1b ), vous trouverez toutes les informations n\u00e9cessaires dans la documentation de pygame . Installation du module dans Thonny How to Dans Thonny, ouvrez le menu Tools puis Manage Packages : Dans la nouvelle fen\u00eatre, tapez pygame puis Search on PyPI : S\u00e9lectionnez le module pygame dans la fen\u00eatre de r\u00e9sultats : Cliquez enfin sur Install : Une fois ces manipulations termin\u00e9es, vous pouvez tester l'installation de Pygame dans le shell de Thonny . Si vous avez un message de bienvenue tel que dans l'image ci-contre, Pygame est install\u00e9. Sinon vous devriez recommencer l'installation, ou bien chercher l'erreur rencontr\u00e9e sur StackOverflow . Installation hors de Thonny Si vous n'utilisez pas d' environnements virtuel python (c'est une tr\u00e8s mauvaise id\u00e9e), vous pouvez toujours utiliser la commande suivante pour installer pygame : python3 -m pip install pygame Si vous utilisez un venv python, vous savez d\u00e9j\u00e0 probablement quoi faire !","title":"Installation"},{"location":"Miscellanees/Pygame/InstallationPygame/#installation-de-pygame-dans-thonny","text":"","title":"Installation de Pygame dans Thonny"},{"location":"Miscellanees/Pygame/InstallationPygame/#cest-quoi-pygame","text":"Pygame Pygame est une biblioth\u00e8que (= un ensemble de modules), libre, multiplate-forme, qui facilite le d\u00e9veloppement de jeux vid\u00e9o temps r\u00e9el avec le langage de programmation Python. \"Construite sur la biblioth\u00e8que SDL , elle permet de programmer la partie multim\u00e9dia (graphismes, son et entr\u00e9es au clavier, \u00e0 la souris ou au joystick), sans se heurter aux difficult\u00e9s des langages de bas niveaux comme le C et ses d\u00e9riv\u00e9s. Cela se fonde sur la supposition que la partie multim\u00e9dia, souvent la plus contraignante \u00e0 programmer dans un tel jeu, est suffisamment ind\u00e9pendante de la logique m\u00eame du jeu pour qu'on puisse utiliser un langage de haut niveau (en l'occurrence le Python) pour la structure du jeu. Pygame, en plus d'adapter la SDL au Python, fournit \u00e9galement un petit nombre de fonctions sp\u00e9cifiques au d\u00e9veloppement de jeux. On peut aussi remarquer que Pygame n'est plus utilis\u00e9e exclusivement pour des jeux vid\u00e9o, mais \u00e9galement pour des applications diverses n\u00e9cessitant du graphisme. \" wikipedia . Depuis Octobre 2020, apr\u00e8s 20 ans d'existence, pygame est pass\u00e9 en version 2, et c'est une tr\u00e8s bonne nouvelle !","title":"C'est quoi Pygame"},{"location":"Miscellanees/Pygame/InstallationPygame/#ou-trouver-de-la-documentation","text":"La documentation en fran\u00e7ais de Pygame est \u00e0 la fois assez limit\u00e9e (il n'y a pas un site de r\u00e9f\u00e9rence) et en m\u00eame temps tr\u00e8s touffue (on trouve des dizaines de vid\u00e9os tutorielles sur Youtube). On trouvera cependant l'excellent tutoriel situ\u00e9 autrefois sur le site du z\u00e9ro (c'est une copie de mauvaise qualit\u00e9 graphique, mais le document en lui m\u00eame est excellent). Pour les plus anglophones d'entre-vous (mais vous l'\u00eates tous \ud83d\ude1b ), vous trouverez toutes les informations n\u00e9cessaires dans la documentation de pygame .","title":"O\u00f9 trouver de la documentation ?"},{"location":"Miscellanees/Pygame/InstallationPygame/#installation-du-module-dans-thonny","text":"How to Dans Thonny, ouvrez le menu Tools puis Manage Packages : Dans la nouvelle fen\u00eatre, tapez pygame puis Search on PyPI : S\u00e9lectionnez le module pygame dans la fen\u00eatre de r\u00e9sultats : Cliquez enfin sur Install : Une fois ces manipulations termin\u00e9es, vous pouvez tester l'installation de Pygame dans le shell de Thonny . Si vous avez un message de bienvenue tel que dans l'image ci-contre, Pygame est install\u00e9. Sinon vous devriez recommencer l'installation, ou bien chercher l'erreur rencontr\u00e9e sur StackOverflow .","title":"Installation du module dans Thonny"},{"location":"Miscellanees/Pygame/InstallationPygame/#installation-hors-de-thonny","text":"Si vous n'utilisez pas d' environnements virtuel python (c'est une tr\u00e8s mauvaise id\u00e9e), vous pouvez toujours utiliser la commande suivante pour installer pygame : python3 -m pip install pygame Si vous utilisez un venv python, vous savez d\u00e9j\u00e0 probablement quoi faire !","title":"Installation hors de Thonny"},{"location":"NSI/Terminale/home/","text":"Le programme Documents officiels Le programme de Terminale NSI se trouve ici . Cependant certains ajustements ont \u00e9t\u00e9 effectu\u00e9s dans le BO du 29 juillet 2021 . Pr\u00e9vision de progression annuelle 2021-2022 Cette progression n'est valable que pour les \u00e9l\u00e8ves du Lyc\u00e9e Pavie de Guingamp, et est sujette \u00e0 modifications au cours de l'ann\u00e9e... Th\u00e8me Chapitre Dur\u00e9e Estim\u00e9e Dates pr\u00e9vues Dates effectives Remarques Structures de donn\u00e9es Modularit\u00e9 et POO 2 semaine 02/09 -> 16/09 Langages et programmation R\u00e9cursivit\u00e9 2 semaines 16/09 -> 30/09 Les \u00e9preuves Epreuve \u00e9crite Pour l'instant, aucune date officielle n'est tomb\u00e9e concernant l'\u00e9preuve \u00e9crite de NSI pour la session de Bac 2022. Nous pouvons cependant- supposer qu'elle aura lieu en Mars . Epreuve pratique Pour l'instant, aucune date officielle n'est tomb\u00e9e concernant l'\u00e9preuve pratique de NSI pour la session de Bac 2022. Nous pouvons cependant- supposer qu'elle aura lieu en Mars .","title":"Pr\u00e9sentation"},{"location":"NSI/Terminale/home/#le-programme","text":"","title":"Le programme"},{"location":"NSI/Terminale/home/#documents-officiels","text":"Le programme de Terminale NSI se trouve ici . Cependant certains ajustements ont \u00e9t\u00e9 effectu\u00e9s dans le BO du 29 juillet 2021 .","title":"Documents officiels"},{"location":"NSI/Terminale/home/#prevision-de-progression-annuelle-2021-2022","text":"Cette progression n'est valable que pour les \u00e9l\u00e8ves du Lyc\u00e9e Pavie de Guingamp, et est sujette \u00e0 modifications au cours de l'ann\u00e9e... Th\u00e8me Chapitre Dur\u00e9e Estim\u00e9e Dates pr\u00e9vues Dates effectives Remarques Structures de donn\u00e9es Modularit\u00e9 et POO 2 semaine 02/09 -> 16/09 Langages et programmation R\u00e9cursivit\u00e9 2 semaines 16/09 -> 30/09","title":"Pr\u00e9vision de progression annuelle 2021-2022"},{"location":"NSI/Terminale/home/#les-epreuves","text":"","title":"Les \u00e9preuves"},{"location":"NSI/Terminale/home/#epreuve-ecrite","text":"Pour l'instant, aucune date officielle n'est tomb\u00e9e concernant l'\u00e9preuve \u00e9crite de NSI pour la session de Bac 2022. Nous pouvons cependant- supposer qu'elle aura lieu en Mars .","title":"Epreuve \u00e9crite"},{"location":"NSI/Terminale/home/#epreuve-pratique","text":"Pour l'instant, aucune date officielle n'est tomb\u00e9e concernant l'\u00e9preuve pratique de NSI pour la session de Bac 2022. Nous pouvons cependant- supposer qu'elle aura lieu en Mars .","title":"Epreuve pratique"},{"location":"NSI/Terminale/C01/Exceptions/","text":"Gestion des exceptions Un exemple d'erreur \u00e0 ne pas commettre Utilisation malheureuse d'un module Reprenons le module secondDegre.py , mais en temps qu'utilisateur. Nous connaissons l'interface qui nous a \u00e9t\u00e9 fournie par l'auteur. Pour tester le module nous lan\u00e7ons le script suivant, nomm\u00e9 testModule.py , et situ\u00e9 dans le m\u00eame dossier que secondDegre.py : import secondDegre as sD p = input ( \"Donnez les coefficients du polynome s\u00e9par\u00e9s par des virgules :\" ) p = tuple ( map ( float , p . split ( \",\" ))) p = sD . polynome ( p ) print ( sD . tangente ( p , 3 )) Un probl\u00e8me ? Copiez-collez le code ci-dessus dans un fichier testModule.py , puis ex\u00e9cutez-le en saisissant : 3,4,5 ; \"trois\",4,5 3,4,5,6 0,3,4 Dans chacun des cas, qu'obtient-on en sortie ? Pourquoi ? Solution 3,4,5 La sortie est : `y = 22.0(x-3) + 44.0` qui est correcte. \"trois\",4,5 La sortie renvoie une erreur de type ValueError , mais c'est celle lev\u00e9e dans le premier if , car un \u00e9l\u00e9ment du tuple n'est pas du bon type. 3,4,5,6 La sortie renvoie une erreur de type ValueError , mais c'est celle lev\u00e9e dans le premier if , car le tuple donn\u00e9 n'est pas de la bonne taille. 0,3,4 La sortie renvoie une erreur de type ValueError , mais c'est celle lev\u00e9e dans le deuxi\u00e8me if , car le tuple donn\u00e9 ne correspond pas \u00e0 un polyn\u00f4me de degr\u00e9 2. Lever les bonnes erreurs Dans l'exemple pr\u00e9c\u00e9dent, les trois erreurs, pourtant tr\u00e8s diff\u00e9rentes, sont signal\u00e9es par le m\u00eame message. L'utilisateur, qui lui ne conna\u00eet pas l'impl\u00e9mentation, ne peut donc pas savoir d'o\u00f9 provient son erreur** (ce qui peut donner des s\u00e9ances de d\u00e9buggage particuli\u00e8rement frustrantes). Il est donc n\u00e9cessaire de pr\u00e9ciser mieux les erreurs commises par l'utilisateur, pour qu'il n'ait pas \u00e0 ses pr\u00e9occuper des d\u00e9tails d'impl\u00e9mentation. Il est par exemple possible de rajouter un message lorsque l'erreur est lev\u00e9e, en la passant en param\u00e8tre directement dans l'instruction ValueError() : def polynome ( t ) : a , b , * c = t if len ( c ) > 1 : raise ValueError ( \"length of tuple argument greater than 3\" ) if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or not ( isinstance ( * c ,( int , float ))) : raise ValueError ( \"argment Error : argument must be a tuple integers or float\" ) if a == 0 : raise ValueError ( \"First element of tuple must not be 0\" ) return t Tyes d'exceptions Voici quelques exceptions courantes, et leurs utilisations Exception Contexte NameError acc\u00e8s \u00e0 une variable inexistante dans l'espace de nom courant IndexError acc\u00e8s \u00e0 un indice invalide d'une liste, d'un tuple, d'une chaine de caract\u00e8res... KeyError acc\u00e8s \u00e0 une cl\u00e9 inexistante d'un dictionnaire ZeroDivisionError division par z\u00e9ro TypeError op\u00e9ration appliqu\u00e9es \u00e0 un ou des objets incompatibles Lever des exceptions Une exception peut \u00eatre lev\u00e9e (c'est-\u00e0-dire volontairement d\u00e9clench\u00e9e) par l'interm\u00e9diaire de l'instruction raise . Dans ce cas le programme est interrompu , et la pile d'erreurs est renvoy\u00e9es dans le terminal \u00e0 l'utilisateur. Corriger le code\"\" Malgr\u00e9 nos corrections, il reste plusieurs possibilit\u00e9s d'erreurs dans l'utilisation de la fonction polynome(t) . Quelles sont-elles et comment les corriger pour lever une exception explicite ? Solution Ex\u00e9cution de polynome((2,3)) ou polynome((4)) Que se passe-t-il lorsqu'on utilise la fonction polynome avec un tuple de 1 ou 2 \u00e9l\u00e9ments ? Dans le cas d'un seul \u00e9l\u00e9ment, l'erreur ressortie est : a,b,*c = t TypeError: cannot unpack non-iterable int object Dans le cas de deux \u00e9l\u00e9ments, l'erreur lev\u00e9e est : ) or not(isinstance(*c,(int, float))) : TypeError: isinstance expected 2 arguments, got 1 Dans les deux cas, on voit appara\u00eetre les d\u00e9tails d'impl\u00e9mentation du code de la fonction, qui sont peu clairs en particulier pour le cas n\u00b02. Ex\u00e9cution de polynome(3,4,5) Une erreur possible, et que vous avez probablement commise, est celle de passer non pas un seul argument sous la forme d'un tuple (ou d'une liste) mais de multiples param\u00e8tres. Cette erreur d\u00e9clenche alors l'exception TypeError car les trois arguments pass\u00e9s ne sont pas du bon type. Une correction possible Le code suivant est une solution possible (certainement perfectible) \u00e0 la lev\u00e9e d'erreurs plus explicites : def polynome ( * t ) : try : if len ( t ) == 1 : # si on passe un tuple ou un tableau (1,2,3), # *t le convertit en [(1,2,3)] t = t [ 0 ] # d'o\u00f9 cette ligne a , b , * c = t #Puis on unpack, c \u00e9tant une liste \u00e9ventuellement vide except TypeError : raise TypeError ( \"Must pass three argument or a tuple of 3 element.\" ) if len ( c ) != 1 : # si c est vide ou contient au moins 2 \u00e9l\u00e9ments raise ValueError ( \"Bad Number of argument.\" ) if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or not ( isinstance ( * c ,( int , float ))) : raise TypeError ( \"argment Error : argument must be a tuple of integers or floats.\" ) if a == 0 : raise ValueError ( \"First element of tuple must not be 0.\" ) return t Intercepter des exceptions Vous avez constat\u00e9 dans la solution pr\u00e9c\u00e9dente un bloc que nous n'avons encore jamais utilis\u00e9 : try : if len ( t ) == 1 : t = t [ 0 ] a , b , * c = t except TypeError : raise TypeError ( \"Must pass three argument or a tuple of 3 element.\" ) On a ici l'utilisation d'une structure sp\u00e9ciale : l'interception d'ereurs. Interception des exceptions Il arrive souvent en programmation que l'on doive utiliser une instructions oui une s\u00e9rie d'instruction dont on sait \u00e0 l'avance qu'elle peuvent g\u00e9n\u00e9rer des erreurs. La structure suivante est l\u00e0 pour \u00e7a : try : # Bloc try except error : # Bloc except Le code du bloc try va \u00eatre ex\u00e9cut\u00e9, et si une erreur du type fournie en argument de l'instruction except est lev\u00e9e, alors le code du bloc except est ex\u00e9cut\u00e9. Exemple : En premi\u00e8re nous avons vu l'importance de rendre parfois un code dumbproof , et que cela g\u00e9n\u00e8rais parfois de nombreuses difficult\u00e9s. Le simple fait de coder une fonction demandant \u00e0 un utilisateur de saisir un nombre entier entre 1 et 10 inclus pouvaiet rapidement p\u00e9nible \u00e0 \u00e9crire. Les deux onglets ci-dessous donnent deux versions d'une fonction permettant de r\u00e9aliser cette fonction, la version utilis\u00e9e en premi\u00e8re, et celle levant des excpetions. Version avec des structures conditionnelles def askIntFrom1To10 () : while True : nb = input ( \"Entrez un entier entre 1 et 10 :\" ) if nb . isnumeric () and \".\" not in ( nb ) : nb = int ( nb ) if 1 <= nb and nb <= 10 : return nb else : print ( \"L'entier saisi n'est pas entre 1 et 10. Veuillez recommencer\" ) else : print ( \"Ce n'est pas un entier, veuillez recommencer !\" ) Version avec interception d'erreurs def askIntFrom1To10 () : while True : try : nb = int ( input ( \"Entrez un entier entre 1 et 10 :\" )) if 1 <= nb and nb <= 10 : return nb else : print ( \"L'entier saisi n'est pas entre 1 et 10. Veuillez recommencer\" ) except ValueError : print ( \"Ce n'est pas un entier, veuillez recommencer !\" ) Exercice Evidemment, la diff\u00e9rence ne saute pas vraiment aux yeux... Pourquoi faire tout un plat d'une seule ligne gagn\u00e9e ? Essayez donc, pour chacune des 2 fonctions pr\u00e9c\u00e9dentes, avec les chaines de caract\u00e8res suivantes : \u00bd 3\u00b2 R\u00e9ponse En fait le probl\u00e8me provient de la m\u00e9thode isnumeric() , dont on ne contr\u00f4le pas vraiment le fonctionnement. On sait que cette m\u00e9thode permet de v\u00e9rifier si une chaine de caract\u00e8res est bien constitu\u00e9e uniquement de caract\u00e8res num\u00e9riques. Mais sans lire r\u00e9ellement la documentation, qui peut se douter que les fractions d\u00e9finies dans la table utf8 , ainsi que les caract\u00e8res en exposant et en indice *, sont consid\u00e9r\u00e9s comme des valeurs num\u00e9riques. L'int\u00e9r\u00eat du bloc try est qu'il se d\u00e9clenchera d\u00e8s qu'il y aura une exception lev\u00e9e. Et cette exception a peu de chance de se produire dans le bloc if / else . La fonction devient dumbproof (mais si vous r\u00e9ussissez \u00e0 d\u00e9clencher une erreur bloquante, signalez-le moi !!). Enchainer les interceptions Il est aussi possible d'avoir plusieurs blocs except successifs, en utilisant : try : # Bloc try except error1 : # Bloc except1 except error2 : # Bloc except2 ... Etendre la gestion des exceptions Il existe de nombreuses autres possibilit\u00e9s utilisant la lev\u00e9e d'exceptions, mais elles d\u00e9passent largement le programme de Terminale. Les plus curieux parmi vous pourront toujours aller lire la doc Python \", qui reste la r\u00e9f\u00e9rence absolue...","title":"Exceptions"},{"location":"NSI/Terminale/C01/Exceptions/#gestion-des-exceptions","text":"","title":"Gestion des exceptions"},{"location":"NSI/Terminale/C01/Exceptions/#un-exemple-derreur-a-ne-pas-commettre","text":"Utilisation malheureuse d'un module Reprenons le module secondDegre.py , mais en temps qu'utilisateur. Nous connaissons l'interface qui nous a \u00e9t\u00e9 fournie par l'auteur. Pour tester le module nous lan\u00e7ons le script suivant, nomm\u00e9 testModule.py , et situ\u00e9 dans le m\u00eame dossier que secondDegre.py : import secondDegre as sD p = input ( \"Donnez les coefficients du polynome s\u00e9par\u00e9s par des virgules :\" ) p = tuple ( map ( float , p . split ( \",\" ))) p = sD . polynome ( p ) print ( sD . tangente ( p , 3 )) Un probl\u00e8me ? Copiez-collez le code ci-dessus dans un fichier testModule.py , puis ex\u00e9cutez-le en saisissant : 3,4,5 ; \"trois\",4,5 3,4,5,6 0,3,4 Dans chacun des cas, qu'obtient-on en sortie ? Pourquoi ? Solution 3,4,5 La sortie est : `y = 22.0(x-3) + 44.0` qui est correcte. \"trois\",4,5 La sortie renvoie une erreur de type ValueError , mais c'est celle lev\u00e9e dans le premier if , car un \u00e9l\u00e9ment du tuple n'est pas du bon type. 3,4,5,6 La sortie renvoie une erreur de type ValueError , mais c'est celle lev\u00e9e dans le premier if , car le tuple donn\u00e9 n'est pas de la bonne taille. 0,3,4 La sortie renvoie une erreur de type ValueError , mais c'est celle lev\u00e9e dans le deuxi\u00e8me if , car le tuple donn\u00e9 ne correspond pas \u00e0 un polyn\u00f4me de degr\u00e9 2. Lever les bonnes erreurs Dans l'exemple pr\u00e9c\u00e9dent, les trois erreurs, pourtant tr\u00e8s diff\u00e9rentes, sont signal\u00e9es par le m\u00eame message. L'utilisateur, qui lui ne conna\u00eet pas l'impl\u00e9mentation, ne peut donc pas savoir d'o\u00f9 provient son erreur** (ce qui peut donner des s\u00e9ances de d\u00e9buggage particuli\u00e8rement frustrantes). Il est donc n\u00e9cessaire de pr\u00e9ciser mieux les erreurs commises par l'utilisateur, pour qu'il n'ait pas \u00e0 ses pr\u00e9occuper des d\u00e9tails d'impl\u00e9mentation. Il est par exemple possible de rajouter un message lorsque l'erreur est lev\u00e9e, en la passant en param\u00e8tre directement dans l'instruction ValueError() : def polynome ( t ) : a , b , * c = t if len ( c ) > 1 : raise ValueError ( \"length of tuple argument greater than 3\" ) if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or not ( isinstance ( * c ,( int , float ))) : raise ValueError ( \"argment Error : argument must be a tuple integers or float\" ) if a == 0 : raise ValueError ( \"First element of tuple must not be 0\" ) return t","title":"Un exemple d'erreur \u00e0 ne pas commettre"},{"location":"NSI/Terminale/C01/Exceptions/#tyes-dexceptions","text":"Voici quelques exceptions courantes, et leurs utilisations Exception Contexte NameError acc\u00e8s \u00e0 une variable inexistante dans l'espace de nom courant IndexError acc\u00e8s \u00e0 un indice invalide d'une liste, d'un tuple, d'une chaine de caract\u00e8res... KeyError acc\u00e8s \u00e0 une cl\u00e9 inexistante d'un dictionnaire ZeroDivisionError division par z\u00e9ro TypeError op\u00e9ration appliqu\u00e9es \u00e0 un ou des objets incompatibles Lever des exceptions Une exception peut \u00eatre lev\u00e9e (c'est-\u00e0-dire volontairement d\u00e9clench\u00e9e) par l'interm\u00e9diaire de l'instruction raise . Dans ce cas le programme est interrompu , et la pile d'erreurs est renvoy\u00e9es dans le terminal \u00e0 l'utilisateur. Corriger le code\"\" Malgr\u00e9 nos corrections, il reste plusieurs possibilit\u00e9s d'erreurs dans l'utilisation de la fonction polynome(t) . Quelles sont-elles et comment les corriger pour lever une exception explicite ? Solution Ex\u00e9cution de polynome((2,3)) ou polynome((4)) Que se passe-t-il lorsqu'on utilise la fonction polynome avec un tuple de 1 ou 2 \u00e9l\u00e9ments ? Dans le cas d'un seul \u00e9l\u00e9ment, l'erreur ressortie est : a,b,*c = t TypeError: cannot unpack non-iterable int object Dans le cas de deux \u00e9l\u00e9ments, l'erreur lev\u00e9e est : ) or not(isinstance(*c,(int, float))) : TypeError: isinstance expected 2 arguments, got 1 Dans les deux cas, on voit appara\u00eetre les d\u00e9tails d'impl\u00e9mentation du code de la fonction, qui sont peu clairs en particulier pour le cas n\u00b02. Ex\u00e9cution de polynome(3,4,5) Une erreur possible, et que vous avez probablement commise, est celle de passer non pas un seul argument sous la forme d'un tuple (ou d'une liste) mais de multiples param\u00e8tres. Cette erreur d\u00e9clenche alors l'exception TypeError car les trois arguments pass\u00e9s ne sont pas du bon type. Une correction possible Le code suivant est une solution possible (certainement perfectible) \u00e0 la lev\u00e9e d'erreurs plus explicites : def polynome ( * t ) : try : if len ( t ) == 1 : # si on passe un tuple ou un tableau (1,2,3), # *t le convertit en [(1,2,3)] t = t [ 0 ] # d'o\u00f9 cette ligne a , b , * c = t #Puis on unpack, c \u00e9tant une liste \u00e9ventuellement vide except TypeError : raise TypeError ( \"Must pass three argument or a tuple of 3 element.\" ) if len ( c ) != 1 : # si c est vide ou contient au moins 2 \u00e9l\u00e9ments raise ValueError ( \"Bad Number of argument.\" ) if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or not ( isinstance ( * c ,( int , float ))) : raise TypeError ( \"argment Error : argument must be a tuple of integers or floats.\" ) if a == 0 : raise ValueError ( \"First element of tuple must not be 0.\" ) return t","title":"Tyes d'exceptions"},{"location":"NSI/Terminale/C01/Exceptions/#intercepter-des-exceptions","text":"Vous avez constat\u00e9 dans la solution pr\u00e9c\u00e9dente un bloc que nous n'avons encore jamais utilis\u00e9 : try : if len ( t ) == 1 : t = t [ 0 ] a , b , * c = t except TypeError : raise TypeError ( \"Must pass three argument or a tuple of 3 element.\" ) On a ici l'utilisation d'une structure sp\u00e9ciale : l'interception d'ereurs. Interception des exceptions Il arrive souvent en programmation que l'on doive utiliser une instructions oui une s\u00e9rie d'instruction dont on sait \u00e0 l'avance qu'elle peuvent g\u00e9n\u00e9rer des erreurs. La structure suivante est l\u00e0 pour \u00e7a : try : # Bloc try except error : # Bloc except Le code du bloc try va \u00eatre ex\u00e9cut\u00e9, et si une erreur du type fournie en argument de l'instruction except est lev\u00e9e, alors le code du bloc except est ex\u00e9cut\u00e9. Exemple : En premi\u00e8re nous avons vu l'importance de rendre parfois un code dumbproof , et que cela g\u00e9n\u00e8rais parfois de nombreuses difficult\u00e9s. Le simple fait de coder une fonction demandant \u00e0 un utilisateur de saisir un nombre entier entre 1 et 10 inclus pouvaiet rapidement p\u00e9nible \u00e0 \u00e9crire. Les deux onglets ci-dessous donnent deux versions d'une fonction permettant de r\u00e9aliser cette fonction, la version utilis\u00e9e en premi\u00e8re, et celle levant des excpetions. Version avec des structures conditionnelles def askIntFrom1To10 () : while True : nb = input ( \"Entrez un entier entre 1 et 10 :\" ) if nb . isnumeric () and \".\" not in ( nb ) : nb = int ( nb ) if 1 <= nb and nb <= 10 : return nb else : print ( \"L'entier saisi n'est pas entre 1 et 10. Veuillez recommencer\" ) else : print ( \"Ce n'est pas un entier, veuillez recommencer !\" ) Version avec interception d'erreurs def askIntFrom1To10 () : while True : try : nb = int ( input ( \"Entrez un entier entre 1 et 10 :\" )) if 1 <= nb and nb <= 10 : return nb else : print ( \"L'entier saisi n'est pas entre 1 et 10. Veuillez recommencer\" ) except ValueError : print ( \"Ce n'est pas un entier, veuillez recommencer !\" ) Exercice Evidemment, la diff\u00e9rence ne saute pas vraiment aux yeux... Pourquoi faire tout un plat d'une seule ligne gagn\u00e9e ? Essayez donc, pour chacune des 2 fonctions pr\u00e9c\u00e9dentes, avec les chaines de caract\u00e8res suivantes : \u00bd 3\u00b2 R\u00e9ponse En fait le probl\u00e8me provient de la m\u00e9thode isnumeric() , dont on ne contr\u00f4le pas vraiment le fonctionnement. On sait que cette m\u00e9thode permet de v\u00e9rifier si une chaine de caract\u00e8res est bien constitu\u00e9e uniquement de caract\u00e8res num\u00e9riques. Mais sans lire r\u00e9ellement la documentation, qui peut se douter que les fractions d\u00e9finies dans la table utf8 , ainsi que les caract\u00e8res en exposant et en indice *, sont consid\u00e9r\u00e9s comme des valeurs num\u00e9riques. L'int\u00e9r\u00eat du bloc try est qu'il se d\u00e9clenchera d\u00e8s qu'il y aura une exception lev\u00e9e. Et cette exception a peu de chance de se produire dans le bloc if / else . La fonction devient dumbproof (mais si vous r\u00e9ussissez \u00e0 d\u00e9clencher une erreur bloquante, signalez-le moi !!). Enchainer les interceptions Il est aussi possible d'avoir plusieurs blocs except successifs, en utilisant : try : # Bloc try except error1 : # Bloc except1 except error2 : # Bloc except2 ... Etendre la gestion des exceptions Il existe de nombreuses autres possibilit\u00e9s utilisant la lev\u00e9e d'exceptions, mais elles d\u00e9passent largement le programme de Terminale. Les plus curieux parmi vous pourront toujours aller lire la doc Python \", qui reste la r\u00e9f\u00e9rence absolue...","title":"Intercepter des exceptions"},{"location":"NSI/Terminale/C01/Intro/","text":"Modularit\u00e9 et initiation \u00e0 la Programmation Orient\u00e9e Objet Quand nous utilisons certaines fonctions o\u00f9 certains objets Python, qu'ils soient built-in ou bien import\u00e9s \u00e0 partir de modules , nous nous posons rarement la question de savoir quelle est leur impl\u00e9mentation , c'est-\u00e0-dire la mani\u00e8re dont-ils ont \u00e9t\u00e9 con\u00e7u et programm\u00e9. Nous faisons globalement confiance aux concepteurs du langage ou du module. Ce qui nous importe est plut\u00f4t l'interface de ces objets, c'est-\u00e0-dire la fa\u00e7on dont nous pouvons interagir avec ces objets : les cr\u00e9er, les affecter, les additionner, les supprimer,... Dans cette partie nous verrons comment cr\u00e9er un module, le documenter, et d\u00e9finir une interface claire. Nous verrons les pr\u00e9mices d'un nouveau paradigme de programmation : la Programmation Orient\u00e9e Objet( POO ). La suite de cette partie est grandement inspir\u00e9e de Num\u00e9riques et Sciences Informatique, 24 le\u00e7ons avec exercices corrig\u00e9, Ellipse Un premier probl\u00e8me Abstract Voici une propri\u00e9t\u00e9 probabiliste peu intuitive : il suffit d'avoir un groupe de 23 personnes pour que la probabilit\u00e9 que deux personnes aient la m\u00eame date d'anniversaire soit sup\u00e9rieure \u00e0 50%. Nous allons construire un programme Python qui permettra de v\u00e9rifier exp\u00e9rimentalement cette propri\u00e9t\u00e9. Pour mod\u00e9liser le probl\u00e8me : plut\u00f4t que d'utiliser des dates, nous allons utiliser des entiers de 1 \u00e0 365 ; nous allons cr\u00e9er une proc\u00e9dure ( une fonction sans param\u00e8tres ) genere_groupe() qui renvoie un tableau al\u00e9atoire de 23 entiers de 1 \u00e0 365 ; nous allons cr\u00e9er une fonction contient_doublon(t) qui renverra True si le tableau contient un doublon, et False sinon ; puis nous cr\u00e9erons une proc\u00e9dure teste_hypothese() qui testera sur un \u00e9chantillon de 100 groupes la pr\u00e9sence d'un doublon ou non, et renverra le nombre de groupes ayant eu des doublons. Exercice Cr\u00e9er un fichier recherchesDates.py et impl\u00e9menter les fonctions pr\u00e9c\u00e9dentes. Des solutions sont propos\u00e9es dans les parties ci-dessous, mais vous devez d'abord tester par vous-m\u00eames . Solutions genere_groupe() from random import randint def genere_groupe () : \"\"\"fonction renvoyant un tableau de 23 nombres al\u00e9atoires entre 1 et 365\"\"\" return [ randint ( 1 , 365 ) for _ in range ( 23 )] contient_doublon(t) def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = [] # s est un tableau temporaire contenant les valeurs test\u00e9es for data in t : if data in s : # si data est d\u00e9j\u00e0 dans s, alors c'est un doublon return True else : # sinon on ajoute data \u00e0 la liste des valeurs test\u00e9es. s . append ( data ) return False teste_hypothese() def teste_hypothese () : \"\"\"fonction renvoyant le nombre de groupes contenant un doublon sur un \u00e9chantillon de 100 groupes\"\"\" nbDoublons = 0 for _ in range ( 100 ) : t = genere_groupe () if contient_doublon ( t ) : nbDoublons += 1 return nbDoublons Ex\u00e9cution dans Basthon Preuve math\u00e9matique Cette pruve est donn\u00e9e \u00e0 titre indicatif, et n'a ni \u00e0 \u00eatre connue, ni m\u00eame \u00e0 \u00eatre comprise. Consid\u00e9rons notre groupe de 23 personnes, et cherchons la probabilit\u00e9 que les 23 personnes n'aient pas la m\u00eame date anniversaire : la premi\u00e8re peut avoir n'importe quel date anniversaire, donc 365 possibilit\u00e9 sur 365 dates possibles. La deuxi\u00e8me ne peut pas avoir la m\u00eame date que les deux premiers, donc 364 possibilit\u00e9s sur 365. La troisi\u00e8me ne peut avoir la m\u00eame date que les deux premiers, donc 363 possibilit\u00e9s sur 365. ... La \\(n-i\u00e8me\\) ne peut avoir la m\u00eame date que les \\(n-1\\) pr\u00e9c\u00e9dents, donc \\(365-(n-1)\\) possibilit\u00e9s. ... La 23\u00e8me ne peut avoir la m\u00eame date que les 22 pr\u00e9c\u00e9dents, donc \\(365-22 = 343\\) possibilit\u00e9s. La probabilit\u00e9 cherch\u00e9e est donc \\(p = \\dfrac{365}{365} \\times \\dfrac{364}{365} \\times ... \\times \\dfrac{343}{365} = \\dfrac{365~!}{342~!.365^{23}}\\) o\u00f9 \\(365~!\\) est la factorielle de 365, soit la multiplication \\(365 \\times 364 \\times 363 \\times ... \\times 2 \\times 1\\) . Or l'\u00e9v\u00e9nement contraire de \"les 23 personnes n'ont pas la m\u00eame date anniversaire\" est l'\u00e9v\u00e9nement \"au moins 2 personnes parmi les 23 ont la m\u00eame date d'anniversaire\" . Donc sa probabilit\u00e9 est \\(p' = 1-p\\) soit en calculant environ \\(0,5073\\) , soit \\(50,73\\) \\%. Plus d'informations peuvent \u00eatre trouv\u00e9es sur l' article correspondant de wikipedia . Diff\u00e9rentes solutions ? Bien entendu, les solutions propos\u00e9es ci-dessus ne sont pas uniques. Elles sont m\u00eames non optimales (en tout cas pour la fonction contient_doublon(t) ). Il est tout \u00e0 fait possible de proposer d'autres impl\u00e9mentations du code, c'est-\u00e0-dire d'autres fa\u00e7ons de coder la fonctionnalit\u00e9 voulue. Ainsi on pourrait regarder les impl\u00e9mentations suivantes, et les comparer entre elles : Exercice : autres impl\u00e9mentations de contient_doublon(t) Tableau de bool\u00e9ens def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = [ False ] * 365 # s est un tableau temporaire contenant false pour chaque date for data in t : if s [ data ] : # si s[data] est vrai (True), alors il y a doublon return True else : # sinon on bascule s[data] \u00e0 True s [ data ] = True return False C'est une solution simple. Mais que dire de ses avantages et de ses inconv\u00e9nients ? Tableau de bits def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = 0 for data in t : if s & ( 1 << data ) != 0 : return True else : s = s | ( 1 << data ) return False C'est une solution beaucoup plus complexe (et hors programme de Terminale dans sa conception). Quels sont ses avantages et ses inconv\u00e9nients ? Table de hachage def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = [[] for _ in range ( 23 )] for data in t : if data in s [ data % 23 ] : return True else : s [ data % 23 ] . append ( data ) return False Solution Solution originale L'avantage est la simplicit\u00e9 du code, et c'est \u00e0 peu pr\u00e8s tout... Par contre les inconv\u00e9nients sont nombreux, en particulier le co\u00fbt en temps : en effet \u00e0 chaque tour de boucle for data in t , on ex\u00e9cute l'instruction data in s , qui parcoure tout le tableau s ... On a donc une complexit\u00e9 en temps en \\(\\mathscr{O}(n^2)\\) (au pire). Pour un tableau de 23 \u00e9l\u00e9ments, c'est acceptable, mais dans l'hypoth\u00e8se d'un tableau de plus grande taille, c'est absolument \u00e0 \u00e9viter ! Solution tableau de bool\u00e9ens Un des avantages est que la complexit\u00e9 en temps est bien meilleure que pour la premi\u00e8re solution. Il n'y a plus les deux boucles imbriqu\u00e9es, d'o\u00f9 un gain consid\u00e9rable. Cependant on peut avoir un probl\u00e8me de co\u00fbt en m\u00e9moire , car on utilise un tableau de taille 365 pour uniquement v\u00e9rifier 23 dates. Dans le cadre d'une comparaison sur un ensemble de valeurs possibles sup\u00e9rieures \u00e0 365, le co\u00fbt en m\u00e9moire peut vite devenir probl\u00e9matique. Solution tableau de bits La solution est tr\u00e8s complexe, mais elle a un grand m\u00e9rite : un bool\u00e9en, en python, est en fait un entier (0 ou 1), donc stock\u00e9 sur... 8 octets ! (source ici ) Or il n'est pas n\u00e9cessaire d'utilier 8 octets, soit 64 bits, pour stocker un bool\u00e9en... En fait il suffit d'un seul bit ! Cette solution divise donc par 64 la taille m\u00e9moire par rapport \u00e0 la solution pr\u00e9c\u00e9dente ! C'est globalement un bon avantage dans cette situation,; mais cela reste rapidement insuffisant si le nombre d'\u00e9l\u00e9ments auquel on s'int\u00e9rese est bien plus grand que 365. Il faut noter que le tableau de bits (ou bit set ou bit array ) est une structure compacte qui permet de repr\u00e9senter facilement des tableaux de bool\u00e9ens. Elle permet une meilleure utilisation des ressources m\u00e9moires dans les cas o\u00f9 celle-ci est limit\u00e9e, comme par exemple dans la m\u00e9moire cache du processeur. Solution table de hachage Comme nous l'avons vu en classede premi\u00e8re, la table de hachage est une solkution efficace et \u00e9l\u00e9gante qui permet de gangner \u00e0 la fois du co\u00fbt en temps (on ne parcoure pas un tableau, on atteint directement l'objet par sa cl\u00e9 , ou en tout on parcoure un sous-ensemble beaucoup plus petit), et du co\u00fbt en m\u00e9moire (le tableau des cl\u00e9s est de la taille strictement n\u00e9cessaire). Une m\u00eame interface Exercice Quand on observe les 4 propositions de codes pour la fonction contient_doublon(t) , on peut constater que ces 4 codes sont quasiment identiques. Quelles sont ces parties identiques ? Solution def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = ... for data in t : if ... : return True else : ... return False Les parties en pointill\u00e9 de la solution pr\u00e9c\u00e9dente v\u00e9rifient les conditions suivantes : s repr\u00e9sente un ensemble de date, et le premier trou correspond \u00e0 la cr\u00e9ation de cette structure. Le deuxi\u00e8me trou consiste \u00e0 v\u00e9rifier si data est contenu dans s . le troisi\u00e8me trou consiste \u00e0 ajouter data \u00e0 s Seules ces trois parties changent dans les 4 programmes. On pourrait alors isoler ces trois aspects dans trois fonctions diff\u00e9rentes et obtenir le code factoris\u00e9 suivant : Code factoris\u00e9 def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = cree () for data in t : if contient ( data , s ) : return True else : ajoute ( data , s ) return False On d\u00e9finit ainsi une fonction contient_doublon(t) compl\u00e8tement s\u00e9par\u00e9e de la repr\u00e9sentation de la structure s . Le programmeur qui souhaite simplement utiliser la structure de donn\u00e9e s n'a pas \u00e0 se pr\u00e9occuper de la fa\u00e7on dont elle a \u00e9t\u00e9 impl\u00e9ment\u00e9e . Il n'a besoin que de conna\u00eetre son interface : la fonction cree() sert \u00e0 construire une structure ; la fonction contient(data,s) sert \u00e0 regarder si data est contenu dans la structure s ; La fonction ajoute(data,s) ajoute l'\u00e9l\u00e9ment data \u00e0 la structure s . C'est exactement ce qui se passe quand on utilise des modules python : on ne cherche pas \u00e0 savoir comment sont programm\u00e9s les fonctions du modules(= l'impl\u00e9mentation du module ) - car on fait confiance aux programmeurs de ce module, mais juste \u00e0 savoir comment utiliser ces fonctions(= l'interface du module ). Encore mieux, le programmeur du module peut, si il ne change pas l' interface (= la mani\u00e8re d'utiliser les fonctions), am\u00e9liorer ces fonctions (en temps, en m\u00e9moire, etc...) sans m\u00eame que l'utilisateur n'ait \u00e0 changer quoi que ce soit \u00e0 son propre programme, qui continuera \u00e0 fonctionner (mieux, du moins on esp\u00e8re...).","title":"Introduction"},{"location":"NSI/Terminale/C01/Intro/#modularite-et-initiation-a-la-programmation-orientee-objet","text":"Quand nous utilisons certaines fonctions o\u00f9 certains objets Python, qu'ils soient built-in ou bien import\u00e9s \u00e0 partir de modules , nous nous posons rarement la question de savoir quelle est leur impl\u00e9mentation , c'est-\u00e0-dire la mani\u00e8re dont-ils ont \u00e9t\u00e9 con\u00e7u et programm\u00e9. Nous faisons globalement confiance aux concepteurs du langage ou du module. Ce qui nous importe est plut\u00f4t l'interface de ces objets, c'est-\u00e0-dire la fa\u00e7on dont nous pouvons interagir avec ces objets : les cr\u00e9er, les affecter, les additionner, les supprimer,... Dans cette partie nous verrons comment cr\u00e9er un module, le documenter, et d\u00e9finir une interface claire. Nous verrons les pr\u00e9mices d'un nouveau paradigme de programmation : la Programmation Orient\u00e9e Objet( POO ). La suite de cette partie est grandement inspir\u00e9e de Num\u00e9riques et Sciences Informatique, 24 le\u00e7ons avec exercices corrig\u00e9, Ellipse","title":"Modularit\u00e9 et initiation \u00e0 la Programmation Orient\u00e9e Objet"},{"location":"NSI/Terminale/C01/Intro/#un-premier-probleme","text":"Abstract Voici une propri\u00e9t\u00e9 probabiliste peu intuitive : il suffit d'avoir un groupe de 23 personnes pour que la probabilit\u00e9 que deux personnes aient la m\u00eame date d'anniversaire soit sup\u00e9rieure \u00e0 50%. Nous allons construire un programme Python qui permettra de v\u00e9rifier exp\u00e9rimentalement cette propri\u00e9t\u00e9. Pour mod\u00e9liser le probl\u00e8me : plut\u00f4t que d'utiliser des dates, nous allons utiliser des entiers de 1 \u00e0 365 ; nous allons cr\u00e9er une proc\u00e9dure ( une fonction sans param\u00e8tres ) genere_groupe() qui renvoie un tableau al\u00e9atoire de 23 entiers de 1 \u00e0 365 ; nous allons cr\u00e9er une fonction contient_doublon(t) qui renverra True si le tableau contient un doublon, et False sinon ; puis nous cr\u00e9erons une proc\u00e9dure teste_hypothese() qui testera sur un \u00e9chantillon de 100 groupes la pr\u00e9sence d'un doublon ou non, et renverra le nombre de groupes ayant eu des doublons. Exercice Cr\u00e9er un fichier recherchesDates.py et impl\u00e9menter les fonctions pr\u00e9c\u00e9dentes. Des solutions sont propos\u00e9es dans les parties ci-dessous, mais vous devez d'abord tester par vous-m\u00eames . Solutions genere_groupe() from random import randint def genere_groupe () : \"\"\"fonction renvoyant un tableau de 23 nombres al\u00e9atoires entre 1 et 365\"\"\" return [ randint ( 1 , 365 ) for _ in range ( 23 )] contient_doublon(t) def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = [] # s est un tableau temporaire contenant les valeurs test\u00e9es for data in t : if data in s : # si data est d\u00e9j\u00e0 dans s, alors c'est un doublon return True else : # sinon on ajoute data \u00e0 la liste des valeurs test\u00e9es. s . append ( data ) return False teste_hypothese() def teste_hypothese () : \"\"\"fonction renvoyant le nombre de groupes contenant un doublon sur un \u00e9chantillon de 100 groupes\"\"\" nbDoublons = 0 for _ in range ( 100 ) : t = genere_groupe () if contient_doublon ( t ) : nbDoublons += 1 return nbDoublons Ex\u00e9cution dans Basthon Preuve math\u00e9matique Cette pruve est donn\u00e9e \u00e0 titre indicatif, et n'a ni \u00e0 \u00eatre connue, ni m\u00eame \u00e0 \u00eatre comprise. Consid\u00e9rons notre groupe de 23 personnes, et cherchons la probabilit\u00e9 que les 23 personnes n'aient pas la m\u00eame date anniversaire : la premi\u00e8re peut avoir n'importe quel date anniversaire, donc 365 possibilit\u00e9 sur 365 dates possibles. La deuxi\u00e8me ne peut pas avoir la m\u00eame date que les deux premiers, donc 364 possibilit\u00e9s sur 365. La troisi\u00e8me ne peut avoir la m\u00eame date que les deux premiers, donc 363 possibilit\u00e9s sur 365. ... La \\(n-i\u00e8me\\) ne peut avoir la m\u00eame date que les \\(n-1\\) pr\u00e9c\u00e9dents, donc \\(365-(n-1)\\) possibilit\u00e9s. ... La 23\u00e8me ne peut avoir la m\u00eame date que les 22 pr\u00e9c\u00e9dents, donc \\(365-22 = 343\\) possibilit\u00e9s. La probabilit\u00e9 cherch\u00e9e est donc \\(p = \\dfrac{365}{365} \\times \\dfrac{364}{365} \\times ... \\times \\dfrac{343}{365} = \\dfrac{365~!}{342~!.365^{23}}\\) o\u00f9 \\(365~!\\) est la factorielle de 365, soit la multiplication \\(365 \\times 364 \\times 363 \\times ... \\times 2 \\times 1\\) . Or l'\u00e9v\u00e9nement contraire de \"les 23 personnes n'ont pas la m\u00eame date anniversaire\" est l'\u00e9v\u00e9nement \"au moins 2 personnes parmi les 23 ont la m\u00eame date d'anniversaire\" . Donc sa probabilit\u00e9 est \\(p' = 1-p\\) soit en calculant environ \\(0,5073\\) , soit \\(50,73\\) \\%. Plus d'informations peuvent \u00eatre trouv\u00e9es sur l' article correspondant de wikipedia .","title":"Un premier probl\u00e8me"},{"location":"NSI/Terminale/C01/Intro/#differentes-solutions","text":"Bien entendu, les solutions propos\u00e9es ci-dessus ne sont pas uniques. Elles sont m\u00eames non optimales (en tout cas pour la fonction contient_doublon(t) ). Il est tout \u00e0 fait possible de proposer d'autres impl\u00e9mentations du code, c'est-\u00e0-dire d'autres fa\u00e7ons de coder la fonctionnalit\u00e9 voulue. Ainsi on pourrait regarder les impl\u00e9mentations suivantes, et les comparer entre elles : Exercice : autres impl\u00e9mentations de contient_doublon(t) Tableau de bool\u00e9ens def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = [ False ] * 365 # s est un tableau temporaire contenant false pour chaque date for data in t : if s [ data ] : # si s[data] est vrai (True), alors il y a doublon return True else : # sinon on bascule s[data] \u00e0 True s [ data ] = True return False C'est une solution simple. Mais que dire de ses avantages et de ses inconv\u00e9nients ? Tableau de bits def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = 0 for data in t : if s & ( 1 << data ) != 0 : return True else : s = s | ( 1 << data ) return False C'est une solution beaucoup plus complexe (et hors programme de Terminale dans sa conception). Quels sont ses avantages et ses inconv\u00e9nients ? Table de hachage def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = [[] for _ in range ( 23 )] for data in t : if data in s [ data % 23 ] : return True else : s [ data % 23 ] . append ( data ) return False Solution Solution originale L'avantage est la simplicit\u00e9 du code, et c'est \u00e0 peu pr\u00e8s tout... Par contre les inconv\u00e9nients sont nombreux, en particulier le co\u00fbt en temps : en effet \u00e0 chaque tour de boucle for data in t , on ex\u00e9cute l'instruction data in s , qui parcoure tout le tableau s ... On a donc une complexit\u00e9 en temps en \\(\\mathscr{O}(n^2)\\) (au pire). Pour un tableau de 23 \u00e9l\u00e9ments, c'est acceptable, mais dans l'hypoth\u00e8se d'un tableau de plus grande taille, c'est absolument \u00e0 \u00e9viter ! Solution tableau de bool\u00e9ens Un des avantages est que la complexit\u00e9 en temps est bien meilleure que pour la premi\u00e8re solution. Il n'y a plus les deux boucles imbriqu\u00e9es, d'o\u00f9 un gain consid\u00e9rable. Cependant on peut avoir un probl\u00e8me de co\u00fbt en m\u00e9moire , car on utilise un tableau de taille 365 pour uniquement v\u00e9rifier 23 dates. Dans le cadre d'une comparaison sur un ensemble de valeurs possibles sup\u00e9rieures \u00e0 365, le co\u00fbt en m\u00e9moire peut vite devenir probl\u00e9matique. Solution tableau de bits La solution est tr\u00e8s complexe, mais elle a un grand m\u00e9rite : un bool\u00e9en, en python, est en fait un entier (0 ou 1), donc stock\u00e9 sur... 8 octets ! (source ici ) Or il n'est pas n\u00e9cessaire d'utilier 8 octets, soit 64 bits, pour stocker un bool\u00e9en... En fait il suffit d'un seul bit ! Cette solution divise donc par 64 la taille m\u00e9moire par rapport \u00e0 la solution pr\u00e9c\u00e9dente ! C'est globalement un bon avantage dans cette situation,; mais cela reste rapidement insuffisant si le nombre d'\u00e9l\u00e9ments auquel on s'int\u00e9rese est bien plus grand que 365. Il faut noter que le tableau de bits (ou bit set ou bit array ) est une structure compacte qui permet de repr\u00e9senter facilement des tableaux de bool\u00e9ens. Elle permet une meilleure utilisation des ressources m\u00e9moires dans les cas o\u00f9 celle-ci est limit\u00e9e, comme par exemple dans la m\u00e9moire cache du processeur. Solution table de hachage Comme nous l'avons vu en classede premi\u00e8re, la table de hachage est une solkution efficace et \u00e9l\u00e9gante qui permet de gangner \u00e0 la fois du co\u00fbt en temps (on ne parcoure pas un tableau, on atteint directement l'objet par sa cl\u00e9 , ou en tout on parcoure un sous-ensemble beaucoup plus petit), et du co\u00fbt en m\u00e9moire (le tableau des cl\u00e9s est de la taille strictement n\u00e9cessaire).","title":"Diff\u00e9rentes solutions ?"},{"location":"NSI/Terminale/C01/Intro/#une-meme-interface","text":"Exercice Quand on observe les 4 propositions de codes pour la fonction contient_doublon(t) , on peut constater que ces 4 codes sont quasiment identiques. Quelles sont ces parties identiques ? Solution def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = ... for data in t : if ... : return True else : ... return False Les parties en pointill\u00e9 de la solution pr\u00e9c\u00e9dente v\u00e9rifient les conditions suivantes : s repr\u00e9sente un ensemble de date, et le premier trou correspond \u00e0 la cr\u00e9ation de cette structure. Le deuxi\u00e8me trou consiste \u00e0 v\u00e9rifier si data est contenu dans s . le troisi\u00e8me trou consiste \u00e0 ajouter data \u00e0 s Seules ces trois parties changent dans les 4 programmes. On pourrait alors isoler ces trois aspects dans trois fonctions diff\u00e9rentes et obtenir le code factoris\u00e9 suivant : Code factoris\u00e9 def contient_doublon ( t ) : \"\"\"fonction renvoyant un bool\u00e9en signalant la pr\u00e9sence ou non d'un doublon dans le tableau\"\"\" s = cree () for data in t : if contient ( data , s ) : return True else : ajoute ( data , s ) return False On d\u00e9finit ainsi une fonction contient_doublon(t) compl\u00e8tement s\u00e9par\u00e9e de la repr\u00e9sentation de la structure s . Le programmeur qui souhaite simplement utiliser la structure de donn\u00e9e s n'a pas \u00e0 se pr\u00e9occuper de la fa\u00e7on dont elle a \u00e9t\u00e9 impl\u00e9ment\u00e9e . Il n'a besoin que de conna\u00eetre son interface : la fonction cree() sert \u00e0 construire une structure ; la fonction contient(data,s) sert \u00e0 regarder si data est contenu dans la structure s ; La fonction ajoute(data,s) ajoute l'\u00e9l\u00e9ment data \u00e0 la structure s . C'est exactement ce qui se passe quand on utilise des modules python : on ne cherche pas \u00e0 savoir comment sont programm\u00e9s les fonctions du modules(= l'impl\u00e9mentation du module ) - car on fait confiance aux programmeurs de ce module, mais juste \u00e0 savoir comment utiliser ces fonctions(= l'interface du module ). Encore mieux, le programmeur du module peut, si il ne change pas l' interface (= la mani\u00e8re d'utiliser les fonctions), am\u00e9liorer ces fonctions (en temps, en m\u00e9moire, etc...) sans m\u00eame que l'utilisateur n'ait \u00e0 changer quoi que ce soit \u00e0 son propre programme, qui continuera \u00e0 fonctionner (mieux, du moins on esp\u00e8re...).","title":"Une m\u00eame interface"},{"location":"NSI/Terminale/C01/IntroPOO/","text":"Introduction \u00e0 la programmation orient\u00e9e objet Un premier exemple issu de Scratch Observons ce jeu assez minable en Scratch (non, mais vraiment, allez voir sur le site...). Le lien ici Ce jeu sommaire est construit autour de trois \u00e9l\u00e9ments : la chauve-souris ; l'\u00e9clair ; le chat. Chacun de ces trois \u00e9l\u00e9ments poss\u00e8de : sa propre zone de script; ses propres caract\u00e9ristiques (nom, taille, costumes, position de d\u00e9part, orientation...). Et ces trois \u00e9l\u00e9ments r\u00e9agissent en fonction d'\u00e9v\u00e9nements li\u00e9s soit \u00e0 l'action du joueur, soit \u00e0 leurs propres interactions. L'\u00e9clair et le chat ont la possibilit\u00e9 d'exister sous la forme de clones , chacun des clones ayant ses propres caract\u00e9ristiques bien que partageant le m\u00eame comportement . Aussi simpliste que Scratch paraisse, il n'en est n\u00e9anmoins pas un v\u00e9ritable langage de programmation , qui plus est multiparadigme : il est en effet con\u00e7u pour g\u00e9rer la programmation imp\u00e9rative , la programmation orient\u00e9e objet ainsi que la programmation \u00e9v\u00e9nementielle . Paradigmes de programmation Un paradigme est \"une repr\u00e9sentation du monde, une mani\u00e8re de voir les choses, un mod\u00e8le coh\u00e9rent du monde qui repose sur un fondement d\u00e9fini\" . Wkipedia . En programmation, plus pr\u00e9cis\u00e9ment, on parle de paradigmes de programmation pour exprimer la mani\u00e8re dont sont con\u00e7us et envisag\u00e9s les programmes. On distingue entre autres : le paradigme de la programmation imp\u00e9rative , qui est celui que nous avons utilis\u00e9 jusqu'ici : on d\u00e9crit les op\u00e9rations en s\u00e9quences d'instructions ex\u00e9cut\u00e9es par l'ordinateur dans un ordre pr\u00e9cis (que le langage soit compil\u00e9 ou interpr\u00e9t\u00e9). C'est le paradigme classique, celui auquel tout le monde pense quand on parle de programme informatique. le paradigme de la programmation orient\u00e9 objet , qui \"consiste en la d\u00e9finition et l'interaction de briques logicielles appel\u00e9es objets ; un objet repr\u00e9sente un concept, une id\u00e9e ou toute entit\u00e9 du monde physique, comme une voiture, une personne ou encore une page d'un livre. Il poss\u00e8de une structure interne et un comportement, et il sait interagir avec ses pairs. Il s'agit donc de repr\u00e9senter ces objets et leurs relation[...]\". Wikipedia . le paradigme de la programmation fonctionnelle , qui consid\u00e8re le calcul en tant qu'\u00e9valuation de fonctions math\u00e9matiques. le paradigme de la programmation \u00e9v\u00e9nementielle , qui est fond\u00e9 sur la notion d'\u00e9v\u00e9nements. Le programme sera principalement d\u00e9fini par ses r\u00e9actions aux diff\u00e9rents \u00e9v\u00e9nements qui peuvent se produire, c'est-\u00e0-dire des changements d'\u00e9tat de variable, par exemple l'incr\u00e9mentation d'une liste, un d\u00e9placement ou un click de souris, une saisie au clavier... et bien d'autres ... Les diff\u00e9rents langages de programmation peuvent \u00eatre plus ou moins sp\u00e9cialis\u00e9 selon un certain nombre de paradigmes. Quasiment tous respectent le paradigme originel imp\u00e9ratif . Certains langages ne d\u00e9passent pas ce paradigme (assembleur, Fortran, Algol, BASIC,... ). D'autres sont sp\u00e9cialis\u00e9s sur un paradigme sp\u00e9cifique ( comme Lisp, ML, OCaml en programmation fonctionnelle, Ada, Smalltalk, C++, Ruby, C# Swift... en POO). Mais en g\u00e9n\u00e9ral tous les langages cit\u00e9s poss\u00e8dent des composantes multiparadigmes . C'est le cas de Python, qui supporte la programmation : imp\u00e9rative ; fonctionnelle ; proc\u00e9durale ; orient\u00e9e objet ; et en partie \u00e9v\u00e9nementielle. Principes Le concept principal de la programmation orient\u00e9e objet (POO) est celui d' objet . Nous avons d\u00e9j\u00e0 rencontr\u00e9 un certain nombres d'objets pr\u00e9d\u00e9finis dans Python : la classe int , pour repr\u00e9senter les entiers relatifs ; la classe float , pour repr\u00e9senter les nombre \u00e0 virgule flottante (une partie des d\u00e9cimaux) ; la classe str pour repr\u00e9senter les cha\u00eenes de caract\u00e8res ; la classe list , pour repr\u00e9senter un ensemble ordonn\u00e9 et mutable de toute autre collection d'objets ; la classe tuple , pour repr\u00e9senter un ensemble ordonn\u00e9 et non-mutable de toute autre collection d'objets ; la classe set , pour repr\u00e9senter un ensemble non ordonn\u00e9 et sans doublons ; la classe dict , pour repr\u00e9senter une collection non ordonn\u00e9e index\u00e9e par des cl\u00e9s. Chacun de ces types pr\u00e9c\u00e9dents poss\u00e8de ses propres attributs et ses propres m\u00e9thodes : un objet de la classe str poss\u00e8de une longueur, donn\u00e9 par la fonction built-in len() , et plusieurs m\u00e9thodes associ\u00e9es comme lower() , upper() , etc... un objet de la classe list poss\u00e8de lui aussi une longueur, et ses propres m\u00e9thodes comme append() , pop() , etc... A lire quand vous avez fini la page !!! Je raconte n'importe quoi ci-dessus... Je voulais prendre l'exemple de la longueur comme \u00e9tant un attribut des types str et list . En fait la valeur renvoy\u00e9e par la fonction built-in len() correspond \u00e0 celle calcul\u00e9e par le DUNDERS __len__(self) . Il ne s'agit donc pas r\u00e9ellement d'un attribut, mais du r\u00e9sultat renvoy\u00e9 par une m\u00e9thode . Comme quoi m\u00eame apr\u00e8s 30 ans de programmation on en apprend encore... Classes et constructeurs d'objets En Programmation Orient\u00e9e Objet, on va construire de nouvelles classes d'objets plus ou moins complexes, poss\u00e9dant : des attributs , c'est-\u00e0-dire des variables sp\u00e9cifiques qui lui sont directement associ\u00e9es ; des m\u00e9thodes , c'est-\u00e0-dire des fonctions modifiant l'objet, ou interagissant avec l'environnement ext\u00e9rieur \u00e0 cet objet. Application \u00e0 un exemple Personnages de JDR/MMORPG Prenons un JDR ou MMORPG lambda, dont les personnages sont constitu\u00e9s ainsi : ils ont 4 caract\u00e9ristiques num\u00e9riques entre \\(1\\) et \\(40\\) , \u00e0 savoir force, endurance, rapidit\u00e9, intelligence ; ils ont un nombre de points de vie de d\u00e9part calcul\u00e9 \u00e0 partir des caract\u00e9ristiques endurance + force//2 ; ils poss\u00e8dent bien s\u00fbr un nom ; leur nombre de points d'exp\u00e9rience au d\u00e9part est de \\(0\\) , et leur niveau est de \\(1\\) ; Chaque personnage peut mener une attaque , qui consiste \u00e0 ajouter un nombre al\u00e9atoire entre 1 et 20 \u00e0 sa force ; Chaque personnage peut se d\u00e9fendre d'une attaque qui lui est lanc\u00e9e en ajoutant un nombre al\u00e9atoire de 1 \u00e0 20 \u00e0 son endurance. Si ce r\u00e9sultat est sup\u00e9rieur ou \u00e9gal au niveau d'attaque, l'attaque a \u00e9chou\u00e9e, sinon le personnage perd un nombre de points de vie \u00e9gal \u00e0 la diff\u00e9rence entre le niveau d'attaque et le niveau de d\u00e9fense. Pour construire un tel personnage, on va devoir renseigner son nom, et ses 4 caract\u00e9ristiques. Ses PV, Pex et son niveau sont automatiquement calcul\u00e9s. Tous sont cependant des attributs du personnage. Abstract On va donc d\u00e9crire un personnage par l'interm\u00e9diaire de l'interface suivante : Cr\u00e9ation de la classe et des attributs Info Nous d\u00e9taillerons beaucoup plus dans un chapitre sp\u00e9cifique le fonctionnement de la POO. Pour l'instant vous devrez vous contenter des explications ci-dessus. D\u00e9crire une classe en Python Le code suivant permet de d\u00e9finir une nouvelle classe d'objets de type Personnage : class Personnage : \"\"\" une classe pour repr\u00e9senter un personnage g\u00e9n\u00e9rique du MMORPG \"\"\" def __init__ ( self , nom , force , endurance , rapidite , intelligence ) : self . nom = nom self . force = force self . endurance = endurance self . rapidite = rapidite self . intelligence = intelligence self . pv = self . endurance + self . force // 2 self . pex = 0 self . niveau = 1 La d\u00e9finition d'une classe d'objet est effectu\u00e9e par le mot-cl\u00e9 class , suivi du nom de la classe (commen\u00e7ant par une majuscule par convention) et du symbole : . Comme toujours en Python le symbole : d\u00e9clenche l'attente d'un bloc indent\u00e9, qui correspondra \u00e0 la d\u00e9finition de l'objet. On trouve ensuite une docstring d\u00e9crivant la classe, puis la d\u00e9finition d'une m\u00e9thode de la classe, la m\u00e9thode __init__() , appel\u00e9e m\u00e9thode constructeur de la classe . Cette m\u00e9thode prend plusieurs param\u00e8tres : le param\u00e8tre self , obligatoire , qui repr\u00e9sente 'l'instance de l'objet cr\u00e9\u00e9. une s\u00e9rie de param\u00e8tres qui correspondent aux param\u00e8tres d\u00e9finis dans l'interface de l'objet Personnage . Puis dans cette m\u00e9thode, on affecte aux attributs de l'objet les valeurs pass\u00e9es en argument, puis on calcule l' attribut pv \u00e0 partir des valeurs d\u00e9j\u00e0 connues. Enfin on d\u00e9fini les deux attributs de valeurs fixes. Un oubli ? Attention ! Ici nous ne respectons pas vraiment l'interface, puisque nous ne v\u00e9rifions pas que les attributs pass\u00e9s en argument sont bien des entiers entre 1 et 40 ! Ce probl\u00e8me sera r\u00e9gl\u00e9 plus tard. Instanciation d'objets Pour cr\u00e9er des personnages, il suffit maintenant d'utiliser une expression de la forme : Personnage( nom, f, e, r, i) . Vous noterez que l'argument self n'est pas renseign\u00e9 ! On appelle cet argument un argument implicite . Ainsi pour cr\u00e9er un objet de type Personnage nomm\u00e9 Bob, et ayant les attributs 20 en force, 25 en endurance, 10 en rapidit\u00e9 et 30 en intelligence, on utilise l'instruction suivante : >>> Personnage(\"Bob\", 20, 25, 10, 30) <__main__.Personnage object at 0x7fb674844e48> On constate donc bien qu'un objet de type Personnage est cr\u00e9e. Bien s\u00fbr, l'objet n'\u00e9tant pas affect\u00e9 \u00e0 un nom, il est imm\u00e9diatement nettoy\u00e9 par le garbage collector . On cr\u00e9e donc une variable playerBob comme r\u00e9f\u00e9rence \u00e0 l'objet : >>> playerBob = Personnage(\"Bob\", 20, 25, 10, 30) Abstract On peut sch\u00e9matiser avec le dessin suivant : L'appel au nom de la classe Personnage fait en r\u00e9alit\u00e9 appel \u00e0 la m\u00e9thode constructeur , qui va permettre de cr\u00e9er un nouvel objet de type Personnage . On peut le v\u00e9rifier avec la ligne suivante : >>> type(playerBob) <class '__main__.Personnage'> Acc\u00e9der aux attributs et les modifier Pour acc\u00e9der \u00e0 l'attribut pv de l'objet playerBob , il suffit d'utiliser la notation >>> playerBob.pv 35 Il devient d\u00e8s lors possible de modifier la valeur d'un attribut comme lors de toute modification classique des variables : >>> playerBob.force = 18 >>> playerBob.force 18 >>> playerBob.rapidite = playerBob.rapidite + 2 >>> playerBob.rapidite 12 Deux objets Nous souhaitons maintenant cr\u00e9er un deuxi\u00e8me personnage du nom de Bill : >>> playerBill = Personnage('Bill', 34, 10, 20, 12) Abstract Cette seconde instance de type Personnage poss\u00e8de aussi ses propres attributs, comme montr\u00e9 dans le sch\u00e9ma suivant : Espace de nommage Chaque instance d'objet poss\u00e8de son propre espace de nommage. Ici m\u00eame si les deux objets de type Personnage ont le m\u00eame nom d'attribut force , ils ne repr\u00e9sentent pas le m\u00eame objet. D\u00e9finitions de m\u00e9thodes Afficher les personnage Essayons maintenant d'afficher une cha\u00eene de caract\u00e8res nous donne toutes les caract\u00e9ristiques d'un personnage. Test de print Essayons d'abord avec la fonction built-in print() : >>> print(playerBob) Sortie et commentaires La sortie sur la console Python est : <__main__.Personnage object at 0x7fb6748590f0> C'est peu parlant ! La fonction print ne renvoie que l'adresse m\u00e9moire et le type de l'objet que nous venons de lui passer. Nous allons donc devoir am\u00e9liorer cet affichage, en construisant notre propre m\u00e9thode , que nous nommerons affiche . Cette m\u00e9thode devra avoir le comportement suivant : >>> playerBob.affiche() \"Bonjour, je suis Bob, de niveau 1. J'ai 18 en force, 25 en endurance, 12 en rapidit\u00e9 et 30 en intelligence. J'ai 35 Points de Vie\" M\u00e9thodes et attributs Si les attributs d'une classe sont comme des variables sp\u00e9cifiques \u00e0 une classe, les m\u00e9thodes sont des fonctions : elles peuvent prendre ou non des arguments, et ont des valeurs de retour (qui peuvent \u00eatre parfois implicites : la m\u00e9thode __init__ renvoie le nouvel objet cr\u00e9\u00e9.) Pour cr\u00e9er cette m\u00e9thode, nous allons compl\u00e9ter la classe Personnage de la mani\u00e8re suivante : class Personnage : \"\"\" une classe pour repr\u00e9senter un personnage g\u00e9n\u00e9rique du MMORPG \"\"\" def __init__ ( self , nom , force , endurance , rapidite , intelligence ) : self . nom = nom ... def affiche ( self ) : print ( f \"Bonjour, je suis { self . nom } , de niveau { self . niveau } .\" f \"J'ai { self . force } en force, { self . endurance } en endurance, { self . rapidite } \" f \" en rapidit\u00e9 et { self . intelligence } en intelligence. J'ai { self . pv } Points de Vie\" ) Vous constatez que : Dans la construction de la m\u00e9thode affiche , appara\u00eet l' argument implicite self , qu'il est imp\u00e9ratif d'utiliser pour avoir acc\u00e8s aux attributs de l'objet. Dans l'appel de la m\u00e9thode aucun argument n'est pass\u00e9 . En rechargeant le module, puis en recr\u00e9ant les objets playerBill puis playerBob , on obtient alors les affichages suivants : >>> playerBob.affiche() Bonjour, je suis Bob, de niveau 1.J'ai 18 en force, 25 en endurance, 12 en rapidit\u00e9 et 30 en intelligence. J'ai 34 Points de Vie >>> playerBill.affiche() Bonjour, je suis Bill, de niveau 1.J'ai 34 en force, 10 en endurance, 20 en rapidit\u00e9 et 12 en intelligence. J'ai 27 Points de Vie Impl\u00e9menter la m\u00e9thode attaque Dans notre interface de d\u00e9part, nous avions pr\u00e9vu une m\u00e9thode attaque() qui renvoie un entier \u00e9gal \u00e0 la valeur de force du personnage auquel on ajoute un nombre al\u00e9atoire entre 1 et 20. Comment impl\u00e9menter une telle m\u00e9thode ? Une impl\u00e9mentation possible from random import randint class Personnage : \"\"\" une classe pour repr\u00e9senter un personnage g\u00e9n\u00e9rique du MMORPG \"\"\" def __init__ ( self , nom , force , endurance , rapidite , intelligence ) : self . nom = nom ... def affiche ( self ) : ... def attaque ( self ) : return self . force + randint ( 1 , 20 ) Cette m\u00e9thode peut alors \u00eatre utilis\u00e9e comme dans les exemples ci-dessous : >>> playerBob.attaque() 22 >>> playerBob.attaque() 27 >>> playerBill.attaque() 38 Impl\u00e9menter la m\u00e9thode defense(valeurAttaque) Dans notre interface de d\u00e9part, nous avions pr\u00e9vu une m\u00e9thode defense(valeurAttaque) qui ajoute un nombre al\u00e9atoire de 1 \u00e0 20 \u00e0 l'endurance du personnage. Si ce r\u00e9sultat est sup\u00e9rieur ou \u00e9gal au niveau d'attaque, l'attaque a \u00e9chou\u00e9e et la m\u00e9thode renvoie True . Sinon le personnage perd un nombre de points de vie \u00e9gal \u00e0 la diff\u00e9rence entre le niveau d'attaque et le niveau de d\u00e9fense, et la m\u00e9thode renvoie False . Comment impl\u00e9menter une telle m\u00e9thode ? Une impl\u00e9mentation possible from random import randint class Personnage : \"\"\" une classe pour repr\u00e9senter un personnage g\u00e9n\u00e9rique du MMORPG \"\"\" def __init__ ( self , nom , force , endurance , rapidite , intelligence ) : self . nom = nom ... def affiche ( self ) : ... def attaque ( self ) : return self . force + randint ( 1 , 20 ) def defense ( self , valeurAttaque ) : valeurDefense = self . endurance + randint ( 1 , 20 ) if valeurAttaque > valeurDefense : self . pv -= valeurAttaque - valeurDefense return False return True cette m\u00e9thode peut alors \u00eatre utilis\u00e9e ainsi : >>> playerBill.defense(playerBob.attaque()) False >>> playerBill.pv 18 M\u00e9thodes sp\u00e9cifiques Info La liste de toutes les m\u00e9thodes d'une classe, y compris des DUNDERS , peut-\u00eatre obtenue par l'interm\u00e9diaire de la commande suivante : >>> dir(Personnage) ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'affiche', 'attaque', 'defense'] DUNDERS Il existe plusieurs m\u00e9thodes sp\u00e9cifiques d\u00e9finies automatiquement d\u00e8s qu'on cr\u00e9e une classe d'objets. Ces m\u00e9thodes sont toutes de la forme __truc__() (c'est-\u00e0-dire que le nom de la classe est pr\u00e9fix\u00e9 par un double tiret du bas, soit Double UNDERScore , ce qui a donn\u00e9 le nom de m\u00e9thodes DUNDERS ). Ce sont des m\u00e9thodes universelles que poss\u00e8dent toute classe en Python, et qui permettent de g\u00e9rer un certain nombre d'actions. Par exemple l'instruction Personnage('Bob', 18, 25, 12, 30) fait appel \u00e0 la m\u00e9thode DUNDERS __init__() que nous avons d\u00e9finie. Il est ainsi possible de red\u00e9finir un certain nombre de ces m\u00e9thodes selon nos utilisations. Le tableau ci-dessous vous pr\u00e9sente quelques-uns de ces DUNDERS, applicables \u00e0 des objets t et other instances de la classe : m\u00e9thode Appel Int\u00e9r\u00eat __str__(self) str(t) renvoie une cha\u00eene de caract\u00e8res d\u00e9crivant l'objet t __lt__(self,other) t < other permet de d\u00e9finir la relation plus petit que entre deux objets, renvoie True ou False selon la d\u00e9finition propos\u00e9e __len__(self) len(t) permet de d\u00e9finir la longueur de l'objet t __contains__(self,x) x in t permet de d\u00e9finir l'appartenance de x \u00e0 t __eq__(self, other) t == other permet de d\u00e9finir l'\u00e9galit\u00e9 entre deux objets t et other __add__(self, other) t + other d\u00e9finit l'addition de deux objets t et other __mul__(self, other) t * other d\u00e9finit la multiplication de deux objets t et other red\u00e9finition de la m\u00e9thode __str__(self) Il est assez facile de red\u00e9finir la m\u00e9thode __str__(self) , puisque nous avons d\u00e9j\u00e0 une cha\u00eene de caract\u00e8re qui nous convient : celle de la m\u00e9thode affiche(self) . Nous allons alors changer la m\u00e9thode affiche(self) qui renverra la cha\u00eene de caract\u00e8re g\u00e9n\u00e9r\u00e9e par la m\u00e9thode __str__(self) (pour des raisons pratiques, la cha\u00eene sera multi-ligne): from random import randint class Personnage : \"\"\" une classe pour repr\u00e9senter un personnage g\u00e9n\u00e9rique du MMORPG \"\"\" def __init__ ( self , nom , force , endurance , rapidite , intelligence ) : self . nom = nom ... def __str__ ( self ) : return f \"\"\"Bonjour, je suis { self . nom } , de niveau { self . niveau } . J'ai { self . force } en force, { self . endurance } en endurance, { self . rapidite } en rapidit\u00e9 et { self . intelligence } en intelligence. J'ai { self . pv } Points de Vie\"\"\" def affiche ( self ) : print ( str ( self )) ... On a alors la possibilit\u00e9 d'utiliser les commandes suivantes : >>> str(playerBob) \"Bonjour, je suis Bob, de niveau 1.\\n J'ai 18 en force, 25 en endurance, 12\\n en rapidit\u00e9 et 30 en intelligence. J'ai 34 Points de Vie\" >>> playerBob.affiche() Bonjour, je suis Bob, de niveau 1.J'ai 18 en force, 25 en endurance, 12en rapidit\u00e9 et 30 en intelligence. J'ai 34 Points de Vie D\u00e9finir l'\u00e9galit\u00e9 entre deux personnages On consid\u00e8re que deux personnages sont \u00e9gaux quand ils poss\u00e8dent les m\u00eames caract\u00e9ristiques num\u00e9riques de bases ( force , endurance , rapidite et intelligence ). Red\u00e9finir la m\u00e9thode DUNDERS __eq__(self, u) pour qu'elle corresponde \u00e0 cette d\u00e9finition. Solution from random import randint class Personnage : \"\"\" une classe pour repr\u00e9senter un personnage g\u00e9n\u00e9rique du MMORPG \"\"\" def __init__ ( self , nom , force , endurance , rapidite , intelligence ) : self . nom = nom ... def __eq__ ( self , other ) : return ( self . force == other . force ) and ( self . endurance == other . endurance ) and ( self . rapidite == other . rapidite ) and ( self . intelligence == other . intelligence ) ... On a alors l'utilisation : >>> playerBob == playerBill False >>> playerBob == Personnage('Marty', 18, 25, 12, 30) True Fight ! Un combat de ce MMORPG se d\u00e9roule selon le sch\u00e9ma suivant : Chaque personnage tire son initiative en ajoutant un nombre al\u00e9atoire entre 1 et 20 \u00e0 sa valeur de rapidite. Le joueur ayant l'initiative la plus \u00e9lev\u00e9e effectue son attaque en premier, et le second se d\u00e9fend. En cas d'\u00e9galit\u00e9 d'initiative, le joeur d'attaque sera celui qui poss\u00e8de la rapidit\u00e9 la plus \u00e9lev\u00e9e. En cas d'\u00e9galit\u00e9 de rapidit\u00e9, le premier joueur sera d\u00e9termin\u00e9 al\u00e9atoirement. Si le deuxi\u00e8me joueur est toujours vivant (ses points de vie sont sup\u00e9rieurs \u00e0 0), il effectue son attaque, et le premier se d\u00e9fend. Si les deux joueurs sont toujours vivants, on recommence un nouveau tour en reprenant en 1. Sinon on affiche le vainqueur. Le vainqueur r\u00e9colte un nombre de points d'exp\u00e9rience \u00e9gal \u00e0 : nombre d'attaque r\u00e9ussie * 2 + nombre de defense r\u00e9ussie Vous devrez impl\u00e9menter un programme simulant un combat entre Bob et Bill , dont la sortie console sera sous la forme suivante : Round 1 Bob a l'initiative et attaque avec 28 Bill r\u00e9ussit sa d\u00e9fense Bill attaque avec 40 Bob rate sa d\u00e9fense et n'a plus que 25 points de vie Round 2 ... Round n Le vainqueur est ..., il lui reste ... points de vie. Il gagne ... points d'exp\u00e9riences. Pour r\u00e9aliser ce programme, vopus devrez : Compl\u00e9ter le fichier personnage.py contenant la classe Personnage de la mani\u00e8re suivante : La m\u00e9thode constructeur __init__() devra lever des exceptions de type TypeError explicites, si nom n'est pas de type str , ou bien si les 4 autres attributs de construction ne sont pas de type int . L'erreur devra interrompre l'ex\u00e9cution du programme qui la d\u00e9clenche ! La m\u00e9thode constructeur __init__() devra lever des exceptions de type ValueError explicites si les valeurs fournies pour les 4 attributs num\u00e9riques ne sont pas entre 1 et 40. L'erreur devra interrompre l'ex\u00e9cution du programme qui la d\u00e9clenche ! La m\u00e9thode constructeur __init__() devra lever des exceptions de type ValueError explicites si la cha\u00eene de caract\u00e8re nom est vide. L'erreur devra interrompre l'ex\u00e9cution du programme qui la d\u00e9clenche ! Vous devrez pour r\u00e9ussir construire une m\u00e9thode suppl\u00e9mentaire pour la classe Personnage : la m\u00e9thode initiative(self) qui renvoie un entier repr\u00e9sentant le score d'initiative du personnage. Le programme permettant le combat devra \u00eatre dans un fichier combat.py s\u00e9par\u00e9 de celui contenant la classe Personnage (la classe Personnage \u00e9tant import\u00e9e depuis le module personnage.py par la commande suivante : from personnage import Personnage Un fichier compress\u00e9 .zip ou .7z contenant les deux fichiers (celui du programme et le module contenant la classe Personnage ) sera rendu via le cahier de texte de pronote, dans la partie Travail \u00e0 rendre .","title":"Introduction \u00e0 la POO"},{"location":"NSI/Terminale/C01/IntroPOO/#introduction-a-la-programmation-orientee-objet","text":"","title":"Introduction \u00e0 la programmation orient\u00e9e objet"},{"location":"NSI/Terminale/C01/IntroPOO/#un-premier-exemple-issu-de-scratch","text":"Observons ce jeu assez minable en Scratch (non, mais vraiment, allez voir sur le site...). Le lien ici Ce jeu sommaire est construit autour de trois \u00e9l\u00e9ments : la chauve-souris ; l'\u00e9clair ; le chat. Chacun de ces trois \u00e9l\u00e9ments poss\u00e8de : sa propre zone de script; ses propres caract\u00e9ristiques (nom, taille, costumes, position de d\u00e9part, orientation...). Et ces trois \u00e9l\u00e9ments r\u00e9agissent en fonction d'\u00e9v\u00e9nements li\u00e9s soit \u00e0 l'action du joueur, soit \u00e0 leurs propres interactions. L'\u00e9clair et le chat ont la possibilit\u00e9 d'exister sous la forme de clones , chacun des clones ayant ses propres caract\u00e9ristiques bien que partageant le m\u00eame comportement . Aussi simpliste que Scratch paraisse, il n'en est n\u00e9anmoins pas un v\u00e9ritable langage de programmation , qui plus est multiparadigme : il est en effet con\u00e7u pour g\u00e9rer la programmation imp\u00e9rative , la programmation orient\u00e9e objet ainsi que la programmation \u00e9v\u00e9nementielle . Paradigmes de programmation Un paradigme est \"une repr\u00e9sentation du monde, une mani\u00e8re de voir les choses, un mod\u00e8le coh\u00e9rent du monde qui repose sur un fondement d\u00e9fini\" . Wkipedia . En programmation, plus pr\u00e9cis\u00e9ment, on parle de paradigmes de programmation pour exprimer la mani\u00e8re dont sont con\u00e7us et envisag\u00e9s les programmes. On distingue entre autres : le paradigme de la programmation imp\u00e9rative , qui est celui que nous avons utilis\u00e9 jusqu'ici : on d\u00e9crit les op\u00e9rations en s\u00e9quences d'instructions ex\u00e9cut\u00e9es par l'ordinateur dans un ordre pr\u00e9cis (que le langage soit compil\u00e9 ou interpr\u00e9t\u00e9). C'est le paradigme classique, celui auquel tout le monde pense quand on parle de programme informatique. le paradigme de la programmation orient\u00e9 objet , qui \"consiste en la d\u00e9finition et l'interaction de briques logicielles appel\u00e9es objets ; un objet repr\u00e9sente un concept, une id\u00e9e ou toute entit\u00e9 du monde physique, comme une voiture, une personne ou encore une page d'un livre. Il poss\u00e8de une structure interne et un comportement, et il sait interagir avec ses pairs. Il s'agit donc de repr\u00e9senter ces objets et leurs relation[...]\". Wikipedia . le paradigme de la programmation fonctionnelle , qui consid\u00e8re le calcul en tant qu'\u00e9valuation de fonctions math\u00e9matiques. le paradigme de la programmation \u00e9v\u00e9nementielle , qui est fond\u00e9 sur la notion d'\u00e9v\u00e9nements. Le programme sera principalement d\u00e9fini par ses r\u00e9actions aux diff\u00e9rents \u00e9v\u00e9nements qui peuvent se produire, c'est-\u00e0-dire des changements d'\u00e9tat de variable, par exemple l'incr\u00e9mentation d'une liste, un d\u00e9placement ou un click de souris, une saisie au clavier... et bien d'autres ... Les diff\u00e9rents langages de programmation peuvent \u00eatre plus ou moins sp\u00e9cialis\u00e9 selon un certain nombre de paradigmes. Quasiment tous respectent le paradigme originel imp\u00e9ratif . Certains langages ne d\u00e9passent pas ce paradigme (assembleur, Fortran, Algol, BASIC,... ). D'autres sont sp\u00e9cialis\u00e9s sur un paradigme sp\u00e9cifique ( comme Lisp, ML, OCaml en programmation fonctionnelle, Ada, Smalltalk, C++, Ruby, C# Swift... en POO). Mais en g\u00e9n\u00e9ral tous les langages cit\u00e9s poss\u00e8dent des composantes multiparadigmes . C'est le cas de Python, qui supporte la programmation : imp\u00e9rative ; fonctionnelle ; proc\u00e9durale ; orient\u00e9e objet ; et en partie \u00e9v\u00e9nementielle.","title":"Un premier exemple issu de Scratch"},{"location":"NSI/Terminale/C01/IntroPOO/#principes","text":"Le concept principal de la programmation orient\u00e9e objet (POO) est celui d' objet . Nous avons d\u00e9j\u00e0 rencontr\u00e9 un certain nombres d'objets pr\u00e9d\u00e9finis dans Python : la classe int , pour repr\u00e9senter les entiers relatifs ; la classe float , pour repr\u00e9senter les nombre \u00e0 virgule flottante (une partie des d\u00e9cimaux) ; la classe str pour repr\u00e9senter les cha\u00eenes de caract\u00e8res ; la classe list , pour repr\u00e9senter un ensemble ordonn\u00e9 et mutable de toute autre collection d'objets ; la classe tuple , pour repr\u00e9senter un ensemble ordonn\u00e9 et non-mutable de toute autre collection d'objets ; la classe set , pour repr\u00e9senter un ensemble non ordonn\u00e9 et sans doublons ; la classe dict , pour repr\u00e9senter une collection non ordonn\u00e9e index\u00e9e par des cl\u00e9s. Chacun de ces types pr\u00e9c\u00e9dents poss\u00e8de ses propres attributs et ses propres m\u00e9thodes : un objet de la classe str poss\u00e8de une longueur, donn\u00e9 par la fonction built-in len() , et plusieurs m\u00e9thodes associ\u00e9es comme lower() , upper() , etc... un objet de la classe list poss\u00e8de lui aussi une longueur, et ses propres m\u00e9thodes comme append() , pop() , etc... A lire quand vous avez fini la page !!! Je raconte n'importe quoi ci-dessus... Je voulais prendre l'exemple de la longueur comme \u00e9tant un attribut des types str et list . En fait la valeur renvoy\u00e9e par la fonction built-in len() correspond \u00e0 celle calcul\u00e9e par le DUNDERS __len__(self) . Il ne s'agit donc pas r\u00e9ellement d'un attribut, mais du r\u00e9sultat renvoy\u00e9 par une m\u00e9thode . Comme quoi m\u00eame apr\u00e8s 30 ans de programmation on en apprend encore... Classes et constructeurs d'objets En Programmation Orient\u00e9e Objet, on va construire de nouvelles classes d'objets plus ou moins complexes, poss\u00e9dant : des attributs , c'est-\u00e0-dire des variables sp\u00e9cifiques qui lui sont directement associ\u00e9es ; des m\u00e9thodes , c'est-\u00e0-dire des fonctions modifiant l'objet, ou interagissant avec l'environnement ext\u00e9rieur \u00e0 cet objet.","title":"Principes"},{"location":"NSI/Terminale/C01/IntroPOO/#application-a-un-exemple","text":"Personnages de JDR/MMORPG Prenons un JDR ou MMORPG lambda, dont les personnages sont constitu\u00e9s ainsi : ils ont 4 caract\u00e9ristiques num\u00e9riques entre \\(1\\) et \\(40\\) , \u00e0 savoir force, endurance, rapidit\u00e9, intelligence ; ils ont un nombre de points de vie de d\u00e9part calcul\u00e9 \u00e0 partir des caract\u00e9ristiques endurance + force//2 ; ils poss\u00e8dent bien s\u00fbr un nom ; leur nombre de points d'exp\u00e9rience au d\u00e9part est de \\(0\\) , et leur niveau est de \\(1\\) ; Chaque personnage peut mener une attaque , qui consiste \u00e0 ajouter un nombre al\u00e9atoire entre 1 et 20 \u00e0 sa force ; Chaque personnage peut se d\u00e9fendre d'une attaque qui lui est lanc\u00e9e en ajoutant un nombre al\u00e9atoire de 1 \u00e0 20 \u00e0 son endurance. Si ce r\u00e9sultat est sup\u00e9rieur ou \u00e9gal au niveau d'attaque, l'attaque a \u00e9chou\u00e9e, sinon le personnage perd un nombre de points de vie \u00e9gal \u00e0 la diff\u00e9rence entre le niveau d'attaque et le niveau de d\u00e9fense. Pour construire un tel personnage, on va devoir renseigner son nom, et ses 4 caract\u00e9ristiques. Ses PV, Pex et son niveau sont automatiquement calcul\u00e9s. Tous sont cependant des attributs du personnage. Abstract On va donc d\u00e9crire un personnage par l'interm\u00e9diaire de l'interface suivante :","title":"Application \u00e0 un exemple"},{"location":"NSI/Terminale/C01/IntroPOO/#creation-de-la-classe-et-des-attributs","text":"Info Nous d\u00e9taillerons beaucoup plus dans un chapitre sp\u00e9cifique le fonctionnement de la POO. Pour l'instant vous devrez vous contenter des explications ci-dessus. D\u00e9crire une classe en Python Le code suivant permet de d\u00e9finir une nouvelle classe d'objets de type Personnage : class Personnage : \"\"\" une classe pour repr\u00e9senter un personnage g\u00e9n\u00e9rique du MMORPG \"\"\" def __init__ ( self , nom , force , endurance , rapidite , intelligence ) : self . nom = nom self . force = force self . endurance = endurance self . rapidite = rapidite self . intelligence = intelligence self . pv = self . endurance + self . force // 2 self . pex = 0 self . niveau = 1 La d\u00e9finition d'une classe d'objet est effectu\u00e9e par le mot-cl\u00e9 class , suivi du nom de la classe (commen\u00e7ant par une majuscule par convention) et du symbole : . Comme toujours en Python le symbole : d\u00e9clenche l'attente d'un bloc indent\u00e9, qui correspondra \u00e0 la d\u00e9finition de l'objet. On trouve ensuite une docstring d\u00e9crivant la classe, puis la d\u00e9finition d'une m\u00e9thode de la classe, la m\u00e9thode __init__() , appel\u00e9e m\u00e9thode constructeur de la classe . Cette m\u00e9thode prend plusieurs param\u00e8tres : le param\u00e8tre self , obligatoire , qui repr\u00e9sente 'l'instance de l'objet cr\u00e9\u00e9. une s\u00e9rie de param\u00e8tres qui correspondent aux param\u00e8tres d\u00e9finis dans l'interface de l'objet Personnage . Puis dans cette m\u00e9thode, on affecte aux attributs de l'objet les valeurs pass\u00e9es en argument, puis on calcule l' attribut pv \u00e0 partir des valeurs d\u00e9j\u00e0 connues. Enfin on d\u00e9fini les deux attributs de valeurs fixes. Un oubli ? Attention ! Ici nous ne respectons pas vraiment l'interface, puisque nous ne v\u00e9rifions pas que les attributs pass\u00e9s en argument sont bien des entiers entre 1 et 40 ! Ce probl\u00e8me sera r\u00e9gl\u00e9 plus tard.","title":"Cr\u00e9ation de la classe et des attributs"},{"location":"NSI/Terminale/C01/IntroPOO/#instanciation-dobjets","text":"Pour cr\u00e9er des personnages, il suffit maintenant d'utiliser une expression de la forme : Personnage( nom, f, e, r, i) . Vous noterez que l'argument self n'est pas renseign\u00e9 ! On appelle cet argument un argument implicite . Ainsi pour cr\u00e9er un objet de type Personnage nomm\u00e9 Bob, et ayant les attributs 20 en force, 25 en endurance, 10 en rapidit\u00e9 et 30 en intelligence, on utilise l'instruction suivante : >>> Personnage(\"Bob\", 20, 25, 10, 30) <__main__.Personnage object at 0x7fb674844e48> On constate donc bien qu'un objet de type Personnage est cr\u00e9e. Bien s\u00fbr, l'objet n'\u00e9tant pas affect\u00e9 \u00e0 un nom, il est imm\u00e9diatement nettoy\u00e9 par le garbage collector . On cr\u00e9e donc une variable playerBob comme r\u00e9f\u00e9rence \u00e0 l'objet : >>> playerBob = Personnage(\"Bob\", 20, 25, 10, 30) Abstract On peut sch\u00e9matiser avec le dessin suivant : L'appel au nom de la classe Personnage fait en r\u00e9alit\u00e9 appel \u00e0 la m\u00e9thode constructeur , qui va permettre de cr\u00e9er un nouvel objet de type Personnage . On peut le v\u00e9rifier avec la ligne suivante : >>> type(playerBob) <class '__main__.Personnage'>","title":"Instanciation d'objets"},{"location":"NSI/Terminale/C01/IntroPOO/#acceder-aux-attributs-et-les-modifier","text":"Pour acc\u00e9der \u00e0 l'attribut pv de l'objet playerBob , il suffit d'utiliser la notation >>> playerBob.pv 35 Il devient d\u00e8s lors possible de modifier la valeur d'un attribut comme lors de toute modification classique des variables : >>> playerBob.force = 18 >>> playerBob.force 18 >>> playerBob.rapidite = playerBob.rapidite + 2 >>> playerBob.rapidite 12","title":"Acc\u00e9der aux attributs et les modifier"},{"location":"NSI/Terminale/C01/IntroPOO/#deux-objets","text":"Nous souhaitons maintenant cr\u00e9er un deuxi\u00e8me personnage du nom de Bill : >>> playerBill = Personnage('Bill', 34, 10, 20, 12) Abstract Cette seconde instance de type Personnage poss\u00e8de aussi ses propres attributs, comme montr\u00e9 dans le sch\u00e9ma suivant : Espace de nommage Chaque instance d'objet poss\u00e8de son propre espace de nommage. Ici m\u00eame si les deux objets de type Personnage ont le m\u00eame nom d'attribut force , ils ne repr\u00e9sentent pas le m\u00eame objet.","title":"Deux objets"},{"location":"NSI/Terminale/C01/IntroPOO/#definitions-de-methodes","text":"Afficher les personnage Essayons maintenant d'afficher une cha\u00eene de caract\u00e8res nous donne toutes les caract\u00e9ristiques d'un personnage. Test de print Essayons d'abord avec la fonction built-in print() : >>> print(playerBob) Sortie et commentaires La sortie sur la console Python est : <__main__.Personnage object at 0x7fb6748590f0> C'est peu parlant ! La fonction print ne renvoie que l'adresse m\u00e9moire et le type de l'objet que nous venons de lui passer. Nous allons donc devoir am\u00e9liorer cet affichage, en construisant notre propre m\u00e9thode , que nous nommerons affiche . Cette m\u00e9thode devra avoir le comportement suivant : >>> playerBob.affiche() \"Bonjour, je suis Bob, de niveau 1. J'ai 18 en force, 25 en endurance, 12 en rapidit\u00e9 et 30 en intelligence. J'ai 35 Points de Vie\" M\u00e9thodes et attributs Si les attributs d'une classe sont comme des variables sp\u00e9cifiques \u00e0 une classe, les m\u00e9thodes sont des fonctions : elles peuvent prendre ou non des arguments, et ont des valeurs de retour (qui peuvent \u00eatre parfois implicites : la m\u00e9thode __init__ renvoie le nouvel objet cr\u00e9\u00e9.) Pour cr\u00e9er cette m\u00e9thode, nous allons compl\u00e9ter la classe Personnage de la mani\u00e8re suivante : class Personnage : \"\"\" une classe pour repr\u00e9senter un personnage g\u00e9n\u00e9rique du MMORPG \"\"\" def __init__ ( self , nom , force , endurance , rapidite , intelligence ) : self . nom = nom ... def affiche ( self ) : print ( f \"Bonjour, je suis { self . nom } , de niveau { self . niveau } .\" f \"J'ai { self . force } en force, { self . endurance } en endurance, { self . rapidite } \" f \" en rapidit\u00e9 et { self . intelligence } en intelligence. J'ai { self . pv } Points de Vie\" ) Vous constatez que : Dans la construction de la m\u00e9thode affiche , appara\u00eet l' argument implicite self , qu'il est imp\u00e9ratif d'utiliser pour avoir acc\u00e8s aux attributs de l'objet. Dans l'appel de la m\u00e9thode aucun argument n'est pass\u00e9 . En rechargeant le module, puis en recr\u00e9ant les objets playerBill puis playerBob , on obtient alors les affichages suivants : >>> playerBob.affiche() Bonjour, je suis Bob, de niveau 1.J'ai 18 en force, 25 en endurance, 12 en rapidit\u00e9 et 30 en intelligence. J'ai 34 Points de Vie >>> playerBill.affiche() Bonjour, je suis Bill, de niveau 1.J'ai 34 en force, 10 en endurance, 20 en rapidit\u00e9 et 12 en intelligence. J'ai 27 Points de Vie Impl\u00e9menter la m\u00e9thode attaque Dans notre interface de d\u00e9part, nous avions pr\u00e9vu une m\u00e9thode attaque() qui renvoie un entier \u00e9gal \u00e0 la valeur de force du personnage auquel on ajoute un nombre al\u00e9atoire entre 1 et 20. Comment impl\u00e9menter une telle m\u00e9thode ? Une impl\u00e9mentation possible from random import randint class Personnage : \"\"\" une classe pour repr\u00e9senter un personnage g\u00e9n\u00e9rique du MMORPG \"\"\" def __init__ ( self , nom , force , endurance , rapidite , intelligence ) : self . nom = nom ... def affiche ( self ) : ... def attaque ( self ) : return self . force + randint ( 1 , 20 ) Cette m\u00e9thode peut alors \u00eatre utilis\u00e9e comme dans les exemples ci-dessous : >>> playerBob.attaque() 22 >>> playerBob.attaque() 27 >>> playerBill.attaque() 38 Impl\u00e9menter la m\u00e9thode defense(valeurAttaque) Dans notre interface de d\u00e9part, nous avions pr\u00e9vu une m\u00e9thode defense(valeurAttaque) qui ajoute un nombre al\u00e9atoire de 1 \u00e0 20 \u00e0 l'endurance du personnage. Si ce r\u00e9sultat est sup\u00e9rieur ou \u00e9gal au niveau d'attaque, l'attaque a \u00e9chou\u00e9e et la m\u00e9thode renvoie True . Sinon le personnage perd un nombre de points de vie \u00e9gal \u00e0 la diff\u00e9rence entre le niveau d'attaque et le niveau de d\u00e9fense, et la m\u00e9thode renvoie False . Comment impl\u00e9menter une telle m\u00e9thode ? Une impl\u00e9mentation possible from random import randint class Personnage : \"\"\" une classe pour repr\u00e9senter un personnage g\u00e9n\u00e9rique du MMORPG \"\"\" def __init__ ( self , nom , force , endurance , rapidite , intelligence ) : self . nom = nom ... def affiche ( self ) : ... def attaque ( self ) : return self . force + randint ( 1 , 20 ) def defense ( self , valeurAttaque ) : valeurDefense = self . endurance + randint ( 1 , 20 ) if valeurAttaque > valeurDefense : self . pv -= valeurAttaque - valeurDefense return False return True cette m\u00e9thode peut alors \u00eatre utilis\u00e9e ainsi : >>> playerBill.defense(playerBob.attaque()) False >>> playerBill.pv 18","title":"D\u00e9finitions de m\u00e9thodes"},{"location":"NSI/Terminale/C01/IntroPOO/#methodes-specifiques","text":"Info La liste de toutes les m\u00e9thodes d'une classe, y compris des DUNDERS , peut-\u00eatre obtenue par l'interm\u00e9diaire de la commande suivante : >>> dir(Personnage) ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'affiche', 'attaque', 'defense'] DUNDERS Il existe plusieurs m\u00e9thodes sp\u00e9cifiques d\u00e9finies automatiquement d\u00e8s qu'on cr\u00e9e une classe d'objets. Ces m\u00e9thodes sont toutes de la forme __truc__() (c'est-\u00e0-dire que le nom de la classe est pr\u00e9fix\u00e9 par un double tiret du bas, soit Double UNDERScore , ce qui a donn\u00e9 le nom de m\u00e9thodes DUNDERS ). Ce sont des m\u00e9thodes universelles que poss\u00e8dent toute classe en Python, et qui permettent de g\u00e9rer un certain nombre d'actions. Par exemple l'instruction Personnage('Bob', 18, 25, 12, 30) fait appel \u00e0 la m\u00e9thode DUNDERS __init__() que nous avons d\u00e9finie. Il est ainsi possible de red\u00e9finir un certain nombre de ces m\u00e9thodes selon nos utilisations. Le tableau ci-dessous vous pr\u00e9sente quelques-uns de ces DUNDERS, applicables \u00e0 des objets t et other instances de la classe : m\u00e9thode Appel Int\u00e9r\u00eat __str__(self) str(t) renvoie une cha\u00eene de caract\u00e8res d\u00e9crivant l'objet t __lt__(self,other) t < other permet de d\u00e9finir la relation plus petit que entre deux objets, renvoie True ou False selon la d\u00e9finition propos\u00e9e __len__(self) len(t) permet de d\u00e9finir la longueur de l'objet t __contains__(self,x) x in t permet de d\u00e9finir l'appartenance de x \u00e0 t __eq__(self, other) t == other permet de d\u00e9finir l'\u00e9galit\u00e9 entre deux objets t et other __add__(self, other) t + other d\u00e9finit l'addition de deux objets t et other __mul__(self, other) t * other d\u00e9finit la multiplication de deux objets t et other red\u00e9finition de la m\u00e9thode __str__(self) Il est assez facile de red\u00e9finir la m\u00e9thode __str__(self) , puisque nous avons d\u00e9j\u00e0 une cha\u00eene de caract\u00e8re qui nous convient : celle de la m\u00e9thode affiche(self) . Nous allons alors changer la m\u00e9thode affiche(self) qui renverra la cha\u00eene de caract\u00e8re g\u00e9n\u00e9r\u00e9e par la m\u00e9thode __str__(self) (pour des raisons pratiques, la cha\u00eene sera multi-ligne): from random import randint class Personnage : \"\"\" une classe pour repr\u00e9senter un personnage g\u00e9n\u00e9rique du MMORPG \"\"\" def __init__ ( self , nom , force , endurance , rapidite , intelligence ) : self . nom = nom ... def __str__ ( self ) : return f \"\"\"Bonjour, je suis { self . nom } , de niveau { self . niveau } . J'ai { self . force } en force, { self . endurance } en endurance, { self . rapidite } en rapidit\u00e9 et { self . intelligence } en intelligence. J'ai { self . pv } Points de Vie\"\"\" def affiche ( self ) : print ( str ( self )) ... On a alors la possibilit\u00e9 d'utiliser les commandes suivantes : >>> str(playerBob) \"Bonjour, je suis Bob, de niveau 1.\\n J'ai 18 en force, 25 en endurance, 12\\n en rapidit\u00e9 et 30 en intelligence. J'ai 34 Points de Vie\" >>> playerBob.affiche() Bonjour, je suis Bob, de niveau 1.J'ai 18 en force, 25 en endurance, 12en rapidit\u00e9 et 30 en intelligence. J'ai 34 Points de Vie D\u00e9finir l'\u00e9galit\u00e9 entre deux personnages On consid\u00e8re que deux personnages sont \u00e9gaux quand ils poss\u00e8dent les m\u00eames caract\u00e9ristiques num\u00e9riques de bases ( force , endurance , rapidite et intelligence ). Red\u00e9finir la m\u00e9thode DUNDERS __eq__(self, u) pour qu'elle corresponde \u00e0 cette d\u00e9finition. Solution from random import randint class Personnage : \"\"\" une classe pour repr\u00e9senter un personnage g\u00e9n\u00e9rique du MMORPG \"\"\" def __init__ ( self , nom , force , endurance , rapidite , intelligence ) : self . nom = nom ... def __eq__ ( self , other ) : return ( self . force == other . force ) and ( self . endurance == other . endurance ) and ( self . rapidite == other . rapidite ) and ( self . intelligence == other . intelligence ) ... On a alors l'utilisation : >>> playerBob == playerBill False >>> playerBob == Personnage('Marty', 18, 25, 12, 30) True Fight ! Un combat de ce MMORPG se d\u00e9roule selon le sch\u00e9ma suivant : Chaque personnage tire son initiative en ajoutant un nombre al\u00e9atoire entre 1 et 20 \u00e0 sa valeur de rapidite. Le joueur ayant l'initiative la plus \u00e9lev\u00e9e effectue son attaque en premier, et le second se d\u00e9fend. En cas d'\u00e9galit\u00e9 d'initiative, le joeur d'attaque sera celui qui poss\u00e8de la rapidit\u00e9 la plus \u00e9lev\u00e9e. En cas d'\u00e9galit\u00e9 de rapidit\u00e9, le premier joueur sera d\u00e9termin\u00e9 al\u00e9atoirement. Si le deuxi\u00e8me joueur est toujours vivant (ses points de vie sont sup\u00e9rieurs \u00e0 0), il effectue son attaque, et le premier se d\u00e9fend. Si les deux joueurs sont toujours vivants, on recommence un nouveau tour en reprenant en 1. Sinon on affiche le vainqueur. Le vainqueur r\u00e9colte un nombre de points d'exp\u00e9rience \u00e9gal \u00e0 : nombre d'attaque r\u00e9ussie * 2 + nombre de defense r\u00e9ussie Vous devrez impl\u00e9menter un programme simulant un combat entre Bob et Bill , dont la sortie console sera sous la forme suivante : Round 1 Bob a l'initiative et attaque avec 28 Bill r\u00e9ussit sa d\u00e9fense Bill attaque avec 40 Bob rate sa d\u00e9fense et n'a plus que 25 points de vie Round 2 ... Round n Le vainqueur est ..., il lui reste ... points de vie. Il gagne ... points d'exp\u00e9riences. Pour r\u00e9aliser ce programme, vopus devrez : Compl\u00e9ter le fichier personnage.py contenant la classe Personnage de la mani\u00e8re suivante : La m\u00e9thode constructeur __init__() devra lever des exceptions de type TypeError explicites, si nom n'est pas de type str , ou bien si les 4 autres attributs de construction ne sont pas de type int . L'erreur devra interrompre l'ex\u00e9cution du programme qui la d\u00e9clenche ! La m\u00e9thode constructeur __init__() devra lever des exceptions de type ValueError explicites si les valeurs fournies pour les 4 attributs num\u00e9riques ne sont pas entre 1 et 40. L'erreur devra interrompre l'ex\u00e9cution du programme qui la d\u00e9clenche ! La m\u00e9thode constructeur __init__() devra lever des exceptions de type ValueError explicites si la cha\u00eene de caract\u00e8re nom est vide. L'erreur devra interrompre l'ex\u00e9cution du programme qui la d\u00e9clenche ! Vous devrez pour r\u00e9ussir construire une m\u00e9thode suppl\u00e9mentaire pour la classe Personnage : la m\u00e9thode initiative(self) qui renvoie un entier repr\u00e9sentant le score d'initiative du personnage. Le programme permettant le combat devra \u00eatre dans un fichier combat.py s\u00e9par\u00e9 de celui contenant la classe Personnage (la classe Personnage \u00e9tant import\u00e9e depuis le module personnage.py par la commande suivante : from personnage import Personnage Un fichier compress\u00e9 .zip ou .7z contenant les deux fichiers (celui du programme et le module contenant la classe Personnage ) sera rendu via le cahier de texte de pronote, dans la partie Travail \u00e0 rendre .","title":"M\u00e9thodes sp\u00e9cifiques"},{"location":"NSI/Terminale/C01/Modularite/","text":"Modules, Interfaces et Encapsulation Retour sur les modules Un module python est un fichier python contenant des fonctions, des constantes (et des constructeurs d' objets , mais nous verrons \u00e7a un peu plus tard), regroup\u00e9es dans ce fichier car elles traitent de la m\u00eame structure de donn\u00e9es . Un exemple Par exemple, dans un jeu vid\u00e9o tel que Space Invaders , on aura : un module qui traitera du vaisseau du joueur ; un module pour construire et g\u00e9rer les vaisseaux ennemis ; un ou des modules pour construire et actualiser l'interface graphique ; un module contenant des constantes (points de vie de d\u00e9part du joueur, nombre d'ennemis, etc) ; et le programme principal qui importera les modules pr\u00e9c\u00e9dents et g\u00e9rera les \u00e9v\u00e9nements liant tous les objets du jeu. On dira que ce programme d\u00e9pend des autres modules. Importer un module Il existe plusieurs possibilit\u00e9s pour importer un module. Dans la suite des exemples, le module toto , contenant les fonctions bidule() et truc() est situ\u00e9 : soit dans le m\u00eame dossier que le fichier qui l'importe ; soit dans un dossier accessible par le syst\u00e8me ( dossier faisant partie de la variable PATH de windows par exemple). Import complet import toto toto . bidule () toto . truc () Toutes les fonctions du module toto sont import\u00e9es, et elles le sont dans un namespace (= espace de nommage\") sp\u00e9cifique. Les fonctions sont alors appel\u00e9es en les pr\u00e9fixant** par le nom du module ( toto. ). Import complet avec alias import toto as to to . bidule () to . truc () Comme pour l'import complet, toutes les fonctions du module toto sont import\u00e9es, et elles le sont dans un namespace (= espace de nommage\") sp\u00e9cifique. Les fonctions sont alors appel\u00e9es en les pr\u00e9fixant par l'alias** du module ( to1. ). Import partiel dans le namespace courant from toto import bidule bidule () Ici, seul la fonction bidule() est import\u00e9e, mais elle l'est directement dans le namespace principal (= main ) du fichier effectuant l'import. La fonction truc() n'est pas appelable (elle n'existe pas pour l'interpr\u00e9teur). Import complet dans le namespace courant from toto import * bidule () truc () Toutes les fonctions sont appel\u00e9es directement dans le namespace principal (= main ) du fichier effectuant l'import. \u26a0\ufe0f C'est une pratique p\u00e9rilleuse ! Si une fonction du module porte le m\u00eame nom qu'une fonction du fichier appelant, celle import\u00e9e \u00e9crasera celle du fichiert courant, et \u00e7a peut-\u00eatre facheux... Voir l'exemple ci-dessous... Fichier principal from mon_module import * print ( \"Pain \" ) Fichier mon_module.py def print ( truc ) : print ( truc * 3 + \"Tarte Tatin\" * 2 ) Sortie attendue Probablement, ce qui est attendu par la sortie du fichier principal est juste la cha\u00eene de caract\u00e8res \"Pain \" . Mais la fonction built-in print() a \u00e9t\u00e9 \u00e9cras\u00e9e par celle du module mon_module.py . Sortie r\u00e9elle \"Pain Pain Pain Tarte Tatin Tarte Tatin\u00a8 La v\u00e9ritable fonction appel\u00e9e est celle du module mon_module.py . (Pour ceux qui ont en t\u00eate la marche imp\u00e9riale, c'est normal...) Remarque Il est toutefois possible d'importer un fichier pr\u00e9sent dans un autre dossier : soit en utilisant une adresse absolue import 'C:\\Mes_Programmes\\Python\\toto.py' ; soit en utilisant une adresse relatice import '..\\toto.py' ( si toto.py est situ\u00e9 dans le dossier parent du fichier qui importe). Interfaces Conception logicielle Dans la conception de logiciels \u00e0 grande \u00e9chelle, ou \u00e0 pluseiurs programmeurs (et \u00e0 l'heure actuelle il est fr\u00e9quent d'avoir plusieurs milliers de programmeurs concevant un logiciel), il est important de pouvoir s\u00e9parer les diff\u00e9rents \u00e9l\u00e9ments du programme en sous-ensembles coh\u00e9rents et ayant le minimum d'interactions entre eux. En particuliers ils se doivent d'\u00eatre le plus \u00e9tanches possibles quant \u00e0 leur fonctionnement. On retrouve ici que la notion d' interface est essentielle. Pour chaque module, on peut donc distinguer : une interface , c'est-\u00e0-dire la description des diff\u00e9rentes fonctions du module et de leurs arguments (obligatoires ou facultatifs). Il s'agit donc d'une documentation la plus claire possible sur la mani\u00e8re d' utiliser le module. une impl\u00e9mentation , c'est-\u00e0-dire la mani\u00e8re dont sont cod\u00e9es ces fonctions (choix de structures, nom des variables interm\u00e9diaires, etc...). Un exemple d'interface Un module utilisable pour la fonction factoris\u00e9e contient_doublon(t) aura pour interface : fonction Description cree() cr\u00e9e et renvoie un ensemble de date vide contient(data,s) renvoie True si la structure s contient la donn\u00e9e data ajoute(data,s) ajoute la donn\u00e9e data \u00e0 la structure s Vous constaterez que dans cette description, il n'est nul part fait mention de la nature de la structure . Il pourrait s'agir aussi bien de liste, de tableau de bits, de tables de hachage... Exercice : r\u00e9alisation de modules Dans chacun des cas suivant, construire un module r\u00e9alisant l'interface ci-dessus, et le tester en l'important dans le fichier rechercheDates.py o\u00f9 vous aurez modifier la fonction contient_doublon(t) par la version factoris\u00e9e de celle-ci. un module dateTab , dont la structure est impl\u00e9ment\u00e9e sous la forme d'un tableau. un module dateBool , dont la structure est impl\u00e9ment\u00e9e sous la forme d'un tableau de bool\u00e9en. un module dateHash , dont la structure est impl\u00e9ment\u00e9e sous la forme d'une table de hachage. \ud83e\udde9 Il est bien entendu essentiel de s'inspirer des exemples donn\u00e9 dans la page d'introduction . Notions d'encapsulation Notion d'encapsulation Le contrat qu'une interface \u00e9tablit entre l'utilisateur et l'auteur d'un module ne porte pas sur les moyens, mais sur les r\u00e9sultats : l'auteur s'engage \u00e0 ce que les r\u00e9sultats produits par l'utilisation de ses fonctions soient bien ceux d\u00e9crits dans l'interface, mais il est libre de s'y prendre comme il le souhaite. En particulier il est libre d'introduire des fonctions, variables, constantes, ..., qui ne sont pas inclues dans l'interface . On parle alors de fonctions, variables, constantes encapsul\u00e9es dans le module. Le contrat explicite est que l'utilisateur ne doit en aucun cas utiliser ces donn\u00e9es encapsul\u00e9es. Dans le cas contraire, si l'auteur du module change son approche et modifie ces donn\u00e9es internes, le programme du client risque de devenir non fonctionnel. Norme en Python En Python, l'auteur d'un module peut indiquer que certains \u00e9l\u00e9ments sont priv\u00e9s (= encapsul\u00e9s) en faisant commencer leur nom par un cracat\u00e8re underscore _ Exemple Imaginons un module secondDegre.py dont l'interface est d\u00e9finie ainsi : fonction Description polynome(t) V\u00e9rifie que le tuple t sous la forme (a,b,c) repr\u00e9sente bien un polyn\u00f4me de degr\u00e9 2 valeursRacines(p) Renvoie les valeurs des racines, et None si il n'existe pas de recines r\u00e9elles convexite(p) Renvoie la convexit\u00e9 de la courbe repr\u00e9sentative du polyn\u00f4me sous la forme d'une cha\u00eene de caract\u00e8re en minuscule tangente(p,x) Renvoie l'\u00e9quation de la tangente \u00e0 la courbe du polyn\u00f4me p en x Dans l'interface de ce module, on consid\u00e8re que le calcul du discriminant est une op\u00e9ration priv\u00e9e. On aurait alors comme possibilit\u00e9 d'impl\u00e9mentation (non compl\u00e8te): from math import sqrt def polynome ( t ) : a , b , * c = t if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or len ( c ) > 1 or not ( isinstance ( * c ,( int , float ))) : raise ValueError () if a == 0 : raise ValueError () return t def _discriminant ( p ) : a , b , c = polynome ( p ) return b ** 2 - 4 * a * c def _nombreRacines ( p ) : ... def valeursracines ( p ) : ... def convexite ( p ) : ... def _calcule ( p , x ) : ... def _nombreDerive ( p , x ) : ... def tangente ( p , x ) : ... Dans ce module, les fonctions pr\u00e9fix\u00e9es par _ sont consid\u00e9r\u00e9es comme priv\u00e9es, et ne faisant pas partie de l'interface. Exercice Cr\u00e9er un module secondDegre.py contenant a minima la totalit\u00e9 des fonctions pr\u00e9c\u00e9dentes, et impl\u00e9menter toutes ces fonctions. Une solution possible from math import sqrt def polynome ( t ) : a , b , * c = t if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or len ( c ) > 1 or not ( isinstance ( * c ,( int , float ))) : raise ValueError () if a == 0 : raise ValueError () return t def _discriminant ( p ) : a , b , c = polynome ( p ) return b ** 2 - 4 * a * c def _nombreRacines ( p ) : d = _discriminant ( p ) if d < 0 : return 0 elif d == 0 : return 1 else : return 2 def valeursRacines ( p ) : nbR = _nombreRacines ( p ) if nbR == 0 : return None elif nbR == 1 : a , b , c = p return - b / ( 2 * a ) else : a , b , c = p d = _discriminant ( p ) return ( - b - sqrt ( d )) / ( 2 * a ), ( - b + sqrt ( d )) / ( 2 * a ) def convexite ( p ) : a , b , c = polynome ( p ) if a > 0 : return \"convexe\" else : return \"concave\" def _calcule ( p , x ) : a , b , c = polynome ( p ) if not ( isinstance ( x , ( float , int ))) : raise valueError () else : return a * x ** 2 + b * x + c def _nombreDerive ( p , x ) : a , b , c = polynome ( p ) if not ( isinstance ( x , ( float , int ))) : raise valueError () else : return 2 * a * x + b def tangente ( p , x ) : return f 'y = { _nombreDerive ( p , x ) } (x- { x } ) + { _calcule ( p , x ) } ' Encapsulation dans d'autres langages Il faut noter que la notion de fonction ou variable priv\u00e9e en Python n'est qu'une convention. Rien n'emp\u00eache r\u00e9ellement l'utilisateur du module d'utiliser ces fonctions priv\u00e9es . C'est loin d'\u00eatre le cas dans d'autres langages (comme C++ ou Java ), qui introduisent un contr\u00f4le strict de l'encapsulation en rendant l'acc\u00e8s aux \u00e9l\u00e9ments priv\u00e9s impossible.","title":"Modules, interfaces, encapsulation"},{"location":"NSI/Terminale/C01/Modularite/#modules-interfaces-et-encapsulation","text":"","title":"Modules, Interfaces et Encapsulation"},{"location":"NSI/Terminale/C01/Modularite/#retour-sur-les-modules","text":"Un module python est un fichier python contenant des fonctions, des constantes (et des constructeurs d' objets , mais nous verrons \u00e7a un peu plus tard), regroup\u00e9es dans ce fichier car elles traitent de la m\u00eame structure de donn\u00e9es . Un exemple Par exemple, dans un jeu vid\u00e9o tel que Space Invaders , on aura : un module qui traitera du vaisseau du joueur ; un module pour construire et g\u00e9rer les vaisseaux ennemis ; un ou des modules pour construire et actualiser l'interface graphique ; un module contenant des constantes (points de vie de d\u00e9part du joueur, nombre d'ennemis, etc) ; et le programme principal qui importera les modules pr\u00e9c\u00e9dents et g\u00e9rera les \u00e9v\u00e9nements liant tous les objets du jeu. On dira que ce programme d\u00e9pend des autres modules. Importer un module Il existe plusieurs possibilit\u00e9s pour importer un module. Dans la suite des exemples, le module toto , contenant les fonctions bidule() et truc() est situ\u00e9 : soit dans le m\u00eame dossier que le fichier qui l'importe ; soit dans un dossier accessible par le syst\u00e8me ( dossier faisant partie de la variable PATH de windows par exemple). Import complet import toto toto . bidule () toto . truc () Toutes les fonctions du module toto sont import\u00e9es, et elles le sont dans un namespace (= espace de nommage\") sp\u00e9cifique. Les fonctions sont alors appel\u00e9es en les pr\u00e9fixant** par le nom du module ( toto. ). Import complet avec alias import toto as to to . bidule () to . truc () Comme pour l'import complet, toutes les fonctions du module toto sont import\u00e9es, et elles le sont dans un namespace (= espace de nommage\") sp\u00e9cifique. Les fonctions sont alors appel\u00e9es en les pr\u00e9fixant par l'alias** du module ( to1. ). Import partiel dans le namespace courant from toto import bidule bidule () Ici, seul la fonction bidule() est import\u00e9e, mais elle l'est directement dans le namespace principal (= main ) du fichier effectuant l'import. La fonction truc() n'est pas appelable (elle n'existe pas pour l'interpr\u00e9teur). Import complet dans le namespace courant from toto import * bidule () truc () Toutes les fonctions sont appel\u00e9es directement dans le namespace principal (= main ) du fichier effectuant l'import. \u26a0\ufe0f C'est une pratique p\u00e9rilleuse ! Si une fonction du module porte le m\u00eame nom qu'une fonction du fichier appelant, celle import\u00e9e \u00e9crasera celle du fichiert courant, et \u00e7a peut-\u00eatre facheux... Voir l'exemple ci-dessous... Fichier principal from mon_module import * print ( \"Pain \" ) Fichier mon_module.py def print ( truc ) : print ( truc * 3 + \"Tarte Tatin\" * 2 ) Sortie attendue Probablement, ce qui est attendu par la sortie du fichier principal est juste la cha\u00eene de caract\u00e8res \"Pain \" . Mais la fonction built-in print() a \u00e9t\u00e9 \u00e9cras\u00e9e par celle du module mon_module.py . Sortie r\u00e9elle \"Pain Pain Pain Tarte Tatin Tarte Tatin\u00a8 La v\u00e9ritable fonction appel\u00e9e est celle du module mon_module.py . (Pour ceux qui ont en t\u00eate la marche imp\u00e9riale, c'est normal...) Remarque Il est toutefois possible d'importer un fichier pr\u00e9sent dans un autre dossier : soit en utilisant une adresse absolue import 'C:\\Mes_Programmes\\Python\\toto.py' ; soit en utilisant une adresse relatice import '..\\toto.py' ( si toto.py est situ\u00e9 dans le dossier parent du fichier qui importe).","title":"Retour sur les modules"},{"location":"NSI/Terminale/C01/Modularite/#interfaces","text":"Conception logicielle Dans la conception de logiciels \u00e0 grande \u00e9chelle, ou \u00e0 pluseiurs programmeurs (et \u00e0 l'heure actuelle il est fr\u00e9quent d'avoir plusieurs milliers de programmeurs concevant un logiciel), il est important de pouvoir s\u00e9parer les diff\u00e9rents \u00e9l\u00e9ments du programme en sous-ensembles coh\u00e9rents et ayant le minimum d'interactions entre eux. En particuliers ils se doivent d'\u00eatre le plus \u00e9tanches possibles quant \u00e0 leur fonctionnement. On retrouve ici que la notion d' interface est essentielle. Pour chaque module, on peut donc distinguer : une interface , c'est-\u00e0-dire la description des diff\u00e9rentes fonctions du module et de leurs arguments (obligatoires ou facultatifs). Il s'agit donc d'une documentation la plus claire possible sur la mani\u00e8re d' utiliser le module. une impl\u00e9mentation , c'est-\u00e0-dire la mani\u00e8re dont sont cod\u00e9es ces fonctions (choix de structures, nom des variables interm\u00e9diaires, etc...). Un exemple d'interface Un module utilisable pour la fonction factoris\u00e9e contient_doublon(t) aura pour interface : fonction Description cree() cr\u00e9e et renvoie un ensemble de date vide contient(data,s) renvoie True si la structure s contient la donn\u00e9e data ajoute(data,s) ajoute la donn\u00e9e data \u00e0 la structure s Vous constaterez que dans cette description, il n'est nul part fait mention de la nature de la structure . Il pourrait s'agir aussi bien de liste, de tableau de bits, de tables de hachage... Exercice : r\u00e9alisation de modules Dans chacun des cas suivant, construire un module r\u00e9alisant l'interface ci-dessus, et le tester en l'important dans le fichier rechercheDates.py o\u00f9 vous aurez modifier la fonction contient_doublon(t) par la version factoris\u00e9e de celle-ci. un module dateTab , dont la structure est impl\u00e9ment\u00e9e sous la forme d'un tableau. un module dateBool , dont la structure est impl\u00e9ment\u00e9e sous la forme d'un tableau de bool\u00e9en. un module dateHash , dont la structure est impl\u00e9ment\u00e9e sous la forme d'une table de hachage. \ud83e\udde9 Il est bien entendu essentiel de s'inspirer des exemples donn\u00e9 dans la page d'introduction .","title":"Interfaces"},{"location":"NSI/Terminale/C01/Modularite/#notions-dencapsulation","text":"Notion d'encapsulation Le contrat qu'une interface \u00e9tablit entre l'utilisateur et l'auteur d'un module ne porte pas sur les moyens, mais sur les r\u00e9sultats : l'auteur s'engage \u00e0 ce que les r\u00e9sultats produits par l'utilisation de ses fonctions soient bien ceux d\u00e9crits dans l'interface, mais il est libre de s'y prendre comme il le souhaite. En particulier il est libre d'introduire des fonctions, variables, constantes, ..., qui ne sont pas inclues dans l'interface . On parle alors de fonctions, variables, constantes encapsul\u00e9es dans le module. Le contrat explicite est que l'utilisateur ne doit en aucun cas utiliser ces donn\u00e9es encapsul\u00e9es. Dans le cas contraire, si l'auteur du module change son approche et modifie ces donn\u00e9es internes, le programme du client risque de devenir non fonctionnel. Norme en Python En Python, l'auteur d'un module peut indiquer que certains \u00e9l\u00e9ments sont priv\u00e9s (= encapsul\u00e9s) en faisant commencer leur nom par un cracat\u00e8re underscore _ Exemple Imaginons un module secondDegre.py dont l'interface est d\u00e9finie ainsi : fonction Description polynome(t) V\u00e9rifie que le tuple t sous la forme (a,b,c) repr\u00e9sente bien un polyn\u00f4me de degr\u00e9 2 valeursRacines(p) Renvoie les valeurs des racines, et None si il n'existe pas de recines r\u00e9elles convexite(p) Renvoie la convexit\u00e9 de la courbe repr\u00e9sentative du polyn\u00f4me sous la forme d'une cha\u00eene de caract\u00e8re en minuscule tangente(p,x) Renvoie l'\u00e9quation de la tangente \u00e0 la courbe du polyn\u00f4me p en x Dans l'interface de ce module, on consid\u00e8re que le calcul du discriminant est une op\u00e9ration priv\u00e9e. On aurait alors comme possibilit\u00e9 d'impl\u00e9mentation (non compl\u00e8te): from math import sqrt def polynome ( t ) : a , b , * c = t if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or len ( c ) > 1 or not ( isinstance ( * c ,( int , float ))) : raise ValueError () if a == 0 : raise ValueError () return t def _discriminant ( p ) : a , b , c = polynome ( p ) return b ** 2 - 4 * a * c def _nombreRacines ( p ) : ... def valeursracines ( p ) : ... def convexite ( p ) : ... def _calcule ( p , x ) : ... def _nombreDerive ( p , x ) : ... def tangente ( p , x ) : ... Dans ce module, les fonctions pr\u00e9fix\u00e9es par _ sont consid\u00e9r\u00e9es comme priv\u00e9es, et ne faisant pas partie de l'interface. Exercice Cr\u00e9er un module secondDegre.py contenant a minima la totalit\u00e9 des fonctions pr\u00e9c\u00e9dentes, et impl\u00e9menter toutes ces fonctions. Une solution possible from math import sqrt def polynome ( t ) : a , b , * c = t if not ( isinstance ( a ,( int , float )) ) or not ( isinstance ( b ,( int , float )) ) or len ( c ) > 1 or not ( isinstance ( * c ,( int , float ))) : raise ValueError () if a == 0 : raise ValueError () return t def _discriminant ( p ) : a , b , c = polynome ( p ) return b ** 2 - 4 * a * c def _nombreRacines ( p ) : d = _discriminant ( p ) if d < 0 : return 0 elif d == 0 : return 1 else : return 2 def valeursRacines ( p ) : nbR = _nombreRacines ( p ) if nbR == 0 : return None elif nbR == 1 : a , b , c = p return - b / ( 2 * a ) else : a , b , c = p d = _discriminant ( p ) return ( - b - sqrt ( d )) / ( 2 * a ), ( - b + sqrt ( d )) / ( 2 * a ) def convexite ( p ) : a , b , c = polynome ( p ) if a > 0 : return \"convexe\" else : return \"concave\" def _calcule ( p , x ) : a , b , c = polynome ( p ) if not ( isinstance ( x , ( float , int ))) : raise valueError () else : return a * x ** 2 + b * x + c def _nombreDerive ( p , x ) : a , b , c = polynome ( p ) if not ( isinstance ( x , ( float , int ))) : raise valueError () else : return 2 * a * x + b def tangente ( p , x ) : return f 'y = { _nombreDerive ( p , x ) } (x- { x } ) + { _calcule ( p , x ) } ' Encapsulation dans d'autres langages Il faut noter que la notion de fonction ou variable priv\u00e9e en Python n'est qu'une convention. Rien n'emp\u00eache r\u00e9ellement l'utilisateur du module d'utiliser ces fonctions priv\u00e9es . C'est loin d'\u00eatre le cas dans d'autres langages (comme C++ ou Java ), qui introduisent un contr\u00f4le strict de l'encapsulation en rendant l'acc\u00e8s aux \u00e9l\u00e9ments priv\u00e9s impossible.","title":"Notions d'encapsulation"},{"location":"NSI/Terminale/C02/Recursivite/","text":"Notion de fonctions r\u00e9cursive Activit\u00e9 d'introduction : de l'it\u00e9ratif au r\u00e9cursif Un peu de maths : les suites arithm\u00e9tiques On rappelle qu'une suite \\((u_n)\\) , de premier terme \\(u_0\\) est dite arithm\u00e9tique si et seulement si \\[ u_{n+1} = u_n +r \\] o\u00f9 \\(r \\in \\mathbb{R}\\) . La d\u00e9finition donn\u00e9e ci-dessus est une d\u00e9finition dite par r\u00e9currence , c'est-\u00e0-dire qu'on d\u00e9finit le terme de rang \\(n+1\\) \u00e0 partir du terme de rang \\(n\\) . Cette suite peut-\u00eatre d\u00e9finie par une formule explicite : \\[ u_n = u_0 + n \\times r \\] Exercice Enonc\u00e9 Construire une fonction suiteArithmetique(n) qui calcule le \\(n\\) -i\u00e8me terme de la suite arithm\u00e9tique de premier terme 3 et de raison 7 . Quelle formule avez-vous utilis\u00e9e ? Une solution Au vu de l'\u00e9nonc\u00e9, je prends le pari que la majorit\u00e9 d'entre vous avez utilis\u00e9 la formule explicite avec un code de la forme suivante : def maSuiteArithmetique ( n ) : return 3 + n * 7 C'est \u00e9videmment la solution la plus simple. Dans ce cas, tout comme pour les suites g\u00e9om\u00e9trique , il est inutile de compliquer le code, nous obtenons directement la solution par un simple calcul alg\u00e9brique. Encore des maths : les suites arithm\u00e9tico-g\u00e9om\u00e9triques Une suite \\((u_n)\\) , de premier terme \\(u_0\\) est dite arithm\u00e9tico-g\u00e9om\u00e9trique si et seulement si \\[ u_{n+1} = a\\times u_n +b \\] o\u00f9 \\(a,b \\in \\mathbb{R}\\) . Encore une fois, la d\u00e9finition donn\u00e9e ci-dessus est une d\u00e9finition dite par r\u00e9currence , c'est-\u00e0-dire qu'on d\u00e9finit le terme de rang \\(n+1\\) \u00e0 partir du terme de rang \\(n\\) . Exercice Enonc\u00e9 Construire une fonction maSuiteAG(n) qui calcule le \\(n\\) -i\u00e8me terme de la suite arithm\u00e9tico-g\u00e9om\u00e9triqueq de premier terme 7 et d\u00e9finie par : \\[ u_{n+1} = -2\\times u_n +5 \\] Quelle formule avez-vous utilis\u00e9e ? Une solution probable Ici nous n'avons qu'une formule - sauf pour les petits malins qui seront all\u00e9 voir sur wikipedia - donc on doit utiliser un processus de r\u00e9p\u00e9tition des op\u00e9rations \u00e0 partir de 7 . On peut bien s\u00fbr appliquer une boucle pour dans notre fonction : def maSuiteAG ( n ) : u = 7 for i in range ( 1 , n + 1 ) : # j'utilise ce range plut\u00f4t que range(n) car le i utilis\u00e9 correspond au terme du rang calcul\u00e9. u = - 2 * u + 5 return u Deux remarques : dans ce code, je ne v\u00e9rifie pas que \\(n \\in \\mathbb{N}\\) , et il faudrait... ; dans le cas o\u00f9 \\(n=0\\) , la boucle for n'est pas effectu\u00e9e. Une telle fonction est dite it\u00e9rative , car elle utilise une boucle de r\u00e9p\u00e9titions pour parvenir au r\u00e9sultat souhait\u00e9. C'est vraiment dommage, dans le premier exercice, on utilise simplement la formule explicite , alors que dans le deuxi\u00e8me cas, on est oblig\u00e9 de r\u00e9fl\u00e9chir \u00e0 l'algorithme. Ce serait si simple de pouvoir utiliser directement la formule r\u00e9cursive , comme dans le code ci-dessous : def maSuiteAGR ( n ) : return - 2 * maSuiteAGR ( n - 1 ) + 5 Ca vaudrait peut-\u00eatre le coup de tester, en prenant \\(n=3\\) par exemple... K\u00e9sako ? Quand on teste la fonction maSuiteAGR(3) , python ... calcule... puis nous renvoie une erreur : RecursionError: maximum recursion depth exceeded Le mot important dans la phrase pr\u00e9c\u00e9dente, c'est que python CALCULE ! Donc il doit a minima comprendre la fonction maSuiteAGR ! Principe de r\u00e9cursivit\u00e9 Fonction r\u00e9cursive Une fonction est dite r\u00e9cursive quand elle s'appelle elle-m\u00eame, une ou plusieurs fois. Des probl\u00e8mes D\u00e9composons l'instruction l'appel \u00e0 maSuiteAGR(3) : maSuiteAGR(3) doit calculer -2*maSuiteAGR(2) +5 , et donc doit calculer : maSuiteAGR(2) , qui doit calculer -2*maSuiteAGR(1) +5 , et donc doit calculer : maSuiteAGR(1) , qui doit calculer -2*maSuiteAGR(0) +5 , et donc doit calculer : maSuiteAGR(0) , qui doit calculer -2*maSuiteAGR(-1) +5 , et donc doit calculer : maSuiteAGR(-1) , qui doit calculer -2*maSuiteAGR(-2) +5 , et donc doit calculer : ... \"HELP ! Mais \u00e7a s'arr\u00eate quand !\" me direz-vous ! Et bien jamais, en th\u00e9orie. Mais en r\u00e9alit\u00e9 cette instruction s'arr\u00eatera quand python aura lev\u00e9 une erreur de type RecursionError , qui signifie qu'une limite aura \u00e9t\u00e9 atteinte (nous en parlerons plus tard pour lever toute ambiguit\u00e9). Supprimer le probl\u00e8me : le cas d'arr\u00eat Pour supprimer le probl\u00e8me pr\u00e9c\u00e9dent, revenons aux maths : dans une d\u00e9finition par r\u00e9currence de suite, on signale toujours la valeur du premier terme (qui peut \u00eatre \\(u_0\\) , ou \\(u_1\\) , ou m\u00eame \\(u_{42}\\) selon le probl\u00e8me et la d\u00e9finition de l'indice). Or dans notre fonction maSuiteAGR , jamais nous ne pr\u00e9cisons ce cas, c'est-\u00e0-dire que quand \\(n=0\\) , alors la suite vaut \\(7\\) . Rajoutons-donc cette condition dans la fonction : def maSuiteAGR ( n ) : if n == 0 : return 7 else : return - 2 * maSuiteAGR ( n - 1 ) + 5 Et testons de nouveau maSuiteAGR(3) : maSuiteAGR(3) doit calculer -2*maSuiteAGR(2) +5 , et donc doit calculer : maSuiteAGR(2) , qui doit calculer -2*maSuiteAGR(1) +5 , et donc doit calculer : maSuiteAGR(1) , qui doit calculer -2*maSuiteAGR(0) +5 , et donc doit calculer : maSuiteAGR(0) , qui maintenant renvoie 7 ! donc maSuiteAGR(1) renvoie -2*7+5 soit -9 ; donc maSuiteAGR(2) renvoie -2*(-9)+5 soit 23 ; donc maSuiteAGR(3) renvoie -2*23+5 soit -41 . Non seulement la fonction s'arr\u00eate, mais en plus elle renvoie la bonne valeur, c'est-\u00e0-dire \\(u_3 = -41\\) . R\u00e9capitulons Pour utiliser une fonction r\u00e9cursive correctement, il faudra distinguer : le ou les cas d'arr\u00eats (ou cas de base ), c'est-\u00e0-dire des cas particuliers pour lesquels la valeur (ou l'objet) renvoy\u00e9 par la fonction est connu ; le cas r\u00e9cursif , pour lequel la fonction s'appelle elle-m\u00eame, une ou plusieurs fois. Exemple comment\u00e9 La somme des \\(n\\) premiers entiers est la somme : \\[ 0+1+2+3+...+n \\] Comment faire pour construire une fonction r\u00e9cursive sommeR(n) qui effectue la somme des \\(n\\) premiers entiers, avec \\(n\\) pass\u00e9 en argument. Quel est le cas r\u00e9cursif ? On a \\(0+1+2+3+...+n = (0+1+2+3+ ...+ (n-1) ) + n\\) , donc le cas r\u00e9cursif est sommeR(n) = sommeR(n-1) + n Quel est le cas de base ? Il y a plusieurs possibilit\u00e9s, soit en partant de l'indice 0 car sommeR(0)=0 , soit en partant de l'indice 1, car sommeR(1) = 1 . Une impl\u00e9mentation r\u00e9cursive possible est alors : def sommeR ( n ) : if n == 0 : return 0 else : return sommeR ( n - 1 ) + n Applications directes Exercice : factorielle Enonc\u00e9 On rappelle que la factorielle d'un entier naturel \\(n\\) est donn\u00e9 par : \\[ \\left\\lbrace \\begin{array}{rcl} n! &=& n \\times (n-1) \\times ... \\times 3 \\times 2 \\times 1\\\\ 1! &=& 1\\\\ 0! &=& 1 \\end{array}\\right. \\] Ecrire une fonction it\u00e9rative factorielle(n) qui renvoie la factorielle d'un entier naturel \\(n\\) donn\u00e9, et l\u00e8ve une ValueError si \\(n\\) n'est pas entier ou est n\u00e9gatif. Ecrire une fonction r\u00e9cursive factorielleR(n) qui renvoie la factorielle d'un entier naturel \\(n\\) donn\u00e9, et l\u00e8ve une ValueError si \\(n\\) n'est pas entier ou est n\u00e9gatif. Solution It\u00e9rative A venir Solution r\u00e9cursive A venir Exercice : \u00e9toiles Enonc\u00e9 Impl\u00e9menter une fonction it\u00e9rative etoile(n) qui \u00e9crit dans le Shell Python un triangle form\u00e9 de caract\u00e8res * tels que dans l'exemple suivant : >>> etoileR ( 5 ) * ** *** **** ***** 2. Imp\u00e9lmenter une fonction r\u00e9cursive etoileR(n) qui effectue le m\u00eame travail. Solution It\u00e9rative A venir Solution r\u00e9cursive A venir Coefficients binomiaux et triangle de Pascal Soient \\(a\\) et \\(b\\) deux r\u00e9els quelconques. D\u00e9veloppez les expressions suivantes : \\(A = (a+b)^1\\) \\(B = (a+b)^2\\) \\(C = (a+b)^3\\) \\(D = (a+b)^4\\) Solution A venir Compl\u00e9tez deux lignes suppl\u00e9mentaires du tableau suivant, nomm\u00e9 Triangle de Pascal : \\[ \\begin{array}{|c|c|c|c|c|c|} \\hline 1&1&&&&\\\\\\hline 1&2&1&&&\\\\\\hline 1&3&3&1&&\\\\\\hline 1&4&6&4&1&\\\\\\hline 1&5&10&10&5&1\\\\\\hline \\end{array} \\] Solution A venir On appelle coefficient binomial de rang \\(p\\) et de degr\u00e9 \\(n\\) le nombre du Triangle de Pascal correspondant \u00e0 la \\(n\\) -i\u00e8me ligne et \u00e0 la \\(p\\) _i\u00e8me colonne. Ce nombre est not\u00e9 \\(\\left(\\begin{array}{c} n\\\\ p\\\\ \\end{array}\\right)\\) . Comment exprimer r\u00e9cursivemment ce coefficient ? Solution A venir Impl\u00e9menter une fonction binomeR(n, p) qui renvoie la valeur du coefficient binomial \\(\\left(\\begin{array}{c} n\\\\ p\\\\ \\end{array}\\right)\\) du triangle de Pascal. Solution A venir *Facultatif : * Impl\u00e9menter une fonction developpe(n) qui renvoie la cha\u00eene de caract\u00e8res correspondant au d\u00e9veloppement de \\((a+b)^n\\) . Solution A venir","title":"Notion de r\u00e9cursivit\u00e9"},{"location":"NSI/Terminale/C02/Recursivite/#notion-de-fonctions-recursive","text":"","title":"Notion de fonctions r\u00e9cursive"},{"location":"NSI/Terminale/C02/Recursivite/#activite-dintroduction-de-literatif-au-recursif","text":"Un peu de maths : les suites arithm\u00e9tiques On rappelle qu'une suite \\((u_n)\\) , de premier terme \\(u_0\\) est dite arithm\u00e9tique si et seulement si \\[ u_{n+1} = u_n +r \\] o\u00f9 \\(r \\in \\mathbb{R}\\) . La d\u00e9finition donn\u00e9e ci-dessus est une d\u00e9finition dite par r\u00e9currence , c'est-\u00e0-dire qu'on d\u00e9finit le terme de rang \\(n+1\\) \u00e0 partir du terme de rang \\(n\\) . Cette suite peut-\u00eatre d\u00e9finie par une formule explicite : \\[ u_n = u_0 + n \\times r \\] Exercice Enonc\u00e9 Construire une fonction suiteArithmetique(n) qui calcule le \\(n\\) -i\u00e8me terme de la suite arithm\u00e9tique de premier terme 3 et de raison 7 . Quelle formule avez-vous utilis\u00e9e ? Une solution Au vu de l'\u00e9nonc\u00e9, je prends le pari que la majorit\u00e9 d'entre vous avez utilis\u00e9 la formule explicite avec un code de la forme suivante : def maSuiteArithmetique ( n ) : return 3 + n * 7 C'est \u00e9videmment la solution la plus simple. Dans ce cas, tout comme pour les suites g\u00e9om\u00e9trique , il est inutile de compliquer le code, nous obtenons directement la solution par un simple calcul alg\u00e9brique. Encore des maths : les suites arithm\u00e9tico-g\u00e9om\u00e9triques Une suite \\((u_n)\\) , de premier terme \\(u_0\\) est dite arithm\u00e9tico-g\u00e9om\u00e9trique si et seulement si \\[ u_{n+1} = a\\times u_n +b \\] o\u00f9 \\(a,b \\in \\mathbb{R}\\) . Encore une fois, la d\u00e9finition donn\u00e9e ci-dessus est une d\u00e9finition dite par r\u00e9currence , c'est-\u00e0-dire qu'on d\u00e9finit le terme de rang \\(n+1\\) \u00e0 partir du terme de rang \\(n\\) . Exercice Enonc\u00e9 Construire une fonction maSuiteAG(n) qui calcule le \\(n\\) -i\u00e8me terme de la suite arithm\u00e9tico-g\u00e9om\u00e9triqueq de premier terme 7 et d\u00e9finie par : \\[ u_{n+1} = -2\\times u_n +5 \\] Quelle formule avez-vous utilis\u00e9e ? Une solution probable Ici nous n'avons qu'une formule - sauf pour les petits malins qui seront all\u00e9 voir sur wikipedia - donc on doit utiliser un processus de r\u00e9p\u00e9tition des op\u00e9rations \u00e0 partir de 7 . On peut bien s\u00fbr appliquer une boucle pour dans notre fonction : def maSuiteAG ( n ) : u = 7 for i in range ( 1 , n + 1 ) : # j'utilise ce range plut\u00f4t que range(n) car le i utilis\u00e9 correspond au terme du rang calcul\u00e9. u = - 2 * u + 5 return u Deux remarques : dans ce code, je ne v\u00e9rifie pas que \\(n \\in \\mathbb{N}\\) , et il faudrait... ; dans le cas o\u00f9 \\(n=0\\) , la boucle for n'est pas effectu\u00e9e. Une telle fonction est dite it\u00e9rative , car elle utilise une boucle de r\u00e9p\u00e9titions pour parvenir au r\u00e9sultat souhait\u00e9. C'est vraiment dommage, dans le premier exercice, on utilise simplement la formule explicite , alors que dans le deuxi\u00e8me cas, on est oblig\u00e9 de r\u00e9fl\u00e9chir \u00e0 l'algorithme. Ce serait si simple de pouvoir utiliser directement la formule r\u00e9cursive , comme dans le code ci-dessous : def maSuiteAGR ( n ) : return - 2 * maSuiteAGR ( n - 1 ) + 5 Ca vaudrait peut-\u00eatre le coup de tester, en prenant \\(n=3\\) par exemple... K\u00e9sako ? Quand on teste la fonction maSuiteAGR(3) , python ... calcule... puis nous renvoie une erreur : RecursionError: maximum recursion depth exceeded Le mot important dans la phrase pr\u00e9c\u00e9dente, c'est que python CALCULE ! Donc il doit a minima comprendre la fonction maSuiteAGR !","title":"Activit\u00e9 d'introduction : de l'it\u00e9ratif au r\u00e9cursif"},{"location":"NSI/Terminale/C02/Recursivite/#principe-de-recursivite","text":"Fonction r\u00e9cursive Une fonction est dite r\u00e9cursive quand elle s'appelle elle-m\u00eame, une ou plusieurs fois. Des probl\u00e8mes D\u00e9composons l'instruction l'appel \u00e0 maSuiteAGR(3) : maSuiteAGR(3) doit calculer -2*maSuiteAGR(2) +5 , et donc doit calculer : maSuiteAGR(2) , qui doit calculer -2*maSuiteAGR(1) +5 , et donc doit calculer : maSuiteAGR(1) , qui doit calculer -2*maSuiteAGR(0) +5 , et donc doit calculer : maSuiteAGR(0) , qui doit calculer -2*maSuiteAGR(-1) +5 , et donc doit calculer : maSuiteAGR(-1) , qui doit calculer -2*maSuiteAGR(-2) +5 , et donc doit calculer : ... \"HELP ! Mais \u00e7a s'arr\u00eate quand !\" me direz-vous ! Et bien jamais, en th\u00e9orie. Mais en r\u00e9alit\u00e9 cette instruction s'arr\u00eatera quand python aura lev\u00e9 une erreur de type RecursionError , qui signifie qu'une limite aura \u00e9t\u00e9 atteinte (nous en parlerons plus tard pour lever toute ambiguit\u00e9). Supprimer le probl\u00e8me : le cas d'arr\u00eat Pour supprimer le probl\u00e8me pr\u00e9c\u00e9dent, revenons aux maths : dans une d\u00e9finition par r\u00e9currence de suite, on signale toujours la valeur du premier terme (qui peut \u00eatre \\(u_0\\) , ou \\(u_1\\) , ou m\u00eame \\(u_{42}\\) selon le probl\u00e8me et la d\u00e9finition de l'indice). Or dans notre fonction maSuiteAGR , jamais nous ne pr\u00e9cisons ce cas, c'est-\u00e0-dire que quand \\(n=0\\) , alors la suite vaut \\(7\\) . Rajoutons-donc cette condition dans la fonction : def maSuiteAGR ( n ) : if n == 0 : return 7 else : return - 2 * maSuiteAGR ( n - 1 ) + 5 Et testons de nouveau maSuiteAGR(3) : maSuiteAGR(3) doit calculer -2*maSuiteAGR(2) +5 , et donc doit calculer : maSuiteAGR(2) , qui doit calculer -2*maSuiteAGR(1) +5 , et donc doit calculer : maSuiteAGR(1) , qui doit calculer -2*maSuiteAGR(0) +5 , et donc doit calculer : maSuiteAGR(0) , qui maintenant renvoie 7 ! donc maSuiteAGR(1) renvoie -2*7+5 soit -9 ; donc maSuiteAGR(2) renvoie -2*(-9)+5 soit 23 ; donc maSuiteAGR(3) renvoie -2*23+5 soit -41 . Non seulement la fonction s'arr\u00eate, mais en plus elle renvoie la bonne valeur, c'est-\u00e0-dire \\(u_3 = -41\\) . R\u00e9capitulons Pour utiliser une fonction r\u00e9cursive correctement, il faudra distinguer : le ou les cas d'arr\u00eats (ou cas de base ), c'est-\u00e0-dire des cas particuliers pour lesquels la valeur (ou l'objet) renvoy\u00e9 par la fonction est connu ; le cas r\u00e9cursif , pour lequel la fonction s'appelle elle-m\u00eame, une ou plusieurs fois. Exemple comment\u00e9 La somme des \\(n\\) premiers entiers est la somme : \\[ 0+1+2+3+...+n \\] Comment faire pour construire une fonction r\u00e9cursive sommeR(n) qui effectue la somme des \\(n\\) premiers entiers, avec \\(n\\) pass\u00e9 en argument. Quel est le cas r\u00e9cursif ? On a \\(0+1+2+3+...+n = (0+1+2+3+ ...+ (n-1) ) + n\\) , donc le cas r\u00e9cursif est sommeR(n) = sommeR(n-1) + n Quel est le cas de base ? Il y a plusieurs possibilit\u00e9s, soit en partant de l'indice 0 car sommeR(0)=0 , soit en partant de l'indice 1, car sommeR(1) = 1 . Une impl\u00e9mentation r\u00e9cursive possible est alors : def sommeR ( n ) : if n == 0 : return 0 else : return sommeR ( n - 1 ) + n","title":"Principe de r\u00e9cursivit\u00e9"},{"location":"NSI/Terminale/C02/Recursivite/#applications-directes","text":"Exercice : factorielle Enonc\u00e9 On rappelle que la factorielle d'un entier naturel \\(n\\) est donn\u00e9 par : \\[ \\left\\lbrace \\begin{array}{rcl} n! &=& n \\times (n-1) \\times ... \\times 3 \\times 2 \\times 1\\\\ 1! &=& 1\\\\ 0! &=& 1 \\end{array}\\right. \\] Ecrire une fonction it\u00e9rative factorielle(n) qui renvoie la factorielle d'un entier naturel \\(n\\) donn\u00e9, et l\u00e8ve une ValueError si \\(n\\) n'est pas entier ou est n\u00e9gatif. Ecrire une fonction r\u00e9cursive factorielleR(n) qui renvoie la factorielle d'un entier naturel \\(n\\) donn\u00e9, et l\u00e8ve une ValueError si \\(n\\) n'est pas entier ou est n\u00e9gatif. Solution It\u00e9rative A venir Solution r\u00e9cursive A venir Exercice : \u00e9toiles Enonc\u00e9 Impl\u00e9menter une fonction it\u00e9rative etoile(n) qui \u00e9crit dans le Shell Python un triangle form\u00e9 de caract\u00e8res * tels que dans l'exemple suivant : >>> etoileR ( 5 ) * ** *** **** ***** 2. Imp\u00e9lmenter une fonction r\u00e9cursive etoileR(n) qui effectue le m\u00eame travail. Solution It\u00e9rative A venir Solution r\u00e9cursive A venir Coefficients binomiaux et triangle de Pascal Soient \\(a\\) et \\(b\\) deux r\u00e9els quelconques. D\u00e9veloppez les expressions suivantes : \\(A = (a+b)^1\\) \\(B = (a+b)^2\\) \\(C = (a+b)^3\\) \\(D = (a+b)^4\\) Solution A venir Compl\u00e9tez deux lignes suppl\u00e9mentaires du tableau suivant, nomm\u00e9 Triangle de Pascal : \\[ \\begin{array}{|c|c|c|c|c|c|} \\hline 1&1&&&&\\\\\\hline 1&2&1&&&\\\\\\hline 1&3&3&1&&\\\\\\hline 1&4&6&4&1&\\\\\\hline 1&5&10&10&5&1\\\\\\hline \\end{array} \\] Solution A venir On appelle coefficient binomial de rang \\(p\\) et de degr\u00e9 \\(n\\) le nombre du Triangle de Pascal correspondant \u00e0 la \\(n\\) -i\u00e8me ligne et \u00e0 la \\(p\\) _i\u00e8me colonne. Ce nombre est not\u00e9 \\(\\left(\\begin{array}{c} n\\\\ p\\\\ \\end{array}\\right)\\) . Comment exprimer r\u00e9cursivemment ce coefficient ? Solution A venir Impl\u00e9menter une fonction binomeR(n, p) qui renvoie la valeur du coefficient binomial \\(\\left(\\begin{array}{c} n\\\\ p\\\\ \\end{array}\\right)\\) du triangle de Pascal. Solution A venir *Facultatif : * Impl\u00e9menter une fonction developpe(n) qui renvoie la cha\u00eene de caract\u00e8res correspondant au d\u00e9veloppement de \\((a+b)^n\\) . Solution A venir","title":"Applications directes"},{"location":"NSI/Terminale/C02/RecursiviteApplications/","text":"Applications de la r\u00e9cursivit\u00e9 Dessiner des fractales avec turtle Commen\u00e7ons par cr\u00e9er un fichier fractales.py qui nous servira pour la totalit\u00e9 des exercices. Pr\u00e9sentation de turtle Le module turtle Le module turtle est un module faisant partie de toute distribution python . Son int\u00e9r\u00eat repose sur la simplicit\u00e9 (relative) des commandes utilis\u00e9es pour dessiner. Un objet de classe Turtle se comporte comme un crayon de table tra\u00e7ante sur une feuille de papier munie d'un rep\u00e8re orthonorm\u00e9. Exemple : premi\u00e8re fen\u00eatre et premi\u00e8re tortue Consid\u00e9rons le code suivant , ainsi que le r\u00e9sultat de son ex\u00e9cution : 1 2 3 4 5 6 7 8 9 10 11 import turtle def testTurtle () : screen = turtle . Screen () screen . bgcolor ( 'lightgray' ) donatello = turtle . Turtle () if __name__ == \"__main__\" : testTurtle () en ligne 1 on importe le module turtle compl\u00e8tement ; en ligne 4, on cr\u00e9e un objet Screen() sur lequel la tortue dessinera, cet objet \u00e9tant affect\u00e9 au nom screen ; en ligne 5, on fait appel \u00e0 la m\u00e9thode bgcolor des objets Screen afin de basculer la couleur de fond sur lightgray ; en ligne 6, on cr\u00e9e un objet Turtle affect\u00e9 au nom donatello . Vous observerez que la tortue est repr\u00e9sent\u00e9e par une pointe de fl\u00e8che , pointant vers la droite. Par d\u00e9faut, la tortue appara\u00eet au centre du rep\u00e8re, c'est-\u00e0-dire au centre de la fen\u00eatre de dessin, donc aux coordonn\u00e9es \\((0; 0)\\) . Nous allons maintenant rajouter au code les instructions suivantes en lignes 7 \u00e0 11, puis ex\u00e9cuter le code : 7 8 9 10 11 donatello . forward ( 100 ) donatello . left ( 90 ) donatello . forward ( 50 ) donatello . right ( 45 ) donatello . backward ( 80 ) Avec ces lignes : la tortue avance de 100 pixels dans la direction o\u00f9 elle pointe ; elle tourne vers sa gauche de 90\u00b0 ; elle avance de 50 pixels dans la nouvelle direction ; elle tourne vers sa droite de 45\u00b0 ; et enfin elle recule de 80 pixels. M\u00e9thodes de la classe Turtle Comme toujours, la doc python est tr\u00e8s claire sur le module turtle , mais voici quelques m\u00e9thodes des objets de classe Turle : forward(d) : d\u00e9place l'objet Turtle de \\(d\\) pixels dans la direction o\u00f9 pointe la t\u00eate de la tortue. A mettre en parall\u00e8le avec la m\u00e9thde backward(d) . left(a) : tourne la t\u00eate de la tortue vers sa gauche de \\(a\\) \u00b0. A mettre en parall\u00e8le avec la m\u00e9thode right(a) . goto(x,y) ou setx(v) ou sety(v) : d\u00e9place la tortue vers une position donn\u00e9e dans le rep\u00e8re. setheading(a) : tourne la t\u00eate de la tortue \u00e0 un angle de \\(a\\) \u00b0 par rapport \u00e0 l'horizontale, dans le sens trigonom\u00e9trique. circle(r) : trace \u00e0 partir de la position courante un cercle de rayon \\(r\\) , le centre \u00e9tant situ\u00e9 sur la gauche de la t\u00eate de la tortue. speed(v) : change la vitesse de d\u00e9placement de la tortue. L'argument est un entier de 0 \u00e0 10 tel que : \u00ab le plus rapide \u00bb : 0 \u00ab rapide \u00bb : 10 \u00ab vitesse normale \u00bb : 6 \u00ab lent \u00bb : 3 \u00ab le plus lent \u00bb : 1 pendown() et penup() : respectivement baisse ou l\u00e8ve le crayon. Si le crayon est lev\u00e9, rien n'est trac\u00e9 \u00e0 l'\u00e9cran. pensize(t) : r\u00e8gle l'\u00e9paisseur de trac\u00e9 \u00e0 \\(t\\) pixels. pencolor(*args) : r\u00e8gle la couleur du stylo. L'argument peut-\u00eatre : une cha\u00eene de caract\u00e8res : red , gray , ou #33cc8c , etc... un triplet RGB : (255, 100, 50) ,... fillcolor(*args) : d\u00e9finit la couleur de remplissage. begin_fill() et end_fill() : d\u00e9but et fin de la d\u00e9fintion d'une zone de remplissage. Je ne d\u00e9taillerai pas ici les m\u00e9thodes des objets Screen . Prise en main de turtle Enonc\u00e9 Cr\u00e9er une fonction triangleEquilateral(c) qui trace un triangle \u00e9quilat\u00e9ral de longueur \\(c\\) \u00e0 partir de la position courante. Cr\u00e9er une fonction pentagramme(c, color=\"red\") qui trace un pentagramme (une \u00e9toile \u00e0 5 branches) et le remplit avec la couleur pass\u00e9e en argument. Cr\u00e9er une fonction hexagone(c, diag = False) qui trace un hexagone de c\u00f4t\u00e9 \\(c\\) et qui trace en outre ses diagonales si le param\u00e8tre optionnel diag est pass\u00e9 \u00e0 True . Solutions A venir. Flocon de Von Koch Le Flocon de Von Koch Le flocon de Von Koch, invent\u00e9e en 1904 par le math\u00e9maticien su\u00e9dois Helge von Koch, est une des premi\u00e8res courbes fractales d\u00e9crites, avant m\u00eame l'invention du terme fractale par Benoit Mandelbrot en 1967. Cette courbe est obtenue par la d\u00e9composition r\u00e9cursive d'un segment en une ligne bris\u00e9e : Construction du flocon Avant de passer \u00e0 une d\u00e9finition r\u00e9cursive de la construction, essayons de faire une \u00e9tape de cette construction. === \"Enonc\u00e9\" a. Cr\u00e9er une fonction segment(l) qui trace une \u00e9tape de la construction du segment de Von Koch (c'est-\u00e0-dire une it\u00e9ration de la m\u00e9thode). b. Tester cette fonction en pla\u00e7ant la tortue dans diff\u00e9rentes positions de d\u00e9part. Solution A venir ! Passons \u00e0 la construction r\u00e9cursive d'un segment : Le triangle de Sierpinski Nouveaux algorithmes de tri Rappels sur les algorithmes de tri vus en premi\u00e8re Le Tri Fusion Encore plus vite : QuickSort","title":"Applications concr\u00e8tes"},{"location":"NSI/Terminale/C02/RecursiviteApplications/#applications-de-la-recursivite","text":"","title":"Applications de la r\u00e9cursivit\u00e9"},{"location":"NSI/Terminale/C02/RecursiviteApplications/#dessiner-des-fractales-avec-turtle","text":"Commen\u00e7ons par cr\u00e9er un fichier fractales.py qui nous servira pour la totalit\u00e9 des exercices.","title":"Dessiner des fractales avec turtle"},{"location":"NSI/Terminale/C02/RecursiviteApplications/#presentation-de-turtle","text":"Le module turtle Le module turtle est un module faisant partie de toute distribution python . Son int\u00e9r\u00eat repose sur la simplicit\u00e9 (relative) des commandes utilis\u00e9es pour dessiner. Un objet de classe Turtle se comporte comme un crayon de table tra\u00e7ante sur une feuille de papier munie d'un rep\u00e8re orthonorm\u00e9. Exemple : premi\u00e8re fen\u00eatre et premi\u00e8re tortue Consid\u00e9rons le code suivant , ainsi que le r\u00e9sultat de son ex\u00e9cution : 1 2 3 4 5 6 7 8 9 10 11 import turtle def testTurtle () : screen = turtle . Screen () screen . bgcolor ( 'lightgray' ) donatello = turtle . Turtle () if __name__ == \"__main__\" : testTurtle () en ligne 1 on importe le module turtle compl\u00e8tement ; en ligne 4, on cr\u00e9e un objet Screen() sur lequel la tortue dessinera, cet objet \u00e9tant affect\u00e9 au nom screen ; en ligne 5, on fait appel \u00e0 la m\u00e9thode bgcolor des objets Screen afin de basculer la couleur de fond sur lightgray ; en ligne 6, on cr\u00e9e un objet Turtle affect\u00e9 au nom donatello . Vous observerez que la tortue est repr\u00e9sent\u00e9e par une pointe de fl\u00e8che , pointant vers la droite. Par d\u00e9faut, la tortue appara\u00eet au centre du rep\u00e8re, c'est-\u00e0-dire au centre de la fen\u00eatre de dessin, donc aux coordonn\u00e9es \\((0; 0)\\) . Nous allons maintenant rajouter au code les instructions suivantes en lignes 7 \u00e0 11, puis ex\u00e9cuter le code : 7 8 9 10 11 donatello . forward ( 100 ) donatello . left ( 90 ) donatello . forward ( 50 ) donatello . right ( 45 ) donatello . backward ( 80 ) Avec ces lignes : la tortue avance de 100 pixels dans la direction o\u00f9 elle pointe ; elle tourne vers sa gauche de 90\u00b0 ; elle avance de 50 pixels dans la nouvelle direction ; elle tourne vers sa droite de 45\u00b0 ; et enfin elle recule de 80 pixels. M\u00e9thodes de la classe Turtle Comme toujours, la doc python est tr\u00e8s claire sur le module turtle , mais voici quelques m\u00e9thodes des objets de classe Turle : forward(d) : d\u00e9place l'objet Turtle de \\(d\\) pixels dans la direction o\u00f9 pointe la t\u00eate de la tortue. A mettre en parall\u00e8le avec la m\u00e9thde backward(d) . left(a) : tourne la t\u00eate de la tortue vers sa gauche de \\(a\\) \u00b0. A mettre en parall\u00e8le avec la m\u00e9thode right(a) . goto(x,y) ou setx(v) ou sety(v) : d\u00e9place la tortue vers une position donn\u00e9e dans le rep\u00e8re. setheading(a) : tourne la t\u00eate de la tortue \u00e0 un angle de \\(a\\) \u00b0 par rapport \u00e0 l'horizontale, dans le sens trigonom\u00e9trique. circle(r) : trace \u00e0 partir de la position courante un cercle de rayon \\(r\\) , le centre \u00e9tant situ\u00e9 sur la gauche de la t\u00eate de la tortue. speed(v) : change la vitesse de d\u00e9placement de la tortue. L'argument est un entier de 0 \u00e0 10 tel que : \u00ab le plus rapide \u00bb : 0 \u00ab rapide \u00bb : 10 \u00ab vitesse normale \u00bb : 6 \u00ab lent \u00bb : 3 \u00ab le plus lent \u00bb : 1 pendown() et penup() : respectivement baisse ou l\u00e8ve le crayon. Si le crayon est lev\u00e9, rien n'est trac\u00e9 \u00e0 l'\u00e9cran. pensize(t) : r\u00e8gle l'\u00e9paisseur de trac\u00e9 \u00e0 \\(t\\) pixels. pencolor(*args) : r\u00e8gle la couleur du stylo. L'argument peut-\u00eatre : une cha\u00eene de caract\u00e8res : red , gray , ou #33cc8c , etc... un triplet RGB : (255, 100, 50) ,... fillcolor(*args) : d\u00e9finit la couleur de remplissage. begin_fill() et end_fill() : d\u00e9but et fin de la d\u00e9fintion d'une zone de remplissage. Je ne d\u00e9taillerai pas ici les m\u00e9thodes des objets Screen . Prise en main de turtle Enonc\u00e9 Cr\u00e9er une fonction triangleEquilateral(c) qui trace un triangle \u00e9quilat\u00e9ral de longueur \\(c\\) \u00e0 partir de la position courante. Cr\u00e9er une fonction pentagramme(c, color=\"red\") qui trace un pentagramme (une \u00e9toile \u00e0 5 branches) et le remplit avec la couleur pass\u00e9e en argument. Cr\u00e9er une fonction hexagone(c, diag = False) qui trace un hexagone de c\u00f4t\u00e9 \\(c\\) et qui trace en outre ses diagonales si le param\u00e8tre optionnel diag est pass\u00e9 \u00e0 True . Solutions A venir.","title":"Pr\u00e9sentation de turtle"},{"location":"NSI/Terminale/C02/RecursiviteApplications/#flocon-de-von-koch","text":"Le Flocon de Von Koch Le flocon de Von Koch, invent\u00e9e en 1904 par le math\u00e9maticien su\u00e9dois Helge von Koch, est une des premi\u00e8res courbes fractales d\u00e9crites, avant m\u00eame l'invention du terme fractale par Benoit Mandelbrot en 1967. Cette courbe est obtenue par la d\u00e9composition r\u00e9cursive d'un segment en une ligne bris\u00e9e : Construction du flocon Avant de passer \u00e0 une d\u00e9finition r\u00e9cursive de la construction, essayons de faire une \u00e9tape de cette construction. === \"Enonc\u00e9\" a. Cr\u00e9er une fonction segment(l) qui trace une \u00e9tape de la construction du segment de Von Koch (c'est-\u00e0-dire une it\u00e9ration de la m\u00e9thode). b. Tester cette fonction en pla\u00e7ant la tortue dans diff\u00e9rentes positions de d\u00e9part. Solution A venir ! Passons \u00e0 la construction r\u00e9cursive d'un segment :","title":"Flocon de Von Koch"},{"location":"NSI/Terminale/C02/RecursiviteApplications/#le-triangle-de-sierpinski","text":"","title":"Le triangle de Sierpinski"},{"location":"NSI/Terminale/C02/RecursiviteApplications/#nouveaux-algorithmes-de-tri","text":"","title":"Nouveaux algorithmes de tri"},{"location":"NSI/Terminale/C02/RecursiviteApplications/#rappels-sur-les-algorithmes-de-tri-vus-en-premiere","text":"","title":"Rappels sur les algorithmes de tri vus en premi\u00e8re"},{"location":"NSI/Terminale/C02/RecursiviteApplications/#le-tri-fusion","text":"","title":"Le Tri Fusion"},{"location":"NSI/Terminale/C02/RecursiviteApplications/#encore-plus-vite-quicksort","text":"","title":"Encore plus vite : QuickSort"},{"location":"NSI/Terminale/C02/ToursHanoi/","text":"","title":"TP : Tours de Hano\u00ef"}]}